TMS9900 Application Binary Interface (ABI)

1) Purpose
  This ABI has been developed to specify the register usage and function calling
  conventions. The patched GCC compiler conforms to this document.

2) Omitted Instructions
  The TMS9900 supports several assembly instructions which have no analogue in
  higher-level code. As a result, these instructions will never be generated by
  the compiler. Assembly language must be used to take advantage of these
  instructions. The list of these instructions is shown below.

      BLWP - Branch with new workspace
      LDCR - Load CRU bits
      LIMI - Load interrupt mask
      LWPI - Specify workspace location
      RTWP - Return with new workspace
      SBO  - Set CRU bit to one
      SBZ  - Set CRU bit to zero
      STCR - Store CRU bits
      STST - Store status flags
      STWP - Store pointer to workspace
      TB   - Test CRU bit
      X    - Execute instruction stored at a location
      XOP  - Extended operation

3) Workspace Location
  The TMS9900 does not have any hardware registers. Instead, a region of RAM is
  used to store sixteen register values. The address of the workspace is set by
  using the LWPI instruction.

  The location of the workspace is irrelevant from the point of view of this
  ABI. All compiled code will run regardless of this location. That being said,
  0x8300 is a frequently used address.

4) Register Usage
  A role has been set for each of the registers. The compiled code will conform
  to these roles. Any assembly language modules must respect these role
  conventions.

  The roles were chosen to be friendly to instructions which use specific
  registers.

  All registers denoted as "Non-Volatile" will retain their values across a
  function call. All registers denoted as "Volatile" will not retain their
  values across a function call.

  Any function which uses registers denoted as "Non-Volatile" must save the
  existing value at the start of the function, and restore its value at the end
  of a function.

  The usage of each register is shown below.

      Name  ABI Role              Volatility    Hardware Role
      ----  -------------------   ----------    -------------
      R0    General Purpose,      Volatile      Bit Shift Count
      R1    Return Value
            Funtion Argument #1   Volatile
      R2    Funtion Argument #2   Volatile
      R3    Funtion Argument #3   Volatile
      R4    Funtion Argument #4   Volatile
      R5    Funtion Argument #5   Volatile
      R6    Funtion Argument #6   Volatile
      R7    General Purpose       Volatile
      R8    General Purpose       Volatile
      R9    General Purpose       Non-Volatile
      R10   Stack Pointer         Non-Volatile
      R11   Return Pointer        Non-Volatile  Return Pointer
      R12   General Purpose       Volatile      CRU Base
      R13   General Purpose       Non-Volatile  BLWP Saved Workspace
      R14   General Purpose       Non-Volatile  BLWP Return Pointer
      R15   General Purpose       Non-Volatile  BLWP Saved Status Flags

5) The Stack
  A stack is a requirement of most compiled languages. It is used to store
  local variables, the stack pointer and return pointer for each called function.
  As functions are called, the stack grows towards lower addresses. As called
  functons return, the stack shrinks towards higher addresses

  The R10 register is used to store the address of the last used address of the
  current stack frame. Please note, however, that the compiler does not
  initialize the value of the R10 register. It is the responsibility of the
  operating system loader to perfoem this initialization.

  The stack consists of a sequence of stack frames, one for each called
  function. The structure of an individual frame is shown below.

      To higher addresses --^
      -------------------  <--  End of caller's stack frame

      Stack argument #1
        ...
      Stack argument #N

      Start of local data
        ...
      End of local data

      Saved register #1
        ...
      Saved register #N
      Address of end of caller's stack frame  <-- Value of R10

      -------------------  <--  End of current stack frame
      To lower addresses --v

6) Argument passing
  The first six function arguments are passed by register to improve
  performance. If more than six arguments are needed, they will be passed on
  the stack.

  Arguments are numbered in the order in which they appear in a function call.
  The parameter nearest to the functon name is argument one. The example below
  will help illustrate this.

      int example_function (int arg1,
                            int arg2,
                            int arg3,
                            int arg4,
                            int arg5,
                            int arg6,
                            int arg7);

  In the example functon, "arg1" is the first argument, and is passed in
  register R1. Arguments "arg2" through "arg6" are passed in registers R2
  through R6 respectively. Argument "arg7" is passed in stack argument one.

  In the case of variadic functions, the first argument before the ellipsis is
  passed on the stack. Any arguments after that one are also passed on the
  stack. The example below will help illustrate this.

      int example_vfunction (int varg1,
                             int varg2,
                             ...);

  In this example function, "varg1" is passed in register R1. Argument "varg2"
  is passed in stack argument one. Any additional arguments are also passed on
  on th estack.

7) Return value
  Function return values are always passed in register R1.

