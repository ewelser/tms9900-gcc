diff -rupN binutils-2.19.1-original/bfd/archures.c binutils-2.19.1/bfd/archures.c
--- binutils-2.19.1-original/bfd/archures.c	2008-08-09 01:35:12.000000000 -0400
+++ binutils-2.19.1/bfd/archures.c	2024-03-11 22:39:47.440425847 -0400
@@ -407,6 +407,8 @@ DESCRIPTION
 .#define bfd_mach_z80            3 {* With ixl, ixh, iyl, and iyh.  *}
 .#define bfd_mach_z80full        7 {* All undocumented instructions.  *}
 .#define bfd_mach_r800           11 {* R800: successor with multiplication.  *}
+.  bfd_arch_tms9900,   {* Texas Instruments TMS9900 archetecture.  *}
+.#define bfd_mach_tms9900       1
 .  bfd_arch_last
 .  };
 */
@@ -501,6 +503,7 @@ extern const bfd_arch_info_type bfd_tic3
 extern const bfd_arch_info_type bfd_tic4x_arch;
 extern const bfd_arch_info_type bfd_tic54x_arch;
 extern const bfd_arch_info_type bfd_tic80_arch;
+extern const bfd_arch_info_type bfd_tms9900_arch;
 extern const bfd_arch_info_type bfd_v850_arch;
 extern const bfd_arch_info_type bfd_vax_arch;
 extern const bfd_arch_info_type bfd_we32k_arch;
@@ -570,6 +573,7 @@ static const bfd_arch_info_type * const
     &bfd_tic4x_arch,
     &bfd_tic54x_arch,
     &bfd_tic80_arch,
+    &bfd_tms9900_arch,
     &bfd_v850_arch,
     &bfd_vax_arch,
     &bfd_w65_arch,
diff -rupN binutils-2.19.1-original/bfd/bfd-in2.h binutils-2.19.1/bfd/bfd-in2.h
--- binutils-2.19.1-original/bfd/bfd-in2.h	2008-08-20 19:28:57.000000000 -0400
+++ binutils-2.19.1/bfd/bfd-in2.h	2024-03-11 22:39:47.240428418 -0400
@@ -2029,6 +2029,8 @@ enum bfd_architecture
 #define bfd_mach_z80            3 /* With ixl, ixh, iyl, and iyh.  */
 #define bfd_mach_z80full        7 /* All undocumented instructions.  */
 #define bfd_mach_r800           11 /* R800: successor with multiplication.  */
+  bfd_arch_tms9900,   /* Texas Instruments TMS9900 archetecture.  */
+#define bfd_mach_tms9900       1
   bfd_arch_last
   };
 
diff -rupN binutils-2.19.1-original/bfd/config.bfd binutils-2.19.1/bfd/config.bfd
--- binutils-2.19.1-original/bfd/config.bfd	2008-04-16 14:02:01.000000000 -0400
+++ binutils-2.19.1/bfd/config.bfd	2024-03-11 22:39:47.212428778 -0400
@@ -102,6 +102,7 @@ sparc*)		 targ_archs=bfd_sparc_arch ;;
 spu*)            targ_archs=bfd_spu_arch ;;
 strongarm*)	 targ_archs=bfd_arm_arch ;;
 thumb*)		 targ_archs=bfd_arm_arch ;;
+tms9900*)	 targ_archs=bfd_tms9900_arch ;;
 v850*)		 targ_archs=bfd_v850_arch ;;
 x86_64*)	 targ_archs=bfd_i386_arch ;;
 xscale*)	 targ_archs=bfd_arm_arch ;;
@@ -1432,6 +1433,10 @@ case "${targ}" in
     targ_underscore=yes
     ;;
 
+  tms9900-*-*)
+    targ_defvec=bfd_elf32_tms9900_vec
+    ;;
+
   v850-*-*)
     targ_defvec=bfd_elf32_v850_vec
     ;;
diff -rupN binutils-2.19.1-original/bfd/configure binutils-2.19.1/bfd/configure
--- binutils-2.19.1-original/bfd/configure	2009-02-02 05:44:37.000000000 -0500
+++ binutils-2.19.1/bfd/configure	2024-03-11 22:39:47.156429498 -0400
@@ -19740,6 +19740,7 @@ do
     bfd_elf32_sparc_vec)	tb="$tb elf32-sparc.lo elfxx-sparc.lo elf-vxworks.lo elf32.lo $elf" ;;
     bfd_elf32_sparc_vxworks_vec) tb="$tb elf32-sparc.lo elfxx-sparc.lo elf-vxworks.lo elf32.lo $elf" ;;
     bfd_elf32_spu_vec)		tb="$tb elf32-spu.lo elf32.lo $elf" ;;
+    bfd_elf32_tms9900_vec)	tb="$tb elf32-tms9900.lo elf32.lo $elf" ;;
     bfd_elf32_tradbigmips_vec)  tb="$tb elf32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_tradlittlemips_vec) tb="$tb elf32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo" ;;
     bfd_elf32_us_cris_vec)	tb="$tb elf32-cris.lo elf32.lo $elf" ;;
diff -rupN binutils-2.19.1-original/bfd/cpu-tms9900.c binutils-2.19.1/bfd/cpu-tms9900.c
--- binutils-2.19.1-original/bfd/cpu-tms9900.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.19.1/bfd/cpu-tms9900.c	2024-03-11 22:39:47.172429293 -0400
@@ -0,0 +1,57 @@
+/* BFD library support routines for the TMS9900 architecture.
+   Copyright 2009 Eric Welser
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+const bfd_arch_info_type bfd_tms9900_arch;
+
+/* This routine is provided two arch_infos and
+   returns whether they'd be compatible.  */
+
+static const bfd_arch_info_type *
+compatible (const bfd_arch_info_type *a, const bfd_arch_info_type *b)
+{
+  if (a->arch != b->arch)
+    return NULL;
+
+  if (a->mach == b->mach)
+    return a;
+
+  return (a->arch == bfd_arch_tms9900) ? & bfd_tms9900_arch : NULL;
+}
+
+
+const bfd_arch_info_type bfd_tms9900_arch = 
+{
+  16,                /* Bits per word */
+  16,                /* Bits per address */
+  8,                 /* Bits per byte */
+  bfd_arch_tms9900,  /* Architecture ID */
+  bfd_mach_tms9900,  /* Machine ID */
+  "tms9900",         /* Architecture name */
+  "tms9900",         /* Printable name */
+  0,                 /* Section align power */
+  TRUE,              /* Is this the default machine for this arch? */
+  compatible,        /* Function to determine object file compatibility */
+  bfd_default_scan,  /* Scan function */
+  NULL               /* Next record */
+};
diff -rupN binutils-2.19.1-original/bfd/doc/archures.texi binutils-2.19.1/bfd/doc/archures.texi
--- binutils-2.19.1-original/bfd/doc/archures.texi	2008-09-10 03:50:16.000000000 -0400
+++ binutils-2.19.1/bfd/doc/archures.texi	2024-03-11 22:39:47.392426464 -0400
@@ -372,6 +372,8 @@ enum bfd_architecture
 #define bfd_mach_z80            3 /* With ixl, ixh, iyl, and iyh.  */
 #define bfd_mach_z80full        7 /* All undocumented instructions.  */
 #define bfd_mach_r800           11 /* R800: successor with multiplication.  */
+  bfd_arch_tms9900,   /* Texas Instruments TMS9900 archetecture.  */
+#define bfd_mach_tms9900       1
   bfd_arch_last
   @};
 @end example
diff -rupN binutils-2.19.1-original/bfd/elf32-tms9900.c binutils-2.19.1/bfd/elf32-tms9900.c
--- binutils-2.19.1-original/bfd/elf32-tms9900.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.19.1/bfd/elf32-tms9900.c	2024-03-11 22:39:47.368426773 -0400
@@ -0,0 +1,128 @@
+#include "sysdep.h"
+#include "bfd.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "bfd_stdint.h"
+
+#include "elf/tms9900.h"
+
+
+#ifdef DEBUG_GEN_RELOC
+#define TRACE(str) \
+  fprintf (stderr, "tms9900 bfd reloc lookup %d (%s)\n", code, str)
+#else
+#define TRACE(str)
+#endif
+
+extern const bfd_target bfd_elf32_tms9900_vec;
+
+static reloc_howto_type elf_howto_table[]=
+{
+  /* Invalid record, do nothing */
+  HOWTO(R_TMS9900_NONE,             /* type */
+        0,                          /* rightshift */
+        0,                          /* size (0 = byte, 1 = short, 2 = long) */
+        0,                          /* bitsize */
+        FALSE,                      /* pc_relative */
+        0,                          /* bitpos */
+        complain_overflow_bitfield, /* complain on overflow */
+	bfd_elf_generic_reloc,      /* special_function */
+        "R_TMS9900_NONE",           /* name */
+	FALSE,                      /* partial_inplace */
+        0x00000000,                 /* src_mask */
+        0x00000000,                 /* dst_mask */
+        FALSE),                     /* pcrel_offset */
+
+  /* 8-bit offset from current PC, used in jump commands */
+  HOWTO(R_TMS9900_PC8,              /* type */
+        1,                          /* rightshift */
+        0,                          /* size (0 = byte, 1 = short, 2 = long) */
+        8,                          /* bitsize */
+        TRUE,                       /* pc_relative */
+        0,                          /* bitpos */
+        complain_overflow_signed,   /* complain on overflow */
+        bfd_elf_generic_reloc,      /* special_function */
+        "R_TMS9900_PC8",            /* name */
+        FALSE,                      /* partial_inplace */
+        0x00000000,                 /* src_mask */
+        0x000000FF,                 /* dst_mask */
+        TRUE),                      /* pcrel_offset */
+
+  /* Generic 16-bit constant */
+  HOWTO(R_TMS9900_16,               /* type */
+        0,                          /* rightshift */
+        1,                          /* size (0 = byte, 1 = short, 2 = long) */
+        16,                         /* bitsize */
+        FALSE,                      /* pc_relative */
+        0,                          /* bitpos */
+        complain_overflow_bitfield, /* complain on overflow */
+        bfd_elf_generic_reloc,      /* special_function */
+        "R_TMS9900_16",             /* name */
+        FALSE,                      /* partial_inplace */
+        0x00000000,                 /* src_mask */
+        0x0000FFFF,                 /* dst_mask */
+        FALSE),                     /* pcrel_offset */
+};  
+
+
+static reloc_howto_type *
+elf_tms9900_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				bfd_reloc_code_real_type code)
+{
+  switch (code)
+    {
+    case BFD_RELOC_NONE:
+      TRACE ("BFD_RELOC_NONE");
+      return &elf_howto_table[R_TMS9900_NONE];
+
+    case BFD_RELOC_16:
+      TRACE ("BFD_RELOC_16");
+      return &elf_howto_table[R_TMS9900_16];
+
+    case BFD_RELOC_8_PCREL:
+      TRACE ("BFD_RELOC_8_PCREL");
+      return &elf_howto_table[R_TMS9900_PC8];
+
+    default:
+      break;
+    }
+
+  TRACE ("Unknown");
+  return 0;
+}
+
+static reloc_howto_type *
+elf_tms9900_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0; i < sizeof (elf_howto_table) / sizeof (elf_howto_table[0]); i++)
+    if (elf_howto_table[i].name != NULL
+	&& strcasecmp (elf_howto_table[i].name, r_name) == 0)
+      return &elf_howto_table[i];
+
+  return NULL;
+}
+
+static void
+tms9900_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
+		           arelent *cache_ptr,
+		           Elf_Internal_Rela *dst)
+{
+  cache_ptr->howto = &elf_howto_table[ELF32_R_TYPE (dst->r_info)];
+}
+
+#define TARGET_BIG_SYM			bfd_elf32_tms9900_vec
+#define TARGET_BIG_NAME			"elf32-tms9900"
+#define ELF_ARCH			bfd_arch_tms9900
+#define ELF_MACHINE_CODE		EM_TMS9900
+#define ELF_MAXPAGESIZE			0x200
+
+#define bfd_elf32_bfd_reloc_type_lookup	      elf_tms9900_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup	      elf_tms9900_reloc_name_lookup
+#define elf_info_to_howto                     tms9900_elf_info_to_howto
+#define elf_info_to_howto_rel                 _bfd_elf_no_info_to_howto
+
+#include "elf32-target.h"
diff -rupN binutils-2.19.1-original/bfd/Makefile.in binutils-2.19.1/bfd/Makefile.in
--- binutils-2.19.1-original/bfd/Makefile.in	2009-02-02 05:44:39.000000000 -0500
+++ binutils-2.19.1/bfd/Makefile.in	2024-03-11 22:39:47.236428470 -0400
@@ -546,6 +546,7 @@ BFD32_BACKENDS = \
 	elfxx-sparc.lo \
 	elf32-sparc.lo \
 	elf32-spu.lo \
+	elf32-tms9900.lo\
 	elf32-v850.lo \
 	elf32-vax.lo \
 	elf32-xstormy16.lo \
@@ -2140,6 +2141,9 @@ elf32-spu.lo: elf32-spu.c $(INCDIR)/file
   $(INCDIR)/bfdlink.h $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
   $(INCDIR)/elf/external.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/spu.h \
   $(INCDIR)/elf/reloc-macros.h elf32-spu.h elf32-target.h
+elf32-tms9900.lo: elf32-tms9900.c $(INCDIR)/filenames.h $(INCDIR)/bfdlink.h\
+  $(INCDIR)/elf/external.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/tms9900.h \
+  $(INCDIR)/elf/reloc-macros.h elf32-spu.h elf32-target.h
 elf32-v850.lo: elf32-v850.c $(INCDIR)/filenames.h $(INCDIR)/bfdlink.h \
   $(INCDIR)/hashtab.h elf-bfd.h $(INCDIR)/elf/common.h \
   $(INCDIR)/elf/external.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/v850.h \
diff -rupN binutils-2.19.1-original/bfd/targets.c binutils-2.19.1/bfd/targets.c
--- binutils-2.19.1-original/bfd/targets.c	2008-02-14 10:20:26.000000000 -0500
+++ binutils-2.19.1/bfd/targets.c	2024-03-11 22:39:47.204428881 -0400
@@ -660,6 +660,7 @@ extern const bfd_target bfd_elf32_shvxwo
 extern const bfd_target bfd_elf32_sparc_vec;
 extern const bfd_target bfd_elf32_sparc_vxworks_vec;
 extern const bfd_target bfd_elf32_spu_vec;
+extern const bfd_target bfd_elf32_tms9900_vec;
 extern const bfd_target bfd_elf32_tradbigmips_vec;
 extern const bfd_target bfd_elf32_tradlittlemips_vec;
 extern const bfd_target bfd_elf32_us_cris_vec;
diff -rupN binutils-2.19.1-original/binutils/doc/nlmconv.1 binutils-2.19.1/binutils/doc/nlmconv.1
--- binutils-2.19.1-original/binutils/doc/nlmconv.1	2008-09-10 03:50:26.000000000 -0400
+++ binutils-2.19.1/binutils/doc/nlmconv.1	2024-03-11 22:39:48.520412086 -0400
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -46,23 +38,36 @@
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.    nr % 0
-.    rr F
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -128,7 +133,11 @@
 .\" ========================================================================
 .\"
 .IX Title "NLMCONV 1"
-.TH NLMCONV 1 "2008-09-10" "binutils-2.18.90" "GNU Development Tools"
+.TH NLMCONV 1 "2015-07-10" "binutils-2.19.1" "GNU Development Tools"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 nlmconv \- converts object code into an NLM.
 .SH "SYNOPSIS"
@@ -147,7 +156,7 @@ reading \fIheaderfile\fR for \s-1NLM\s0
 on writing the \s-1NLM\s0 command file language used in header files, see the
 \&\fBlinkers\fR section, \fB\s-1NLMLINK\s0\fR in particular, of the \fI\s-1NLM\s0
 Development and Tools Overview\fR, which is part of the \s-1NLM\s0 Software
-Developer's Kit (\*(L"\s-1NLM\s0 \s-1SDK\s0\*(R"), available from Novell, Inc.
+Developer's Kit (\*(L"\s-1NLM SDK\*(R"\s0), available from Novell, Inc.
 \&\fBnlmconv\fR uses the \s-1GNU\s0 Binary File Descriptor library to read
 \&\fIinfile\fR;
 .PP
@@ -219,7 +228,7 @@ Prints the version number for \fBnlmconv
 Read command-line options from \fIfile\fR.  The options read are
 inserted in place of the original @\fIfile\fR option.  If \fIfile\fR
 does not exist, or cannot be read, then the option will be treated
-literally, and not removed.  
+literally, and not removed.
 .Sp
 Options in \fIfile\fR are separated by whitespace.  A whitespace
 character may be included in an option by surrounding the entire
diff -rupN binutils-2.19.1-original/binutils/doc/nm.1 binutils-2.19.1/binutils/doc/nm.1
--- binutils-2.19.1-original/binutils/doc/nm.1	2008-09-10 03:50:26.000000000 -0400
+++ binutils-2.19.1/binutils/doc/nm.1	2024-03-11 22:39:48.520412086 -0400
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -46,23 +38,36 @@
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.    nr % 0
-.    rr F
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -128,7 +133,11 @@
 .\" ========================================================================
 .\"
 .IX Title "NM 1"
-.TH NM 1 "2008-09-10" "binutils-2.18.90" "GNU Development Tools"
+.TH NM 1 "2015-07-10" "binutils-2.19.1" "GNU Development Tools"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 nm \- list symbols from object files
 .SH "SYNOPSIS"
@@ -145,7 +154,7 @@ nm [\fB\-a\fR|\fB\-\-debug\-syms\fR] [\f
    [\fB\-V\fR|\fB\-\-version\fR] [\fB\-X 32_64\fR] [\fB\-\-help\fR]  [\fIobjfile\fR...]
 .SH "DESCRIPTION"
 .IX Header "DESCRIPTION"
-\&\s-1GNU\s0 \fBnm\fR lists the symbols from object files \fIobjfile\fR....
+\&\s-1GNU \s0\fBnm\fR lists the symbols from object files \fIobjfile\fR....
 If no object files are listed as arguments, \fBnm\fR assumes the file
 \&\fIa.out\fR.
 .PP
@@ -315,7 +324,7 @@ Display all symbols, even debugger-only
 listed.
 .IP "\fB\-B\fR" 4
 .IX Item "-B"
-The same as \fB\-\-format=bsd\fR (for compatibility with the \s-1MIPS\s0 \fBnm\fR).
+The same as \fB\-\-format=bsd\fR (for compatibility with the \s-1MIPS \s0\fBnm\fR).
 .IP "\fB\-C\fR" 4
 .IX Item "-C"
 .PD 0
@@ -326,7 +335,7 @@ Decode (\fIdemangle\fR) low-level symbol
 Besides removing any initial underscore prepended by the system, this
 makes \*(C+ function names readable. Different compilers have different
 mangling styles. The optional demangling style argument can be used to
-choose an appropriate demangling style for your compiler. 
+choose an appropriate demangling style for your compiler.
 .IP "\fB\-\-no\-demangle\fR" 4
 .IX Item "--no-demangle"
 Do not demangle low-level symbol names.  This is the default.
@@ -391,7 +400,7 @@ encountered.
 .IP "\fB\-\-portability\fR" 4
 .IX Item "--portability"
 .PD
-Use the \s-1POSIX\s0.2 standard output format instead of the default format.
+Use the \s-1POSIX.2\s0 standard output format instead of the default format.
 Equivalent to \fB\-f posix\fR.
 .IP "\fB\-S\fR" 4
 .IX Item "-S"
@@ -464,8 +473,8 @@ Show the version number of \fBnm\fR and
 .IX Item "-X"
 This option is ignored for compatibility with the \s-1AIX\s0 version of
 \&\fBnm\fR.  It takes one parameter which must be the string
-\&\fB32_64\fR.  The default mode of \s-1AIX\s0 \fBnm\fR corresponds
-to \fB\-X 32\fR, which is not supported by \s-1GNU\s0 \fBnm\fR.
+\&\fB32_64\fR.  The default mode of \s-1AIX \s0\fBnm\fR corresponds
+to \fB\-X 32\fR, which is not supported by \s-1GNU \s0\fBnm\fR.
 .IP "\fB\-\-help\fR" 4
 .IX Item "--help"
 Show a summary of the options to \fBnm\fR and exit.
@@ -474,7 +483,7 @@ Show a summary of the options to \fBnm\f
 Read command-line options from \fIfile\fR.  The options read are
 inserted in place of the original @\fIfile\fR option.  If \fIfile\fR
 does not exist, or cannot be read, then the option will be treated
-literally, and not removed.  
+literally, and not removed.
 .Sp
 Options in \fIfile\fR are separated by whitespace.  A whitespace
 character may be included in an option by surrounding the entire
diff -rupN binutils-2.19.1-original/binutils/doc/objcopy.1 binutils-2.19.1/binutils/doc/objcopy.1
--- binutils-2.19.1-original/binutils/doc/objcopy.1	2008-09-10 03:50:26.000000000 -0400
+++ binutils-2.19.1/binutils/doc/objcopy.1	2024-03-11 22:39:48.520412086 -0400
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -46,23 +38,36 @@
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.    nr % 0
-.    rr F
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -128,7 +133,11 @@
 .\" ========================================================================
 .\"
 .IX Title "OBJCOPY 1"
-.TH OBJCOPY 1 "2008-09-10" "binutils-2.18.90" "GNU Development Tools"
+.TH OBJCOPY 1 "2015-07-10" "binutils-2.19.1" "GNU Development Tools"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 objcopy \- copy and translate object files
 .SH "SYNOPSIS"
@@ -199,8 +208,8 @@ objcopy [\fB\-F\fR \fIbfdname\fR|\fB\-\-
         \fIinfile\fR [\fIoutfile\fR]
 .SH "DESCRIPTION"
 .IX Header "DESCRIPTION"
-The \s-1GNU\s0 \fBobjcopy\fR utility copies the contents of an object
-file to another.  \fBobjcopy\fR uses the \s-1GNU\s0 \s-1BFD\s0 Library to
+The \s-1GNU \s0\fBobjcopy\fR utility copies the contents of an object
+file to another.  \fBobjcopy\fR uses the \s-1GNU BFD\s0 Library to
 read and write the object files.  It can write the destination object
 file in a format different from that of the source object file.  The
 exact behavior of \fBobjcopy\fR is controlled by command-line options.
@@ -212,7 +221,7 @@ between any two formats may not work as
 deletes them afterward.  \fBobjcopy\fR uses \s-1BFD\s0 to do all its
 translation work; it has access to all the formats described in \s-1BFD\s0
 and thus is able to recognize most formats without being told
-explicitly.  
+explicitly.
 .PP
 \&\fBobjcopy\fR can be used to generate S\-records by using an output
 target of \fBsrec\fR (e.g., use \fB\-O srec\fR).
@@ -253,7 +262,7 @@ the name of \fIinfile\fR.
 .IX Item "--input-target=bfdname"
 .PD
 Consider the source file's object format to be \fIbfdname\fR, rather than
-attempting to deduce it.  
+attempting to deduce it.
 .IP "\fB\-O\fR \fIbfdname\fR" 4
 .IX Item "-O bfdname"
 .PD 0
@@ -269,7 +278,7 @@ Write the output file using the object f
 .PD
 Use \fIbfdname\fR as the object format for both the input and the output
 file; i.e., simply transfer data from source to destination with no
-translation.  
+translation.
 .IP "\fB\-B\fR \fIbfdarch\fR" 4
 .IX Item "-B bfdarch"
 .PD 0
@@ -387,7 +396,7 @@ point (!) then the sense of the switch i
 For example:
 .Sp
 .Vb 1
-\&          -w -W !foo -W fo*
+\&          \-w \-W !foo \-W fo*
 .Ve
 .Sp
 would cause objcopy to weaken all symbols that start with \*(L"fo\*(R"
@@ -417,7 +426,7 @@ Keep only every \fIbyte\fRth byte of the
 affected).  \fIbyte\fR can be in the range from 0 to \fIinterleave\fR\-1,
 where \fIinterleave\fR is given by the \fB\-i\fR or \fB\-\-interleave\fR
 option, or the default of 4.  This option is useful for creating files
-to program \s-1ROM\s0.  It is typically used with an \f(CW\*(C`srec\*(C'\fR output
+to program \s-1ROM. \s0 It is typically used with an \f(CW\*(C`srec\*(C'\fR output
 target.
 .IP "\fB\-i\fR \fIinterleave\fR" 4
 .IX Item "-i interleave"
@@ -495,7 +504,7 @@ Set or change the \s-1LMA\s0 address of
 address is the address where the section will be loaded into memory at
 program load time.  Normally this is the same as the \s-1VMA\s0 address, which
 is the address of the section at program run time, but on some systems,
-especially those where a program is held in \s-1ROM\s0, the two can be
+especially those where a program is held in \s-1ROM,\s0 the two can be
 different.  If \fB=\fR is used, the section address is set to
 \&\fIval\fR.  Otherwise, \fIval\fR is added to or subtracted from the
 section address.  See the comments under \fB\-\-change\-addresses\fR,
@@ -508,7 +517,7 @@ address is the address where the section
 program has started executing.  Normally this is the same as the \s-1LMA\s0
 address, which is the address where the section will be loaded into
 memory, but on some systems, especially those where a program is held in
-\&\s-1ROM\s0, the two can be different.  If \fB=\fR is used, the section address
+\&\s-1ROM,\s0 the two can be different.  If \fB=\fR is used, the section address
 is set to \fIval\fR.  Otherwise, \fIval\fR is added to or subtracted
 from the section address.  See the comments under
 \&\fB\-\-change\-addresses\fR, above.  If \fIsection\fR does not exist in
@@ -563,8 +572,8 @@ you wanted instead to create a section c
 data you could use the following command line to achieve it:
 .Sp
 .Vb 3
-\&          objcopy -I binary -O <output_format> -B <architecture> \e
-\&           --rename-section .data=.rodata,alloc,load,readonly,data,contents \e
+\&          objcopy \-I binary \-O <output_format> \-B <architecture> \e
+\&           \-\-rename\-section .data=.rodata,alloc,load,readonly,data,contents \e
 \&           <input_binary_file> <output_object_file>
 .Ve
 .IP "\fB\-\-change\-leading\-char\fR" 4
@@ -738,7 +747,7 @@ needed if debugging abilities are requir
 to create these files is as follows:
 .RS 4
 .IP "1.<Link the executable as normal.  Assuming that is is called>" 4
-.IX Item "1.<Link the executable as normal.  Assuming that is is called>"
+.IX Item "1.<Link the executable as normal. Assuming that is is called>"
 \&\f(CW\*(C`foo\*(C'\fR then...
 .ie n .IP "1.<Run ""objcopy \-\-only\-keep\-debug foo foo.dbg"" to>" 4
 .el .IP "1.<Run \f(CWobjcopy \-\-only\-keep\-debug foo foo.dbg\fR to>" 4
@@ -761,9 +770,9 @@ optional.  You could instead do this:
 .IP "1.<Link the executable as normal.>" 4
 .IX Item "1.<Link the executable as normal.>"
 .PD 0
-.ie n .IP "1.<Copy ""foo""\fR to  \f(CW""foo.full"">" 4
+.ie n .IP "1.<Copy ""foo"" to  ""foo.full"">" 4
 .el .IP "1.<Copy \f(CWfoo\fR to  \f(CWfoo.full\fR>" 4
-.IX Item "1.<Copy foo to  foo.full>"
+.IX Item "1.<Copy foo to foo.full>"
 .ie n .IP "1.<Run ""objcopy \-\-strip\-debug foo"">" 4
 .el .IP "1.<Run \f(CWobjcopy \-\-strip\-debug foo\fR>" 4
 .IX Item "1.<Run objcopy --strip-debug foo>"
@@ -831,7 +840,7 @@ Display a list showing all architectures
 Read command-line options from \fIfile\fR.  The options read are
 inserted in place of the original @\fIfile\fR option.  If \fIfile\fR
 does not exist, or cannot be read, then the option will be treated
-literally, and not removed.  
+literally, and not removed.
 .Sp
 Options in \fIfile\fR are separated by whitespace.  A whitespace
 character may be included in an option by surrounding the entire
diff -rupN binutils-2.19.1-original/binutils/doc/size.1 binutils-2.19.1/binutils/doc/size.1
--- binutils-2.19.1-original/binutils/doc/size.1	2008-09-10 03:50:27.000000000 -0400
+++ binutils-2.19.1/binutils/doc/size.1	2024-03-11 22:39:48.520412086 -0400
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -46,23 +38,36 @@
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.    nr % 0
-.    rr F
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -128,7 +133,11 @@
 .\" ========================================================================
 .\"
 .IX Title "SIZE 1"
-.TH SIZE 1 "2008-09-10" "binutils-2.18.90" "GNU Development Tools"
+.TH SIZE 1 "2015-07-10" "binutils-2.19.1" "GNU Development Tools"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 size \- list section sizes and total size.
 .SH "SYNOPSIS"
@@ -142,7 +151,7 @@ size [\fB\-A\fR|\fB\-B\fR|\fB\-\-format=
      [\fIobjfile\fR...]
 .SH "DESCRIPTION"
 .IX Header "DESCRIPTION"
-The \s-1GNU\s0 \fBsize\fR utility lists the section sizes\-\-\-and the total
+The \s-1GNU \s0\fBsize\fR utility lists the section sizes\-\-\-and the total
 size\-\-\-for each of the object or archive files \fIobjfile\fR in its
 argument list.  By default, one line of output is generated for each
 object file or each module in an archive.
@@ -160,8 +169,8 @@ The command line options have the follow
 .IP "\fB\-\-format=\fR\fIcompatibility\fR" 4
 .IX Item "--format=compatibility"
 .PD
-Using one of these options, you can choose whether the output from \s-1GNU\s0
-\&\fBsize\fR resembles output from System V \fBsize\fR (using \fB\-A\fR,
+Using one of these options, you can choose whether the output from \s-1GNU
+\&\s0\fBsize\fR resembles output from System V \fBsize\fR (using \fB\-A\fR,
 or \fB\-\-format=sysv\fR), or Berkeley \fBsize\fR (using \fB\-B\fR, or
 \&\fB\-\-format=berkeley\fR).  The default is the one-line format similar to
 Berkeley's.
@@ -170,7 +179,7 @@ Here is an example of the Berkeley (defa
 \&\fBsize\fR:
 .Sp
 .Vb 4
-\&        $ size --format=Berkeley ranlib size
+\&        $ size \-\-format=Berkeley ranlib size
 \&        text    data    bss     dec     hex     filename
 \&        294880  81920   11592   388392  5ed28   ranlib
 \&        294880  81920   11888   388688  5ee50   size
@@ -179,16 +188,15 @@ Here is an example of the Berkeley (defa
 This is the same data, but displayed closer to System V conventions:
 .Sp
 .Vb 7
-\&        $ size --format=SysV ranlib size
+\&        $ size \-\-format=SysV ranlib size
 \&        ranlib  :
 \&        section         size         addr
 \&        .text         294880         8192
 \&        .data          81920       303104
 \&        .bss           11592       385024
 \&        Total         388392
-.Ve
-.Sp
-.Vb 6
+\&        
+\&        
 \&        size  :
 \&        section         size         addr
 \&        .text         294880         8192
@@ -244,7 +252,7 @@ Display the version number of \fBsize\fR
 Read command-line options from \fIfile\fR.  The options read are
 inserted in place of the original @\fIfile\fR option.  If \fIfile\fR
 does not exist, or cannot be read, then the option will be treated
-literally, and not removed.  
+literally, and not removed.
 .Sp
 Options in \fIfile\fR are separated by whitespace.  A whitespace
 character may be included in an option by surrounding the entire
diff -rupN binutils-2.19.1-original/binutils/doc/strings.1 binutils-2.19.1/binutils/doc/strings.1
--- binutils-2.19.1-original/binutils/doc/strings.1	2008-09-10 03:50:27.000000000 -0400
+++ binutils-2.19.1/binutils/doc/strings.1	2024-03-11 22:39:48.524412036 -0400
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -46,23 +38,36 @@
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.    nr % 0
-.    rr F
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -128,7 +133,11 @@
 .\" ========================================================================
 .\"
 .IX Title "STRINGS 1"
-.TH STRINGS 1 "2008-09-10" "binutils-2.18.90" "GNU Development Tools"
+.TH STRINGS 1 "2015-07-10" "binutils-2.19.1" "GNU Development Tools"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 strings \- print the strings of printable characters in files.
 .SH "SYNOPSIS"
@@ -142,7 +151,7 @@ strings [\fB\-afov\fR] [\fB\-\fR\fImin-l
         [\fB\-\-help\fR] [\fB\-\-version\fR] \fIfile\fR...
 .SH "DESCRIPTION"
 .IX Header "DESCRIPTION"
-For each \fIfile\fR given, \s-1GNU\s0 \fBstrings\fR prints the printable
+For each \fIfile\fR given, \s-1GNU \s0\fBstrings\fR prints the printable
 character sequences that are at least 4 characters long (or the number
 given with the options below) and are followed by an unprintable
 character.  By default, it only prints the strings from the initialized
@@ -205,7 +214,7 @@ octal, \fBx\fR for hexadecimal, or \fBd\
 .PD
 Select the character encoding of the strings that are to be found.
 Possible values for \fIencoding\fR are: \fBs\fR = single\-7\-bit\-byte
-characters (\s-1ASCII\s0, \s-1ISO\s0 8859, etc., default), \fBS\fR =
+characters (\s-1ASCII, ISO 8859,\s0 etc., default), \fBS\fR =
 single\-8\-bit\-byte characters, \fBb\fR = 16\-bit bigendian, \fBl\fR =
 16\-bit littleendian, \fBB\fR = 32\-bit bigendian, \fBL\fR = 32\-bit
 littleendian.  Useful for finding wide character strings. (\fBl\fR
@@ -229,7 +238,7 @@ Print the program version number on the
 Read command-line options from \fIfile\fR.  The options read are
 inserted in place of the original @\fIfile\fR option.  If \fIfile\fR
 does not exist, or cannot be read, then the option will be treated
-literally, and not removed.  
+literally, and not removed.
 .Sp
 Options in \fIfile\fR are separated by whitespace.  A whitespace
 character may be included in an option by surrounding the entire
diff -rupN binutils-2.19.1-original/binutils/doc/strip.1 binutils-2.19.1/binutils/doc/strip.1
--- binutils-2.19.1-original/binutils/doc/strip.1	2008-09-10 03:50:27.000000000 -0400
+++ binutils-2.19.1/binutils/doc/strip.1	2024-03-11 22:39:48.524412036 -0400
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -46,23 +38,36 @@
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.    nr % 0
-.    rr F
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -128,7 +133,11 @@
 .\" ========================================================================
 .\"
 .IX Title "STRIP 1"
-.TH STRIP 1 "2008-09-10" "binutils-2.18.90" "GNU Development Tools"
+.TH STRIP 1 "2015-07-10" "binutils-2.19.1" "GNU Development Tools"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 strip \- Discard symbols from object files.
 .SH "SYNOPSIS"
@@ -151,7 +160,7 @@ strip [\fB\-F\fR \fIbfdname\fR |\fB\-\-t
       \fIobjfile\fR...
 .SH "DESCRIPTION"
 .IX Header "DESCRIPTION"
-\&\s-1GNU\s0 \fBstrip\fR discards all symbols from object files
+\&\s-1GNU \s0\fBstrip\fR discards all symbols from object files
 \&\fIobjfile\fR.  The list of object files may include archives.
 At least one object file must be given.
 .PP
@@ -261,7 +270,7 @@ point (!) then the sense of the switch i
 For example:
 .Sp
 .Vb 1
-\&          -w -K !foo -K fo*
+\&          \-w \-K !foo \-K fo*
 .Ve
 .Sp
 would cause strip to only keep symbols that start with the letters
@@ -300,7 +309,7 @@ needed if debugging abilities are requir
 to create these files is as follows:
 .RS 4
 .IP "1.<Link the executable as normal.  Assuming that is is called>" 4
-.IX Item "1.<Link the executable as normal.  Assuming that is is called>"
+.IX Item "1.<Link the executable as normal. Assuming that is is called>"
 \&\f(CW\*(C`foo\*(C'\fR then...
 .ie n .IP "1.<Run ""objcopy \-\-only\-keep\-debug foo foo.dbg"" to>" 4
 .el .IP "1.<Run \f(CWobjcopy \-\-only\-keep\-debug foo foo.dbg\fR to>" 4
@@ -323,7 +332,7 @@ optional.  You could instead do this:
 .IP "1.<Link the executable as normal.>" 4
 .IX Item "1.<Link the executable as normal.>"
 .PD 0
-.ie n .IP "1.<Copy ""foo""\fR to \f(CW""foo.full"">" 4
+.ie n .IP "1.<Copy ""foo"" to ""foo.full"">" 4
 .el .IP "1.<Copy \f(CWfoo\fR to \f(CWfoo.full\fR>" 4
 .IX Item "1.<Copy foo to foo.full>"
 .ie n .IP "1.<Run ""strip \-\-strip\-debug foo"">" 4
@@ -367,7 +376,7 @@ archives, \fBstrip \-v\fR lists all memb
 Read command-line options from \fIfile\fR.  The options read are
 inserted in place of the original @\fIfile\fR option.  If \fIfile\fR
 does not exist, or cannot be read, then the option will be treated
-literally, and not removed.  
+literally, and not removed.
 .Sp
 Options in \fIfile\fR are separated by whitespace.  A whitespace
 character may be included in an option by surrounding the entire
diff -rupN binutils-2.19.1-original/binutils/doc/windmc.1 binutils-2.19.1/binutils/doc/windmc.1
--- binutils-2.19.1-original/binutils/doc/windmc.1	2008-09-10 03:50:28.000000000 -0400
+++ binutils-2.19.1/binutils/doc/windmc.1	2024-03-11 22:39:48.524412036 -0400
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -46,23 +38,36 @@
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.    nr % 0
-.    rr F
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -128,7 +133,11 @@
 .\" ========================================================================
 .\"
 .IX Title "WINDMC 1"
-.TH WINDMC 1 "2008-09-10" "binutils-2.18.90" "GNU Development Tools"
+.TH WINDMC 1 "2015-07-10" "binutils-2.19.1" "GNU Development Tools"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 windmc \- generates Windows message resources.
 .SH "SYNOPSIS"
@@ -170,7 +179,7 @@ Windows Message Compiler.
 .IP "\fB\-\-ascii_in\fR" 4
 .IX Item "--ascii_in"
 .PD
-Specifies that the input file specified is \s-1ANSI\s0. This is the default
+Specifies that the input file specified is \s-1ANSI.\s0 This is the default
 behaviour.
 .IP "\fB\-A\fR" 4
 .IX Item "-A"
@@ -201,7 +210,7 @@ Sets the customer bit in all message id'
 .IP "\fB\-\-codepage_in\fR \fIcodepage\fR" 4
 .IX Item "--codepage_in codepage"
 .PD
-Sets the default codepage to be used to convert input file to \s-1UTF16\s0. The
+Sets the default codepage to be used to convert input file to \s-1UTF16.\s0 The
 default is ocdepage 1252.
 .IP "\fB\-d\fR" 4
 .IX Item "-d"
@@ -258,7 +267,7 @@ of any message exceeds the number specif
 .IX Item "--nullterminate"
 .PD
 Terminate message text in \f(CW\*(C`bin\*(C'\fR files by zero. By default they are
-terminated by \s-1CR/LF\s0.
+terminated by \s-1CR/LF.\s0
 .IP "\fB\-o\fR" 4
 .IX Item "-o"
 .PD 0
@@ -291,7 +300,7 @@ is the current directory.
 .IP "\fB\-\-unicode_in\fR" 4
 .IX Item "--unicode_in"
 .PD
-Specifies that the input file is \s-1UTF16\s0.
+Specifies that the input file is \s-1UTF16.\s0
 .IP "\fB\-U\fR" 4
 .IX Item "-U"
 .PD 0
@@ -327,7 +336,7 @@ symbolic name. No such file is generated
 Read command-line options from \fIfile\fR.  The options read are
 inserted in place of the original @\fIfile\fR option.  If \fIfile\fR
 does not exist, or cannot be read, then the option will be treated
-literally, and not removed.  
+literally, and not removed.
 .Sp
 Options in \fIfile\fR are separated by whitespace.  A whitespace
 character may be included in an option by surrounding the entire
diff -rupN binutils-2.19.1-original/binutils/readelf.c binutils-2.19.1/binutils/readelf.c
--- binutils-2.19.1-original/binutils/readelf.c	2008-09-17 05:00:44.000000000 -0400
+++ binutils-2.19.1/binutils/readelf.c	2024-03-11 22:39:48.516412137 -0400
@@ -152,6 +152,7 @@
 #include "elf/sh.h"
 #include "elf/sparc.h"
 #include "elf/spu.h"
+#include "elf/tms9900.h"
 #include "elf/v850.h"
 #include "elf/vax.h"
 #include "elf/x86-64.h"
@@ -1198,6 +1199,10 @@ dump_relocations (FILE *file,
 	case EM_CR16_OLD:
 	  rtype = elf_cr16_reloc_type (type);
 	  break;
+
+        case EM_TMS9900:
+          rtype = elf_tms9900_reloc_type (type);
+          break;
 	}
 
       if (rtype == NULL)
@@ -1825,6 +1830,7 @@ get_machine_name (unsigned e_machine)
     case EM_CYGNUS_MEP:         return "Toshiba MeP Media Engine";
     case EM_CR16:		
     case EM_CR16_OLD:		return "National Semiconductor's CR16";
+    case EM_TMS9900:            return "Texas Instruments TMS9900";
     default:
       snprintf (buff, sizeof (buff), _("<unknown>: 0x%x"), e_machine);
       return buff;
diff -rupN binutils-2.19.1-original/cgen/cpu/fr30.cpu binutils-2.19.1/cgen/cpu/fr30.cpu
--- binutils-2.19.1-original/cgen/cpu/fr30.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/fr30.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,1863 +0,0 @@
-
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-(include "simplify.inc")
-
-; define-arch must appear first
-
-(define-arch
-  (name fr30) ; name of cpu family
-  (comment "Fujitsu FR30")
-  (default-alignment forced)
-  (insn-lsb0? #f)
-  (machs fr30)
-  (isas fr30)
-)
-
-(define-isa
-  (name fr30)
-  (base-insn-bitsize 16)
-  (decode-assist (0 1 2 3 4 5 6 7)) ; Initial bitnumbers to decode insns by.
-  (liw-insns 1)       ; The fr30 fetches  1 insn at a time.
-  (parallel-insns 1)  ; The fr30 executes 1 insn at a time.
-)
-
-(define-cpu
-  ; cpu names must be distinct from the architecture name and machine names.
-  ; The "b" suffix stands for "base" and is the convention.
-  ; The "f" suffix stands for "family" and is the convention.
-  (name fr30bf)
-  (comment "Fujitsu FR30 base family")
-  (endian big)
-  (word-bitsize 32)
-)
-
-(define-mach
-  (name fr30)
-  (comment "Generic FR30 cpu")
-  (cpu fr30bf)
-)
-
-; Model descriptions.
-;
-(define-model
-  (name fr30-1) (comment "fr30-1") (attrs)
-  (mach fr30)
-
-  (pipeline all "" () ((fetch) (decode) (execute) (writeback)))
-
-  ; `state' is a list of variables for recording model state
-  (state
-   ; bit mask of h-gr registers loaded from memory by previous insn
-   (load-regs UINT)
-   ; bit mask of h-gr registers loaded from memory by current insn
-   (load-regs-pending UINT)
-   )
-
-  (unit u-exec "Execution Unit" ()
-	1 1 ; issue done
-	() ; state
-	((Ri INT -1) (Rj INT -1)) ; inputs
-	((Ri INT -1)) ; outputs
-	() ; profile action (default)
-	)
-  (unit u-cti "Branch Unit" ()
-	1 1 ; issue done
-	() ; state
-	((Ri INT -1)) ; inputs
-	((pc)) ; outputs
-	() ; profile action (default)
-	)
-  (unit u-load "Memory Load Unit" ()
-	1 1 ; issue done
-	() ; state
-	((Rj INT -1)
-	 ;(ld-mem AI)
-	 ) ; inputs
-	((Ri INT -1)) ; outputs
-	() ; profile action (default)
-	)
-  (unit u-store "Memory Store Unit" ()
-	1 1 ; issue done
-	() ; state
-	((Ri INT -1) (Rj INT -1)) ; inputs
-	() ; ((st-mem AI)) ; outputs
-	() ; profile action (default)
-	)
-  (unit u-ldm "LDM Memory Load Unit" ()
-	1 1 ; issue done
-	() ; state
-	((reglist INT)) ; inputs
-	() ; outputs
-	() ; profile action (default)
-	)
-  (unit u-stm "STM Memory Store Unit" ()
-	1 1 ; issue done
-	() ; state
-	((reglist INT)) ; inputs
-	() ; outputs
-	() ; profile action (default)
-	)
-)
-
-; The instruction fetch/execute cycle.
-;
-; This is how to fetch and decode an instruction.
-; Leave it out for now
-
-; (define-extract (const SI 0))
-
-; This is how to execute a decoded instruction.
-; Leave it out for now
-
-; (define-execute (const SI 0))
-
-; Instruction fields.
-;
-; Attributes:
-; PCREL-ADDR: pc relative value (for reloc and disassembly purposes)
-; ABS-ADDR: absolute address (for reloc and disassembly purposes?)
-; RESERVED: bits are not used to decode insn, must be all 0
-
-(dnf f-op1       "1st 4 bits of opcode"  ()  0  4)
-(dnf f-op2       "2nd 4 bits of opcode"  ()  4  4)
-(dnf f-op3       "3rd 4 bits of opcode"  ()  8  4)
-(dnf f-op4       "4th 4 bits of opcode"  () 12  4)
-(dnf f-op5       "5th bit of opcode"     ()  4  1)
-(dnf f-cc        "condition code"        ()  4  4)
-(dnf f-ccc       "coprocessor calc code" () 16  8)
-(dnf f-Rj        "register Rj"           ()  8  4)
-(dnf f-Ri        "register Ri"           () 12  4)
-(dnf f-Rs1       "register Rs"           ()  8  4)
-(dnf f-Rs2       "register Rs"           () 12  4)
-(dnf f-Rjc       "register Rj"           () 24  4)
-(dnf f-Ric       "register Ri"           () 28  4)
-(dnf f-CRj       "coprocessor register"  () 24  4)
-(dnf f-CRi       "coprocessor register"  () 28  4)
-(dnf f-u4        "4 bit 0 extended"      ()  8  4)
-(dnf f-u4c       "4 bit 0 extended"      () 12  4)
-(df  f-i4        "4 bit sign extended"   ()  8  4 INT #f #f)
-(df  f-m4        "4 bit minus extended"  ()  8  4 UINT
-     ((value pc) (and WI value (const #xf)))
-     ; ??? On a 64 bit host this doesn't get completely sign extended
-     ; if the value is recorded in a long, as it is during extraction.
-     ; Various fixes exist, pick one.
-     ((value pc) (or  WI value (sll WI (const -1) (const 4))))
-)
-(dnf f-u8        "8 bit unsigned"        ()  8  8)
-(dnf f-i8        "8 bit unsigned"        ()  4  8)
-
-(dnf  f-i20-4     "upper 4 bits of i20"  ()  8  4)
-(dnf  f-i20-16    "lower 16 bits of i20" () 16 16)
-(dnmf f-i20       "20 bit unsigned"      () UINT
-      (f-i20-4 f-i20-16)
-      (sequence () ; insert
-		(set (ifield f-i20-4)  (srl (ifield f-i20) (const 16)))
-		(set (ifield f-i20-16) (and (ifield f-i20) (const #xffff)))
-		)
-      (sequence () ; extract
-		(set (ifield f-i20) (or (sll (ifield f-i20-4) (const 16))
-					(ifield f-i20-16)))
-		)
-)
-
-(dnf f-i32       "32 bit immediate"      (SIGN-OPT) 16 32)
-
-(df  f-udisp6    "6 bit unsigned offset" ()  8  4 UINT
-     ((value pc) (srl UWI value (const 2)))
-     ((value pc) (sll UWI value (const 2)))
-)
-(df  f-disp8     "8 bit signed offset"   ()  4  8 INT #f #f)
-(df  f-disp9     "9 bit signed offset"   ()  4  8 INT
-    ((value pc) (sra WI value (const 1)))
-    ((value pc) (sll WI value (const 1)))
-)
-(df  f-disp10    "10 bit signed offset"  ()  4  8 INT
-     ((value pc) (sra WI value (const 2)))
-     ((value pc) (sll WI value (const 2)))
-)
-(df  f-s10       "10 bit signed offset"  ()  8  8 INT
-     ((value pc) (sra WI value (const 2)))
-     ((value pc) (sll WI value (const 2)))
-)
-(df  f-u10       "10 bit unsigned offset" ()  8  8 UINT
-     ((value pc) (srl UWI value (const 2)))
-     ((value pc) (sll UWI value (const 2)))
-)
-(df  f-rel9 "9 pc relative signed offset" (PCREL-ADDR) 8 8 INT
-     ((value pc) (sra WI (sub WI value (add WI pc (const 2))) (const 1)))
-     ((value pc) (add WI (sll WI value (const 1)) (add WI pc (const 2))))
-)
-(dnf f-dir8      "8  bit direct address"  ()  8  8)
-(df  f-dir9      "9  bit direct address"  ()  8  8 UINT
-     ((value pc) (srl UWI value (const 1)))
-     ((value pc) (sll UWI value (const 1)))
-)
-(df  f-dir10     "10 bit direct address"  ()  8  8 UINT
-     ((value pc) (srl UWI value (const 2)))
-     ((value pc) (sll UWI value (const 2)))
-)
-(df  f-rel12     "12 bit pc relative signed offset" (PCREL-ADDR) 5 11 INT
-     ((value pc) (sra WI (sub WI value (add WI pc (const 2))) (const 1)))
-     ((value pc) (add WI (sll WI value (const 1)) (add WI pc (const 2))))
-)
-
-(dnf f-reglist_hi_st  "8 bit register mask for stm" () 8 8)
-(dnf f-reglist_low_st "8 bit register mask for stm" () 8 8)
-(dnf f-reglist_hi_ld  "8 bit register mask for ldm" () 8 8)
-(dnf f-reglist_low_ld "8 bit register mask for ldm" () 8 8)
-
-; Enums.
-
-; insn-op1: bits 0-3
-; FIXME: should use die macro or some such
-(define-normal-insn-enum insn-op1 "insn op1 enums" () OP1_ f-op1
-  ("0" "1" "2" "3" "4" "5" "6" "7"
-   "8" "9" "A" "B" "C" "D" "E" "F")
-)
-
-; insn-op2: bits 4-7
-; FIXME: should use die macro or some such
-(define-normal-insn-enum insn-op2 "insn op2 enums" () OP2_ f-op2
-  ("0" "1" "2" "3" "4" "5" "6" "7"
-   "8" "9" "A" "B" "C" "D" "E" "F")
-)
-
-; insn-op3: bits 8-11
-; FIXME: should use die macro or some such
-(define-normal-insn-enum insn-op3 "insn op3 enums" () OP3_ f-op3
-  ("0" "1" "2" "3" "4" "5" "6" "7"
-   "8" "9" "A" "B" "C" "D" "E" "F")
-)
-
-; insn-op4: bits 12-15
-; FIXME: should use die macro or some such
-(define-normal-insn-enum insn-op4 "insn op4 enums" () OP4_ f-op4
-  ("0")
-)
-
-; insn-op5: bit 4 (5th bit origin 0)
-; FIXME: should use die macro or some such
-(define-normal-insn-enum insn-op5 "insn op5 enums" () OP5_ f-op5
-  ("0" "1")
-)
-
-; insn-cc: condition codes
-; FIXME: should use die macro or some such
-(define-normal-insn-enum insn-cc "insn cc enums" () CC_ f-cc
-  ("ra" "no" "eq" "ne" "c" "nc" "n" "p" "v" "nv" "lt" "ge" "le" "gt" "ls" "hi")
-)
-
-; Hardware pieces.
-; These entries list the elements of the raw hardware.
-; They're also used to provide tables and other elements of the assembly
-; language.
-
-(dnh h-pc "program counter" (PC PROFILE) (pc) () () ())
-
-(define-keyword
-  (name gr-names)
-  (print-name h-gr)
-  (prefix "")
-  (values (r0 0) (r1 1) (r2 2) (r3 3) (r4 4) (r5 5) (r6 6) (r7 7)
-	  (r8 8) (r9 9) (r10 10) (r11 11) (r12 12) (r13 13) (r14 14) (r15 15)
-	  (ac 13) (fp 14) (sp 15))
-)
-
-(define-hardware
-  (name h-gr)
-  (comment "general registers")
-  (attrs PROFILE CACHE-ADDR)
-  (type register WI (16))
-  (indices extern-keyword gr-names)
-)
-
-(define-keyword
-  (name cr-names)
-  (print-name h-cr)
-  (prefix "")
-  (values (cr0 0) (cr1 1) (cr2 2) (cr3 3)
-	  (cr4 4) (cr5 5) (cr6 6) (cr7 7)
-	  (cr8 8) (cr9 9) (cr10 10) (cr11 11)
-	  (cr12 12) (cr13 13) (cr14 14) (cr15 15))
-)
-
-(define-hardware
-  (name h-cr)
-  (comment "coprocessor registers")
-  (attrs)
-  (type register WI (16))
-  (indices extern-keyword cr-names)
-)
-
-(define-keyword
-  (name dr-names)
-  (print-name h-dr)
-  (prefix "")
-  (values (tbr 0) (rp 1) (ssp 2) (usp 3) (mdh 4) (mdl 5))
-)
-
-(define-hardware
-  (name h-dr)
-  (comment "dedicated registers")
-  (type register WI (6))
-  (indices extern-keyword dr-names)
-  (get (index) (c-call WI "@cpu@_h_dr_get_handler" index))
-  (set (index newval) (c-call VOID "@cpu@_h_dr_set_handler" index newval))
-)
-
-(define-hardware
-  (name h-ps)
-  (comment "processor status")
-  (type register UWI)
-  (indices keyword "" ((ps 0)))
-  (get () (c-call UWI "@cpu@_h_ps_get_handler"))
-  (set (newval) (c-call VOID "@cpu@_h_ps_set_handler" newval))
-)
-
-(dnh h-r13 "General Register 13 explicitly required"
-    ()
-    (register WI)
-    (keyword "" ((r13 0)))
-    () ()
-)
-
-(dnh h-r14 "General Register 14 explicitly required"
-    ()
-    (register WI)
-    (keyword "" ((r14 0)))
-    () ()
-)
-
-(dnh h-r15 "General Register 15 explicitly required"
-    ()
-    (register WI)
-    (keyword "" ((r15 0)))
-    () ()
-)
-
-; These bits are actually part of the PS register but are accessed more
-; often than the entire register, so define them directly. We can assemble
-; the PS register from its components when necessary.
-
-(dsh h-nbit  "negative         bit" ()           (register BI))
-(dsh h-zbit  "zero             bit" ()           (register BI))
-(dsh h-vbit  "overflow         bit" ()           (register BI))
-(dsh h-cbit  "carry            bit" ()           (register BI))
-(dsh h-ibit  "interrupt enable bit" ()           (register BI))
-(define-hardware
-  (name h-sbit)
-  (comment "stack bit")
-  (type register BI)
-  (get () (c-call BI "@cpu@_h_sbit_get_handler"))
-  (set (newval) (c-call VOID "@cpu@_h_sbit_set_handler" newval))
-)
-(dsh h-tbit  "trace trap       bit" ()           (register BI))
-(dsh h-d0bit "division 0       bit" ()           (register BI))
-(dsh h-d1bit "division 1       bit" ()           (register BI))
-
-; These represent sub-registers within the program status register
-
-(define-hardware
-  (name h-ccr)
-  (comment "condition code bits")
-  (type register UQI)
-  (get () (c-call UQI "@cpu@_h_ccr_get_handler"))
-  (set (newval) (c-call VOID "@cpu@_h_ccr_set_handler" newval))
-)
-(define-hardware
-  (name h-scr)
-  (comment "system condition bits")
-  (type register UQI)
-  (get () (c-call UQI "@cpu@_h_scr_get_handler"))
-  (set (newval) (c-call VOID "@cpu@_h_scr_set_handler" newval))
-)
-(define-hardware
-  (name h-ilm)
-  (comment "interrupt level mask")
-  (type register UQI)
-  (get () (c-call UQI "@cpu@_h_ilm_get_handler"))
-  (set (newval) (c-call VOID "@cpu@_h_ilm_set_handler" newval))
-)
-
-; Instruction Operands.
-; These entries provide a layer between the assembler and the raw hardware
-; description, and are used to refer to hardware elements in the semantic
-; code.  Usually there's a bit of over-specification, but in more complicated
-; instruction sets there isn't.
-
-; FR30 specific operand attributes:
-
-(define-attr
-  (for operand)
-  (type boolean)
-  (name HASH-PREFIX)
-  (comment "immediates have an optional '#' prefix")
-)
-
-; ??? Convention says this should be o-sr, but then the insn definitions
-; should refer to o-sr which is clumsy.  The "o-" could be implicit, but
-; then it should be implicit for all the symbols here, but then there would
-; be confusion between (f-)simm8 and (h-)simm8.
-; So for now the rule is exactly as it appears here.
-
-(dnop Ri      "destination register"         ()            h-gr   f-Ri)
-(dnop Rj      "source register"              ()            h-gr   f-Rj)
-(dnop Ric     "target register coproc insn"  ()            h-gr   f-Ric)
-(dnop Rjc     "source register coproc insn"  ()            h-gr   f-Rjc)
-(dnop CRi     "coprocessor register"         ()            h-cr   f-CRi)
-(dnop CRj     "coprocessor register"         ()            h-cr   f-CRj)
-(dnop Rs1     "dedicated register"           ()            h-dr   f-Rs1)
-(dnop Rs2     "dedicated register"           ()            h-dr   f-Rs2)
-(dnop R13     "General Register 13"          ()            h-r13  f-nil)
-(dnop R14     "General Register 14"          ()            h-r14  f-nil)
-(dnop R15     "General Register 15"          ()            h-r15  f-nil)
-(dnop ps      "Program Status register"      ()            h-ps   f-nil)
-(dnop u4      "4  bit unsigned immediate"    (HASH-PREFIX) h-uint f-u4)
-(dnop u4c     "4  bit unsigned immediate"    (HASH-PREFIX) h-uint f-u4c)
-(dnop u8      "8  bit unsigned immediate"    (HASH-PREFIX) h-uint f-u8)
-(dnop i8      "8  bit unsigned immediate"    (HASH-PREFIX) h-uint f-i8)
-(dnop udisp6  "6  bit unsigned immediate"    (HASH-PREFIX) h-uint f-udisp6)
-(dnop disp8   "8  bit signed   immediate"    (HASH-PREFIX) h-sint f-disp8)
-(dnop disp9   "9  bit signed   immediate"    (HASH-PREFIX) h-sint f-disp9)
-(dnop disp10  "10 bit signed   immediate"    (HASH-PREFIX) h-sint f-disp10)
-
-(dnop s10     "10 bit signed   immediate"    (HASH-PREFIX) h-sint f-s10)
-(dnop u10     "10 bit unsigned immediate"    (HASH-PREFIX) h-uint f-u10)
-(dnop i32     "32 bit immediate"             (HASH-PREFIX) h-uint f-i32)
-
-(define-operand
-  (name m4)
-  (comment "4  bit negative immediate")
-  (attrs HASH-PREFIX)
-  (type h-sint)
-  (index f-m4)
-  (handlers (print "m4"))
-)
-
-(define-operand
-  (name i20)
-  (comment "20 bit immediate")
-  (attrs HASH-PREFIX)
-  (type h-uint)
-  (index f-i20)
-)
-
-(dnop dir8    "8  bit direct address"        ()  h-uint f-dir8)
-(dnop dir9    "9  bit direct address"        ()  h-uint f-dir9)
-(dnop dir10   "10 bit direct address"        ()  h-uint f-dir10)
-
-(dnop label9  "9  bit pc relative address"   ()  h-iaddr f-rel9)
-(dnop label12 "12 bit pc relative address"   ()  h-iaddr f-rel12)
-
-(define-operand 
-  (name    reglist_low_ld)
-  (comment "8 bit low register mask for ldm")
-  (attrs)
-  (type    h-uint)
-  (index   f-reglist_low_ld)
-  (handlers (parse "low_register_list_ld")
-	    (print "low_register_list_ld"))
-)
-
-(define-operand 
-  (name    reglist_hi_ld)
-  (comment "8 bit high register mask for ldm")
-  (attrs)
-  (type    h-uint)
-  (index   f-reglist_hi_ld)
-  (handlers (parse "hi_register_list_ld")
-	    (print "hi_register_list_ld"))
-)
-
-(define-operand 
-  (name    reglist_low_st)
-  (comment "8 bit low register mask for stm")
-  (attrs)
-  (type    h-uint)
-  (index   f-reglist_low_st)
-  (handlers (parse "low_register_list_st")
-	    (print "low_register_list_st"))
-)
-
-(define-operand 
-  (name    reglist_hi_st)
-  (comment "8 bit high register mask for stm")
-  (attrs)
-  (type    h-uint)
-  (index   f-reglist_hi_st)
-  (handlers (parse "hi_register_list_st")
-	    (print "hi_register_list_st"))
-)
-
-(dnop cc   "condition codes"  ()            h-uint f-cc)
-(dnop ccc  "coprocessor calc" (HASH-PREFIX) h-uint f-ccc)
-
-(dnop nbit  "negative   bit"       (SEM-ONLY) h-nbit  f-nil)
-(dnop vbit  "overflow   bit"       (SEM-ONLY) h-vbit  f-nil)
-(dnop zbit  "zero       bit"       (SEM-ONLY) h-zbit  f-nil)
-(dnop cbit  "carry      bit"       (SEM-ONLY) h-cbit  f-nil)
-(dnop ibit  "interrupt  bit"       (SEM-ONLY) h-ibit  f-nil)
-(dnop sbit  "stack      bit"       (SEM-ONLY) h-sbit  f-nil)
-(dnop tbit  "trace trap bit"       (SEM-ONLY) h-tbit  f-nil)
-(dnop d0bit "division 0 bit"       (SEM-ONLY) h-d0bit f-nil)
-(dnop d1bit "division 1 bit"       (SEM-ONLY) h-d1bit f-nil)
-
-(dnop ccr  "condition code bits"   (SEM-ONLY) h-ccr  f-nil)
-(dnop scr  "system condition bits" (SEM-ONLY) h-scr  f-nil)
-(dnop ilm  "interrupt level mask"  (SEM-ONLY) h-ilm  f-nil)
-
-; Instruction definitions.
-;
-; Notes:
-; - dni is short for "define-normal-instruction"
-
-; FR30 specific insn attributes:
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name NOT-IN-DELAY-SLOT)
-  (comment "insn can't go in delay slot")
-)
-
-; Sets zbit and nbit based on the value of x
-;
-(define-pmacro (set-z-and-n x)
-  (sequence ()
-	    (set zbit (eq x (const 0)))
-	    (set nbit (lt x (const 0))))
-)
-
-; Binary integer instruction which sets status bits
-;
-(define-pmacro (binary-int-op name insn comment opc1 opc2 op arg1 arg2)
-  (dni name
-       (.str insn " " comment)
-       ()
-       (.str insn " $" arg1 ",$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (sequence ()
-		 (set vbit ((.sym op -oflag) arg2 arg1 (const 0)))
-		 (set cbit ((.sym op -cflag) arg2 arg1 (const 0)))
-		 (set arg2 (op arg2 arg1))
-		 (set-z-and-n arg2))
-       ()
-  )
-)
-
-; Binary integer instruction which does *not* set status bits
-;
-(define-pmacro (binary-int-op-n name insn comment opc1 opc2 op arg1 arg2)
-  (dni name
-       (.str insn " " comment)
-       ()
-       (.str insn " $" arg1 ",$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (set arg2 (op arg2 arg1))
-       ()
-  )
-)
-
-; Binary integer instruction with carry which sets status bits
-;
-(define-pmacro (binary-int-op-c name insn comment opc1 opc2 op arg1 arg2)
-  (dni name
-       (.str insn " " comment)
-       ()
-       (.str insn " $" arg1 ",$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (sequence ((WI tmp))
-		 (set tmp  ((.sym op c)      arg2 arg1 cbit))
-		 (set vbit ((.sym op -oflag) arg2 arg1 cbit))
-		 (set cbit ((.sym op -cflag) arg2 arg1 cbit))
-		 (set arg2 tmp)
-		 (set-z-and-n arg2))
-       ()
-  )
-)
-
-(binary-int-op   add   add   "reg/reg"   OP1_A OP2_6 add Rj Ri)
-(binary-int-op   addi  add   "immed/reg" OP1_A OP2_4 add u4 Ri)
-(binary-int-op   add2  add2  "immed/reg" OP1_A OP2_5 add m4 Ri)
-(binary-int-op-c addc  addc  "reg/reg"   OP1_A OP2_7 add Rj Ri)
-(binary-int-op-n addn  addn  "reg/reg"   OP1_A OP2_2 add Rj Ri)
-(binary-int-op-n addni addn  "immed/reg" OP1_A OP2_0 add u4 Ri)
-(binary-int-op-n addn2 addn2 "immed/reg" OP1_A OP2_1 add m4 Ri)
-
-(binary-int-op   sub   sub   "reg/reg"   OP1_A OP2_C sub Rj Ri)
-(binary-int-op-c subc  subc  "reg/reg"   OP1_A OP2_D sub Rj Ri)
-(binary-int-op-n subn  subn  "reg/reg"   OP1_A OP2_E sub Rj Ri)
-
-; Integer compare instruction
-;
-(define-pmacro (int-cmp name insn comment opc1 opc2 arg1 arg2)
-  (dni name
-       (.str insn " " comment)
-       ()
-       (.str insn " $" arg1 ",$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (sequence ((WI tmp1))
-		 (set vbit (sub-oflag arg2 arg1 (const 0)))
-		 (set cbit (sub-cflag arg2 arg1 (const 0)))
-		 (set tmp1 (sub       arg2 arg1))
-		 (set-z-and-n tmp1)
-       )
-       ()
-  )
-)
-
-(int-cmp cmp  cmp  "reg/reg"   OP1_A OP2_A Rj Ri)
-(int-cmp cmpi cmp  "immed/reg" OP1_A OP2_8 u4 Ri)
-(int-cmp cmp2 cmp2 "immed/reg" OP1_A OP2_9 m4 Ri)
-
-; Binary logical instruction
-;
-(define-pmacro (binary-logical-op name insn comment opc1 opc2 op arg1 arg2)
-  (dni name
-       (.str insn " " comment)
-       ()
-       (.str insn " $" arg1 ",$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (sequence ()
-		 (set arg2 (op arg2 arg1))
-		 (set-z-and-n arg2))
-       ()
-  )
-)
-
-(binary-logical-op and and "reg/reg" OP1_8 OP2_2 and Rj Ri)
-(binary-logical-op or  or  "reg/reg" OP1_9 OP2_2 or  Rj Ri)
-(binary-logical-op eor eor "reg/reg" OP1_9 OP2_A xor Rj Ri)
-
-(define-pmacro (les-units model) ; les: load-exec-store
-  (model (unit u-exec) (unit u-load) (unit u-store))
-)
-
-; Binary logical instruction to memory
-;
-(define-pmacro (binary-logical-op-m name insn comment opc1 opc2 mode op arg1 arg2)
-  (dni name
-       (.str insn " " comment)
-       (NOT-IN-DELAY-SLOT)
-       (.str insn " $" arg1 ",@$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (sequence ((mode tmp))
-		 (set mode tmp (op mode (mem mode arg2) arg1))
-		 (set-z-and-n tmp)
-		 (set mode (mem mode arg2) tmp))
-       ((les-units fr30-1))
-  )
-)
-
-(binary-logical-op-m andm and  "reg/mem" OP1_8 OP2_4 WI and Rj Ri)
-(binary-logical-op-m andh andh "reg/mem" OP1_8 OP2_5 HI and Rj Ri)
-(binary-logical-op-m andb andb "reg/mem" OP1_8 OP2_6 QI and Rj Ri)
-(binary-logical-op-m orm  or   "reg/mem" OP1_9 OP2_4 WI or  Rj Ri)
-(binary-logical-op-m orh  orh  "reg/mem" OP1_9 OP2_5 HI or  Rj Ri)
-(binary-logical-op-m orb  orb  "reg/mem" OP1_9 OP2_6 QI or  Rj Ri)
-(binary-logical-op-m eorm eor  "reg/mem" OP1_9 OP2_C WI xor Rj Ri)
-(binary-logical-op-m eorh eorh "reg/mem" OP1_9 OP2_D HI xor Rj Ri)
-(binary-logical-op-m eorb eorb "reg/mem" OP1_9 OP2_E QI xor Rj Ri)
-
-; Binary logical instruction to low half of byte in memory
-;
-(dni bandl
-     "bandl #u4,@Ri"
-     (NOT-IN-DELAY-SLOT)
-     "bandl $u4,@$Ri"
-     (+ OP1_8 OP2_0 u4 Ri)
-     (set QI (mem QI Ri)
-	   (and QI
-		 (or  QI u4 (const #xf0))
-		 (mem QI Ri)))
-     ((les-units fr30-1))
-)
-
-(dni borl
-     "borl #u4,@Ri"
-     (NOT-IN-DELAY-SLOT)
-     "borl $u4,@$Ri"
-     (+ OP1_9 OP2_0 u4 Ri)
-     (set QI (mem QI Ri) (or QI u4 (mem QI Ri)))
-     ((les-units fr30-1))
-)
-
-(dni beorl
-     "beorl #u4,@Ri"
-     (NOT-IN-DELAY-SLOT)
-     "beorl $u4,@$Ri"
-     (+ OP1_9 OP2_8 u4 Ri)
-     (set QI (mem QI Ri) (xor QI u4 (mem QI Ri)))
-     ((les-units fr30-1))
-)
-
-; Binary logical instruction to high half of byte in memory
-;
-(dni bandh
-     "bandh #u4,@Ri"
-     (NOT-IN-DELAY-SLOT)
-     "bandh $u4,@$Ri"
-     (+ OP1_8 OP2_1 u4 Ri)
-     (set QI (mem QI Ri)
-	   (and QI
-		 (or QI (sll QI u4 (const 4)) (const #x0f))
-		 (mem QI Ri)))
-     ((les-units fr30-1))
-)
-
-(define-pmacro (binary-or-op-mh name insn opc1 opc2 op arg1 arg2)
-  (dni name
-       (.str name " #" arg1 ",@" args)
-       (NOT-IN-DELAY-SLOT)
-       (.str name " $" arg1 ",@$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (set QI (mem QI arg2)
-	     (insn QI
-		   (sll QI arg1 (const 4))
-		   (mem QI arg2)))
-       ((les-units fr30-1))
-  )
-)
-
-(binary-or-op-mh borh  or  OP1_9 OP2_1 or  u4 Ri)
-(binary-or-op-mh beorh xor OP1_9 OP2_9 xor u4 Ri)
-
-(dni btstl
-     "btstl #u4,@Ri"
-     (NOT-IN-DELAY-SLOT)
-     "btstl $u4,@$Ri"
-     (+ OP1_8 OP2_8 u4 Ri)
-     (sequence ((QI tmp))
-	       (set tmp (and QI u4 (mem QI Ri)))
-	       (set zbit (eq tmp (const 0)))
-	       (set nbit (const 0)))
-     ((fr30-1 (unit u-load) (unit u-exec (cycles 2))))
-)
-
-(dni btsth
-     "btsth #u4,@Ri"
-     (NOT-IN-DELAY-SLOT)
-     "btsth $u4,@$Ri"
-     (+ OP1_8 OP2_9 u4 Ri)
-     (sequence ((QI tmp))
-	       (set tmp (and QI (sll QI u4 (const 4)) (mem QI Ri)))
-	       (set zbit (eq tmp (const 0)))
-	       (set nbit (lt tmp (const 0))))
-     ((fr30-1 (unit u-load) (unit u-exec (cycles 2))))
-)
-
-(dni mul
-     "mul Rj,Ri"
-     (NOT-IN-DELAY-SLOT)
-     "mul $Rj,$Ri"
-     (+ OP1_A OP2_F Rj Ri)
-     (sequence ((DI tmp))
-	       (set tmp (mul DI (ext DI Rj) (ext DI Ri)))
-	       (set (reg h-dr 5) (trunc WI tmp))
-	       (set (reg h-dr 4) (trunc WI (srl tmp (const 32))))
-	       (set nbit (lt (reg h-dr 5) (const 0)))
-	       (set zbit (eq tmp (const DI 0)))
-	       (set vbit (orif
-			  (gt  tmp (const DI #x7fffffff))
-			  (lt  tmp (neg (const DI #x80000000))))))
-     ((fr30-1 (unit u-exec (cycles 5))))
-)
-
-(dni mulu
-     "mulu Rj,Ri"
-     (NOT-IN-DELAY-SLOT)
-     "mulu $Rj,$Ri"
-     (+ OP1_A OP2_B Rj Ri)
-     (sequence ((DI tmp))
-	       (set tmp (mul DI (zext DI Rj) (zext DI Ri)))
-	       (set (reg h-dr 5) (trunc WI tmp))
-	       (set (reg h-dr 4) (trunc WI (srl tmp (const 32))))
-	       (set nbit (lt (reg h-dr 4) (const 0)))
-	       (set zbit (eq (reg h-dr 5) (const 0)))
-	       (set vbit (ne (reg h-dr 4) (const 0))))
-     ((fr30-1 (unit u-exec (cycles 5))))
-)
-
-(dni mulh
-     "mulh Rj,Ri"
-     (NOT-IN-DELAY-SLOT)
-     "mulh $Rj,$Ri"
-     (+ OP1_B OP2_F Rj Ri)
-     (sequence ()
-	       (set (reg h-dr 5) (mul (trunc HI Rj) (trunc HI Ri)))
-	       (set nbit (lt (reg h-dr 5) (const 0)))
-	       (set zbit (ge (reg h-dr 5) (const 0))))
-     ((fr30-1 (unit u-exec (cycles 3))))
-)
-
-(dni muluh
-     "muluh Rj,Ri"
-     (NOT-IN-DELAY-SLOT)
-     "muluh $Rj,$Ri"
-     (+ OP1_B OP2_B Rj Ri)
-     (sequence ()
-	       (set (reg h-dr 5) (mul (and Rj (const #xffff))
-				      (and Ri (const #xffff))))
-	       (set nbit (lt (reg h-dr 5) (const 0)))
-	       (set zbit (ge (reg h-dr 5) (const 0))))
-     ((fr30-1 (unit u-exec (cycles 3))))
-)
-
-(dni div0s
-     "div0s Ri"
-     ()
-     "div0s $Ri"
-     (+ OP1_9 OP2_7 OP3_4 Ri)
-     (sequence ()
-	       (set d0bit (lt (reg h-dr 5) (const 0)))
-	       (set d1bit (xor d0bit (lt Ri (const 0))))
-	       (if (ne d0bit (const 0))
-		   (set (reg h-dr 4) (const #xffffffff))
-		   (set (reg h-dr 4) (const 0))))
-     ()
-)
-
-(dni div0u
-     "div0u Ri"
-     ()
-     "div0u $Ri"
-     (+ OP1_9 OP2_7 OP3_5 Ri)
-     (sequence ()
-	       (set d0bit (const 0))
-	       (set d1bit (const 0))
-	       (set (reg h-dr 4) (const 0)))
-     ()
-)
-
-(dni div1
-     "div1 Ri"
-     ()
-     "div1 $Ri"
-     (+ OP1_9 OP2_7 OP3_6 Ri)
-     (sequence ((WI tmp))
-	       (set (reg h-dr 4) (sll (reg h-dr 4) (const 1)))
-	       (if (lt (reg h-dr 5) (const 0))
-		   (set (reg h-dr 4) (add (reg h-dr 4) (const 1))))
-	       (set (reg h-dr 5) (sll (reg h-dr 5) (const 1)))
-	       (if (eq d1bit (const 1))
-		   (sequence ()
-			     (set tmp  (add       (reg h-dr 4) Ri))
-			     (set cbit (add-cflag (reg h-dr 4) Ri (const 0))))
-		   (sequence ()
-			     (set tmp  (sub       (reg h-dr 4) Ri))
-			     (set cbit (sub-cflag (reg h-dr 4) Ri (const 0)))))
-	       (if (not (xor (xor d0bit d1bit) cbit))
-		   (sequence ()
-			     (set (reg h-dr 4) tmp)
-			     (set (reg h-dr 5) (or (reg h-dr 5) (const 1)))))
-	       (set zbit (eq (reg h-dr 4) (const 0))))
-     ()
-)
-
-(dni div2
-     "div2 Ri"
-     ()
-     "div2 $Ri"
-     (+ OP1_9 OP2_7 OP3_7 Ri)
-     (sequence ((WI tmp))
-	       (if (eq d1bit (const 1))
-		   (sequence ()
-			     (set tmp  (add       (reg h-dr 4) Ri))
-			     (set cbit (add-cflag (reg h-dr 4) Ri (const 0))))
-		   (sequence ()
-			     (set tmp  (sub       (reg h-dr 4) Ri))
-			     (set cbit (sub-cflag (reg h-dr 4) Ri (const 0)))))
-	       (if (eq tmp (const 0))
-		   (sequence ()
-			     (set zbit (const 1))
-			     (set (reg h-dr 4) (const 0)))
-		   (set zbit (const 0))))
-     ()
-)
-
-(dni div3
-     "div3"
-     ()
-     "div3"
-     (+ OP1_9 OP2_F OP3_6 OP4_0)
-     (if (eq zbit (const 1))
-	 (set (reg h-dr 5) (add (reg h-dr 5) (const 1))))
-     ()
-)
-
-(dni div4s
-     "div4s"
-     ()
-     "div4s"
-     (+ OP1_9 OP2_F OP3_7 OP4_0)
-     (if (eq d1bit (const 1))
-	 (set (reg h-dr 5) (neg (reg h-dr 5))))
-     ()
-)
-
-(define-pmacro (leftshift-op name insn opc1 opc2 arg1 arg2 shift-expr)
-  (dni name
-       (.str insn " " arg1 "," arg2)
-       ()
-       (.str insn " $" arg1 ",$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (sequence ((WI shift))
-		 (set shift shift-expr)
-		 (if (ne shift (const 0))
-		     (sequence ()
-			       (set cbit (ne (and arg2
-						  (sll (const 1)
-						       (sub (const 32) shift)))
-					     (const 0)))
-			       (set arg2 (sll arg2 shift)))
-		     (set cbit (const 0)))
-		 (set nbit (lt arg2 (const 0)))
-		 (set zbit (eq arg2 (const 0))))
-       ()
-  )
-)
-(leftshift-op  lsl   lsl   OP1_B OP2_6 Rj Ri (and Rj (const #x1f)))
-(leftshift-op  lsli  lsl   OP1_B OP2_4 u4 Ri u4)
-(leftshift-op  lsl2  lsl2  OP1_B OP2_5 u4 Ri (add u4 (const #x10)))
-
-(define-pmacro (rightshift-op name insn opc1 opc2 op arg1 arg2 shift-expr)
-  (dni name
-       (.str insn " " arg1 "," arg2)
-       ()
-       (.str insn " $" arg1 ",$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (sequence ((WI shift))
-		 (set shift shift-expr)
-		 (if (ne shift (const 0))
-		     (sequence ()
-			       (set cbit (ne (and arg2
-						  (sll (const 1)
-						       (sub shift (const 1))))
-					     (const 0)))
-			       (set arg2 (op arg2 shift)))
-		     (set cbit (const 0)))
-		 (set nbit (lt arg2 (const 0)))
-		 (set zbit (eq arg2 (const 0))))
-       ()
-  )
-)
-(rightshift-op lsr  lsr  OP1_B OP2_2 srl Rj Ri (and Rj (const #x1f)))
-(rightshift-op lsri lsr  OP1_B OP2_0 srl u4 Ri u4)
-(rightshift-op lsr2 lsr2 OP1_B OP2_1 srl u4 Ri (add u4 (const #x10)))
-(rightshift-op asr  asr  OP1_B OP2_A sra Rj Ri (and Rj (const #x1f)))
-(rightshift-op asri asr  OP1_B OP2_8 sra u4 Ri u4)
-(rightshift-op asr2 asr2 OP1_B OP2_9 sra u4 Ri (add u4 (const #x10)))
-
-(dni ldi8
-     "load 8 bit unsigned immediate"
-     ()
-     "ldi:8 $i8,$Ri"
-     (+ OP1_C i8 Ri)
-     (set Ri i8)
-     ()
-)
-
-; Typing ldi:8 in in emacs is a pain.
-(dnmi ldi8m "ldi:8 without the colon"
-      (NO-DIS)
-      "ldi8 $i8,$Ri"
-      (emit ldi8 i8 Ri)
-)
-
-(dni ldi20
-     "load 20 bit unsigned immediate"
-     (NOT-IN-DELAY-SLOT)
-     "ldi:20 $i20,$Ri"
-     (+ OP1_9 OP2_B Ri i20)
-     (set Ri i20)
-     ((fr30-1 (unit u-exec (cycles 2))))
-)
-
-; Typing ldi:20 in in emacs is a pain.
-(dnmi ldi20m "ldi:20 without the colon"
-      (NO-DIS)
-      "ldi20 $i20,$Ri"
-      (emit ldi20 i20 Ri)
-)
-
-(dni ldi32
-     "load 32 bit immediate"
-     (NOT-IN-DELAY-SLOT)
-     "ldi:32 $i32,$Ri"
-     (+ OP1_9 OP2_F OP3_8 Ri i32)
-     (set Ri i32)
-     ((fr30-1 (unit u-exec (cycles 3))))
-)
-
-; Typing ldi:32 in in emacs is a pain.
-(dnmi ldi32m "ldi:32 without the colon"
-      (NO-DIS)
-      "ldi32 $i32,$Ri"
-      (emit ldi32 i32 Ri)
-)
-
-(define-pmacro (basic-ld name insn opc1 opc2 mode arg1 arg2)
-  (dni name
-       (.str name " @" arg1 "," arg2)
-       ()
-       (.str name " @$" arg1 ",$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (set arg2 (mem mode arg1))
-       ((fr30-1 (unit u-load)))
-  )
-)
-
-(basic-ld ld   ld   OP1_0 OP2_4 WI  Rj Ri)
-(basic-ld lduh lduh OP1_0 OP2_5 UHI Rj Ri)
-(basic-ld ldub ldub OP1_0 OP2_6 UQI Rj Ri)
-
-(define-pmacro (r13base-ld name insn opc1 opc2 mode arg1 arg2)
-  (dni name
-       (.str insn " @(R13," arg1 ")," arg2)
-       ()
-       (.str insn " @($R13,$" arg1 "),$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (set arg2 (mem mode (add arg1 (reg h-gr 13))))
-       ((fr30-1 (unit u-load)))
-  )
-)
-
-(r13base-ld ldr13   ld   OP1_0 OP2_0 WI  Rj Ri)
-(r13base-ld ldr13uh lduh OP1_0 OP2_1 UHI Rj Ri)
-(r13base-ld ldr13ub ldub OP1_0 OP2_2 UQI Rj Ri)
-
-(define-pmacro (r14base-ld name insn opc1 mode arg1 arg2)
-  (dni name
-       (.str insn " @(R14," arg1 ")," arg2)
-       ()
-       (.str insn " @($R14,$" arg1 "),$" arg2)
-       (+ opc1 arg1 arg2)
-       (set arg2 (mem mode (add arg1 (reg h-gr 14))))
-       ((fr30-1 (unit u-load)))
-  )
-)
-
-(r14base-ld ldr14   ld   OP1_2 WI  disp10 Ri)
-(r14base-ld ldr14uh lduh OP1_4 UHI disp9  Ri)
-(r14base-ld ldr14ub ldub OP1_6 UQI disp8  Ri)
-
-(dni ldr15
-     "ld @(R15,udisp6),Ri mem/reg"
-     ()
-     "ld @($R15,$udisp6),$Ri"
-     (+ OP1_0 OP2_3 udisp6 Ri)
-     (set Ri (mem WI (add udisp6 (reg h-gr 15))))
-     ((fr30-1 (unit u-load)))
-)
-
-(dni ldr15gr
-     "ld @R15+,Ri"
-     ()
-     "ld @$R15+,$Ri"
-     (+ OP1_0 OP2_7 OP3_0 Ri)
-     (sequence ()
-	       (set Ri (mem WI (reg h-gr 15)))
-	       (if (ne (ifield f-Ri) (const 15))
-		   (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-     ((fr30-1 (unit u-load)))
-)
-
-; This insn loads a value from where r15 points into the target register and
-; then increments r15. If the target register is also r15, then the post
-; increment is not performed.
-;
-(dni ldr15dr
-     "ld @R15+,Rs2"
-     ()
-     "ld @$R15+,$Rs2"
-     (+ OP1_0 OP2_7 OP3_8 Rs2)
-; This seems more straight forward, but doesn't work due to a problem in
-; cgen. We're trying to not increment r15 if it is the target register.
-;     (sequence ()
-;	       (set Rs2 (mem WI (reg h-gr 15)))
-;	       (if (not (or (and (eq (ifield f-Rs2) (const 2))
-;				 (eq sbit (const 0)))
-;	                    (and (eq (ifield f-Rs2) (const 3))
-;				 (eq sbit (const 1)))))
-;		   (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))
-;	       )
-;     )
-     (sequence ((WI tmp))
-	       (set tmp (mem WI (reg h-gr 15))) ; save in case target is r15
-	       (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))
-	       (set Rs2 tmp))
-     ((fr30-1 (unit u-load)))
-)
-
-(dni ldr15ps
-     "ld @R15+,ps mem/reg"
-     (NOT-IN-DELAY-SLOT)
-     "ld @$R15+,$ps"
-     (+ OP1_0 OP2_7 OP3_9 OP4_0)
-     (sequence ()
-	       (set ps (mem WI (reg h-gr 15)))
-	       (set (reg h-gr 15) (add (reg h-gr 15) (const 4))))
-     ((fr30-1 (unit u-load)))
-)
-
-(define-pmacro (basic-st name insn opc1 opc2 mode arg1 arg2)
-  (dni name
-       (.str name " " arg1 ",@" arg2)
-       ()
-       (.str name " $" arg1 ",@$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (set (mem mode arg2) arg1)
-       ((fr30-1 (unit u-store)))
-  )
-)
-
-(basic-st st  st  OP1_1 OP2_4 WI Ri Rj)
-(basic-st sth sth OP1_1 OP2_5 HI Ri Rj)
-(basic-st stb stb OP1_1 OP2_6 QI Ri Rj)
-
-(define-pmacro (r13base-st name insn opc1 opc2 mode arg1 arg2)
-  (dni name
-       (.str insn " " arg1 ",@(R13," arg2 ")")
-       ()
-       (.str insn " $" arg1 ",@($R13,$" arg2 ")")
-       (+ opc1 opc2 arg1 arg2)
-       (set (mem mode (add arg2 (reg h-gr 13))) arg1)
-       ((fr30-1 (unit u-store)))
-  )
-)
-
-(r13base-st str13  st  OP1_1 OP2_0 WI Ri Rj)
-(r13base-st str13h sth OP1_1 OP2_1 HI Ri Rj)
-(r13base-st str13b stb OP1_1 OP2_2 QI Ri Rj)
-
-(define-pmacro (r14base-st name insn opc1 mode arg1 arg2)
-  (dni name
-       (.str insn " " arg1 ",@(R14," arg2 ")")
-       ()
-       (.str insn " $" arg1 ",@($R14,$" arg2 ")")
-       (+ opc1 arg1 arg2)
-       (set (mem mode (add arg2 (reg h-gr 14))) arg1)
-       ((fr30-1 (unit u-store)))
-  )
-)
-
-(r14base-st str14  st  OP1_3 WI  Ri disp10)
-(r14base-st str14h sth OP1_5 HI  Ri disp9)
-(r14base-st str14b stb OP1_7 QI  Ri disp8)
-
-(dni str15
-     "st Ri,@(R15,udisp6) reg/mem"
-     ()
-     "st $Ri,@($R15,$udisp6)"
-     (+ OP1_1 OP2_3 udisp6 Ri)
-     (set (mem WI (add (reg h-gr 15) udisp6)) Ri)
-     ((fr30-1 (unit u-store)))
-)
-
-; These store insns predecrement r15 and then store the contents of the source
-; register where r15 then points. If the source register is also r15, then the
-; original value of r15 is stored.
-;
-(dni str15gr
-     "st Ri,@-R15 reg/mem"
-     ()
-     "st $Ri,@-$R15"
-     (+ OP1_1 OP2_7 OP3_0 Ri)
-     (sequence ((WI tmp))
-	       (set tmp Ri) ; save in case it's r15
-	       (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-	       (set (mem WI (reg h-gr 15)) tmp))
-     ((fr30-1 (unit u-store)))
-)
-
-(dni str15dr
-     "st Rs,@-R15 reg/mem"
-     ()
-     "st $Rs2,@-$R15"
-     (+ OP1_1 OP2_7 OP3_8 Rs2)
-     (sequence ((WI tmp))
-	       (set tmp Rs2) ; save in case it's r15
-	       (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-	       (set (mem WI (reg h-gr 15)) tmp))
-     ((fr30-1 (unit u-store)))
-)
-
-(dni str15ps
-     "st ps,@-R15 reg/mem"
-     ()
-     "st $ps,@-$R15"
-     (+ OP1_1 OP2_7 OP3_9 OP4_0)
-     (sequence ()
-	       (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-	       (set (mem WI (reg h-gr 15)) ps))
-     ((fr30-1 (unit u-store)))
-)
-
-(define-pmacro (mov2gr name opc1 opc2 arg1 arg2)
-  (dni name
-       (.str "mov " arg1 "," arg2)
-       ()
-       (.str "mov $" arg1 ",$" arg2)
-       (+ opc1 opc2 arg1 arg2)
-       (set arg2 arg1)
-       ()
-  )
-)
-
-(mov2gr mov   OP1_8 OP2_B Rj Ri)
-(mov2gr movdr OP1_B OP2_7 Rs1 Ri)
-
-(dni movps
-     "mov ps,Ri reg/reg"
-     ()
-     "mov $ps,$Ri"
-     (+ OP1_1 OP2_7 OP3_1 Ri)
-     (set Ri ps)
-     ()
-)
-
-(dni mov2dr
-     "mov Ri,Rs reg/reg"
-     ()
-     "mov $Ri,$Rs1"
-     (+ OP1_B OP2_3 Rs1 Ri)
-     (set Rs1 Ri)
-     ()
-)
-
-(dni mov2ps
-     "mov Ri,ps reg/reg"
-     ()
-     "mov $Ri,$ps"
-     (+ OP1_0 OP2_7 OP3_1 Ri)
-     (set ps Ri)
-     ()
-)
-
-(dni jmp
-     "jmp with no delay slot"
-     (NOT-IN-DELAY-SLOT)
-     "jmp @$Ri"
-     (+ OP1_9 OP2_7 OP3_0 Ri)
-     (set pc Ri)
-     ((fr30-1 (unit u-cti)))
-)
-
-(dni jmpd "jmp with delay slot"
-     (NOT-IN-DELAY-SLOT)
-     "jmp:d @$Ri"
-     (+ OP1_9 OP2_F OP3_0 Ri)
-     (delay (const 1)
-	    (set pc Ri))
-     ((fr30-1 (unit u-cti)))
-)
-
-; These versions which use registers must appear before the other
-; versions which use relative addresses due to a problem in cgen
-; - DB.
-(dni callr
-     "call @Ri"
-     (NOT-IN-DELAY-SLOT)
-     "call @$Ri"
-     (+ OP1_9 OP2_7 OP3_1 Ri)
-     (sequence ()
-	       (set (reg h-dr 1) (add pc (const 2)))
-	       (set pc Ri))
-     ((fr30-1 (unit u-cti)))
-)
-(dni callrd
-     "call:d @Ri"
-     (NOT-IN-DELAY-SLOT)
-     "call:d @$Ri"
-     (+ OP1_9 OP2_F OP3_1 Ri)
-     (delay (const 1)
-	    (sequence ()
-		      (set (reg h-dr 1) (add pc (const 4)))
-		      (set pc Ri)))
-     ((fr30-1 (unit u-cti)))
-)
-; end of reordered insns
-
-(dni call
-     "call relative to pc"
-     (NOT-IN-DELAY-SLOT)
-     "call $label12"
-     (+ OP1_D OP5_0 label12)
-     (sequence ()
-	       (set (reg h-dr 1) (add pc (const 2)))
-	       (set pc label12))
-     ((fr30-1 (unit u-cti)))
-)
-(dni calld
-     "call relative to pc"
-     (NOT-IN-DELAY-SLOT)
-     "call:d $label12"
-     (+ OP1_D OP5_1 label12)
-     (delay (const 1)
-	    (sequence ()
-		      (set (reg h-dr 1) (add pc (const 4)))
-		      (set pc label12)))
-     ((fr30-1 (unit u-cti)))
-)
-
-(dni ret
-     "return from subroutine"
-     (NOT-IN-DELAY-SLOT)
-     "ret"
-     (+ OP1_9 OP2_7 OP3_2 OP4_0)
-     (set pc (reg h-dr 1))
-     ((fr30-1 (unit u-cti)))
-)
-
-(dni ret:d
-     "return from subroutine with delay slot"
-     (NOT-IN-DELAY-SLOT)
-     "ret:d"
-     (+ OP1_9 OP2_F OP3_2 OP4_0)
-     (delay (const 1)
-	    (set pc (reg h-dr 1)))
-     ((fr30-1 (unit u-cti)))
-)
-
-(dni int
-     "interrupt"
-     (NOT-IN-DELAY-SLOT)
-     "int $u8"
-     (+ OP1_1 OP2_F u8)
-     (sequence ()
-	       ; This is defered to fr30_int because for the breakpoint case
-	       ; we want to change as little of the machine state as possible.
-	       ; Push PS onto the system stack
-	       ;(set  (reg h-dr 2) (sub (reg h-dr 2) (const 4)))
-	       ;(set UWI (mem UWI (reg h-dr 2)) ps)
-	       ; Push the return address onto the system stack
-	       ;(set  (reg h-dr 2) (sub (reg h-dr 2) (const 4)))
-	       ;(set UWI (mem UWI (reg h-dr 2)) (add pc (const 2)))
-	       ; Set status bits
-	       ;(set ibit (const 0))
-	       ;(set sbit (const 0))
-
-	       ; We still should indicate what is modified by this insn.
-	       (clobber (reg h-dr 2))
-	       (clobber ibit)
-	       (clobber sbit)
-	       ; ??? (clobber memory)?
-
-	       ; fr30_int handles operating vs user mode
-	       (set WI pc (c-call WI "fr30_int" pc u8))
-     )
-     ; This is more properly a cti, but branch stall calculation is different.
-     ((fr30-1 (unit u-exec (cycles 6))))
-)
-
-(dni inte
-     "interrupt for emulator"
-     (NOT-IN-DELAY-SLOT)
-     "inte"
-     (+ OP1_9 OP2_F OP3_3 OP4_0)
-     (sequence ()
-	       ; This is defered to fr30_inte because for the breakpoint case
-	       ; we want to change as little of the machine state as possible.
-	       ; Push PS onto the system stack
-	       ;(set  (reg h-dr 2) (sub (reg h-dr 2) (const 4)))
-	       ;(set UWI (mem UWI (reg h-dr 2)) ps)
-	       ; Push the return address onto the system stack
-	       ;(set  (reg h-dr 2) (sub (reg h-dr 2) (const 4)))
-	       ;(set UWI (mem UWI (reg h-dr 2)) (add pc (const 2)))
-	       ; Set status bits
-	       ;(set ibit (const 0))
-	       ;(set ilm  (const 4))
-
-	       ; We still should indicate what is modified by this insn.
-	       (clobber (reg h-dr 2))
-	       (clobber ibit)
-	       (clobber ilm)
-	       ; ??? (clobber memory)?
-
-	       ; fr30_int handles operating vs user mode
-	       (set WI pc (c-call WI "fr30_inte" pc))
-     )
-     ; This is more properly a cti, but branch stall calculation is different.
-     ((fr30-1 (unit u-exec (cycles 6))))
-)
-
-(dni reti
-     "return from interrupt"
-     (NOT-IN-DELAY-SLOT)
-     "reti"
-     (+ OP1_9 OP2_7 OP3_3 OP4_0)
-     (if (eq sbit (const 0))
-	 (sequence ()
-		   ; Pop the return address from the system stack
-		   (set UWI pc (mem UWI (reg h-dr 2)))
-		   (set  (reg h-dr 2) (add (reg h-dr 2) (const 4)))
-		   ; Pop PS from the system stack
-		   (set UWI ps (mem UWI (reg h-dr 2)))
-		   (set  (reg h-dr 2) (add (reg h-dr 2) (const 4)))
-         )
-	 (sequence ()
-		   ; Pop the return address from the user stack
-		   (set UWI pc (mem UWI (reg h-dr 3)))
-		   (set  (reg h-dr 3) (add (reg h-dr 3) (const 4)))
-		   ; Pop PS from the user stack
-		   (set UWI ps (mem UWI (reg h-dr 3)))
-		   (set  (reg h-dr 3) (add (reg h-dr 3) (const 4)))
-         )
-     )    
-     ; This is more properly a cti, but branch stall calculation is different.
-     ((fr30-1 (unit u-exec (cycles 4))))
-)
-
-; Conditional branches with and without delay slots
-;
-(define-pmacro (cond-branch cc condition)
-  (begin
-    (dni (.sym b cc d)
-	 (.str (.sym b cc :d) " label9")
-	 (NOT-IN-DELAY-SLOT)
-	 (.str (.sym b cc :d) " $label9")
-	 (+ OP1_F (.sym CC_ cc) label9)
-	 (delay (const 1)
-		(if condition (set pc label9)))
-	 ((fr30-1 (unit u-cti)))
-    )
-    (dni (.sym b cc)
-	 (.str (.sym b cc) " label9")
-	 (NOT-IN-DELAY-SLOT)
-	 (.str (.sym b cc) " $label9")
-	 (+ OP1_E (.sym CC_ cc) label9)
-	 (if condition (set pc label9))
-	 ((fr30-1 (unit u-cti)))
-    )
-  )
-)
-
-(cond-branch ra (const BI 1))
-(cond-branch no (const BI 0))
-(cond-branch eq      zbit)
-(cond-branch ne (not zbit))
-(cond-branch c       cbit)
-(cond-branch nc (not cbit))
-(cond-branch n       nbit)
-(cond-branch p  (not nbit))
-(cond-branch v       vbit)
-(cond-branch nv (not vbit))
-(cond-branch lt      (xor vbit nbit))
-(cond-branch ge (not (xor vbit nbit)))
-(cond-branch le      (or (xor vbit nbit) zbit))
-(cond-branch gt (not (or (xor vbit nbit) zbit)))
-(cond-branch ls      (or cbit zbit))
-(cond-branch hi (not (or cbit zbit)))
-
-(define-pmacro (dir2r13 name insn opc1 opc2 mode arg1)
-  (dni name
-       (.str insn " @" arg1 ",R13")
-       ()
-       (.str insn " @$" arg1 ",$R13")
-       (+ opc1 opc2 arg1)
-       (set (reg h-gr 13) (mem mode arg1))
-       ((fr30-1 (unit u-load)))
-  )
-)
-
-(define-pmacro (dir2r13-postinc name insn opc1 opc2 mode arg1 incr)
-  (dni name
-       (.str insn " @" arg1 ",@R13+")
-       (NOT-IN-DELAY-SLOT)
-       (.str insn " @$" arg1 ",@$R13+")
-       (+ opc1 opc2 arg1)
-       (sequence ()
-		 (set (mem mode (reg h-gr 13)) (mem mode arg1))
-		 (set (reg h-gr 13) (add (reg h-gr 13) incr)))
-       ((fr30-1 (unit u-load) (unit u-store)))
-  )
-)
-
-(define-pmacro (r132dir name insn opc1 opc2 mode arg1)
-  (dni name
-       (.str insn " R13,@" arg1)
-       ()
-       (.str insn " $R13,@$" arg1)
-       (+ opc1 opc2 arg1)
-       (set (mem mode arg1) (reg h-gr 13))
-       ((fr30-1 (unit u-store)))
-  )
-)
-
-(define-pmacro (r13-postinc2dir name insn opc1 opc2 mode arg1 incr)
-  (dni name
-       (.str insn " @R13+,@" arg1)
-       (NOT-IN-DELAY-SLOT)
-       (.str insn " @$R13+,@$" arg1)
-       (+ opc1 opc2 arg1)
-       (sequence ()
-		 (set (mem mode arg1) (mem mode (reg h-gr 13)))
-		 (set (reg h-gr 13) (add (reg h-gr 13) incr)))
-       ((fr30-1 (unit u-load) (unit u-store)))
-  )
-)
-
-; These versions which move from reg to mem must appear before the other
-; versions which use immediate addresses due to a problem in cgen
-; - DB.
-(r132dir dmovr13  dmov  OP1_1 OP2_8 WI dir10)
-(r132dir dmovr13h dmovh OP1_1 OP2_9 HI dir9)
-(r132dir dmovr13b dmovb OP1_1 OP2_A QI dir8)
-
-(r13-postinc2dir dmovr13pi  dmov  OP1_1 OP2_C WI dir10 (const 4))
-(r13-postinc2dir dmovr13pih dmovh OP1_1 OP2_D HI dir9  (const 2))
-(r13-postinc2dir dmovr13pib dmovb OP1_1 OP2_E QI dir8  (const 1))
-
-(dni dmovr15pi
-     "dmov @R15+,@dir10"
-     (NOT-IN-DELAY-SLOT)
-     "dmov @$R15+,@$dir10"
-     (+ OP1_1 OP2_B dir10)
-     (sequence ()
-	       (set (mem WI dir10) (mem WI (reg h-gr 15)))
-	       (set (reg h-gr 15) (add (reg h-gr 15) (const 4))))
-     ((fr30-1 (unit u-load) (unit u-store)))
-)
-; End of reordered insns.
-
-(dir2r13 dmov2r13  dmov  OP1_0 OP2_8 WI dir10)
-(dir2r13 dmov2r13h dmovh OP1_0 OP2_9 HI dir9)
-(dir2r13 dmov2r13b dmovb OP1_0 OP2_A QI dir8)
-
-(dir2r13-postinc dmov2r13pi  dmov  OP1_0 OP2_C WI dir10 (const 4))
-(dir2r13-postinc dmov2r13pih dmovh OP1_0 OP2_D HI dir9  (const 2))
-(dir2r13-postinc dmov2r13pib dmovb OP1_0 OP2_E QI dir8  (const 1))
-
-(dni dmov2r15pd
-     "dmov @dir10,@-R15"
-     (NOT-IN-DELAY-SLOT)
-     "dmov @$dir10,@-$R15"
-     (+ OP1_0 OP2_B dir10)
-     (sequence ()
-	       (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-	       (set (mem WI (reg h-gr 15)) (mem WI dir10)))
-     ((fr30-1 (unit u-load) (unit u-store)))
-)
-
-; Leave these insns as stubs for now, except for the increment of $Ri
-;
-(dni ldres
-     "ldres @Ri+,#u4"
-     ()
-     "ldres @$Ri+,$u4"
-     (+ OP1_B OP2_C u4 Ri)
-     (set Ri (add Ri (const 4)))
-     ()
-)
-
-(dni stres
-     "stres #u4,@Ri+"
-     ()
-     "stres $u4,@$Ri+"
-     (+ OP1_B OP2_D u4 Ri)
-     (set Ri (add Ri (const 4)))
-     ()
-)
-
-; Leave the coprocessor insns as stubs for now.
-;
-(define-pmacro (cop-stub name insn opc1 opc2 opc3 arg1 arg2)
-  (dni name
-       (.str insn " u4c,ccc,CRj," arg1 "," arg2)
-       (NOT-IN-DELAY-SLOT)
-       (.str insn " $u4c,$ccc,$" arg1 ",$" arg2)
-       (+ opc1 opc2 opc3 u4c ccc arg1 arg2)
-       (nop) ; STUB
-       ()
-  )
-)
-
-(cop-stub copop copop OP1_9 OP2_F OP3_C CRj CRi)
-(cop-stub copld copld OP1_9 OP2_F OP3_D Rjc CRi)
-(cop-stub copst copst OP1_9 OP2_F OP3_E CRj Ric)
-(cop-stub copsv copsv OP1_9 OP2_F OP3_F CRj Ric)
-
-(dni nop
-     "nop"
-     ()
-     "nop"
-     (+ OP1_9 OP2_F OP3_A OP4_0)
-     (nop)
-     ()
-)
-
-(dni andccr
-     "andccr #u8"
-     ()
-     "andccr $u8"
-     (+ OP1_8 OP2_3 u8)
-     (set ccr (and ccr u8))
-     ()
-)
-
-(dni orccr
-     "orccr #u8"
-     ()
-     "orccr $u8"
-     (+ OP1_9 OP2_3 u8)
-     (set ccr (or ccr u8))
-     ()
-)
-
-(dni stilm
-     "stilm #u8"
-     ()
-     "stilm $u8"
-     (+ OP1_8 OP2_7 u8)
-     (set ilm (and u8 (const #x1f)))
-     ()
-)
-
-(dni addsp
-     "addsp #s10"
-     ()
-     "addsp $s10"
-     (+ OP1_A OP2_3 s10)
-     (set (reg h-gr 15) (add (reg h-gr 15) s10))
-     ()
-)
-
-(define-pmacro (ext-op name opc1 opc2 opc3 op mode mask)
-  (dni name
-       (.str name " Ri")
-       ()
-       (.str name " $Ri")
-       (+ opc1 opc2 opc3 Ri)
-       (set Ri (op WI (and mode Ri mask)))
-       ()
-  )
-)
-
-(ext-op extsb OP1_9 OP2_7 OP3_8 ext  QI  (const #xff))
-(ext-op extub OP1_9 OP2_7 OP3_9 zext UQI (const #xff))
-(ext-op extsh OP1_9 OP2_7 OP3_A ext  HI  (const #xffff))
-(ext-op extuh OP1_9 OP2_7 OP3_B zext UHI (const #xffff))
-
-(dni ldm0
-     "ldm0 (reglist_low_ld)"
-     (NOT-IN-DELAY-SLOT)
-     "ldm0 ($reglist_low_ld)"
-     (+ OP1_8 OP2_C reglist_low_ld)
-     (sequence ()
-	       (if (and reglist_low_ld (const #x1))
-		   (sequence ()
-			     (set (reg h-gr 0) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_low_ld (const #x2))
-		   (sequence ()
-			     (set (reg h-gr 1) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_low_ld (const #x4))
-		   (sequence ()
-			     (set (reg h-gr 2) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_low_ld (const #x8))
-		   (sequence ()
-			     (set (reg h-gr 3) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_low_ld (const #x10))
-		   (sequence ()
-			     (set (reg h-gr 4) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_low_ld (const #x20))
-		   (sequence ()
-			     (set (reg h-gr 5) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_low_ld (const #x40))
-		   (sequence ()
-			     (set (reg h-gr 6) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_low_ld (const #x80))
-		   (sequence ()
-			     (set (reg h-gr 7) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-     )
-     ((fr30-1 (unit u-ldm)))
-)
-
-(dni ldm1
-     "ldm1 (reglist_hi_ld)"
-     (NOT-IN-DELAY-SLOT)
-     "ldm1 ($reglist_hi_ld)"
-     (+ OP1_8 OP2_D reglist_hi_ld)
-     (sequence ()
-	       (if (and reglist_hi_ld (const #x1))
-		   (sequence ()
-			     (set (reg h-gr 8) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_hi_ld (const #x2))
-		   (sequence ()
-			     (set (reg h-gr 9) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_hi_ld (const #x4))
-		   (sequence ()
-			     (set (reg h-gr 10) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_hi_ld (const #x8))
-		   (sequence ()
-			     (set (reg h-gr 11) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_hi_ld (const #x10))
-		   (sequence ()
-			     (set (reg h-gr 12) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_hi_ld (const #x20))
-		   (sequence ()
-			     (set (reg h-gr 13) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_hi_ld (const #x40))
-		   (sequence ()
-			     (set (reg h-gr 14) (mem WI (reg h-gr 15)))
-			     (set (reg h-gr 15) (add (reg h-gr 15) (const 4)))))
-	       (if (and reglist_hi_ld (const #x80))
-		   (set (reg h-gr 15) (mem WI (reg h-gr 15))))
-     )
-     ((fr30-1 (unit u-ldm)))
-)
-
-(dni stm0
-     "stm0 (reglist_low_st)"
-     (NOT-IN-DELAY-SLOT)
-     "stm0 ($reglist_low_st)"
-     (+ OP1_8 OP2_E reglist_low_st)
-     (sequence ()
-	       (if (and reglist_low_st (const #x1))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 7))))
-	       (if (and reglist_low_st (const #x2))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 6))))
-	       (if (and reglist_low_st (const #x4))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 5))))
-	       (if (and reglist_low_st (const #x8))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 4))))
-	       (if (and reglist_low_st (const #x10))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 3))))
-	       (if (and reglist_low_st (const #x20))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 2))))
-	       (if (and reglist_low_st (const #x40))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 1))))
-	       (if (and reglist_low_st (const #x80))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 0))))
-     )
-     ((fr30-1 (unit u-stm)))
-)
-
-(dni stm1
-     "stm1 (reglist_hi_st)"
-     (NOT-IN-DELAY-SLOT)
-     "stm1 ($reglist_hi_st)"
-     (+ OP1_8 OP2_F reglist_hi_st)
-     (sequence ()
-	       (if (and reglist_hi_st (const #x1))
-		   (sequence ((WI save-r15))
-			     (set save-r15 (reg h-gr 15))
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) save-r15)))
-	       (if (and reglist_hi_st (const #x2))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 14))))
-	       (if (and reglist_hi_st (const #x4))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 13))))
-	       (if (and reglist_hi_st (const #x8))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 12))))
-	       (if (and reglist_hi_st (const #x10))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 11))))
-	       (if (and reglist_hi_st (const #x20))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 10))))
-	       (if (and reglist_hi_st (const #x40))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 9))))
-	       (if (and reglist_hi_st (const #x80))
-		   (sequence ()
-			     (set (reg h-gr 15) (sub (reg h-gr 15) (const 4)))
-			     (set (mem WI (reg h-gr 15)) (reg h-gr 8))))
-     )
-     ((fr30-1 (unit u-stm)))
-)
-
-(dni enter
-     "enter #u10"
-     (NOT-IN-DELAY-SLOT)
-     "enter $u10"
-     (+ OP1_0 OP2_F u10)
-     (sequence ((WI tmp))
-	       (set tmp (sub (reg h-gr 15) (const 4)))
-	       (set (mem WI tmp) (reg h-gr 14))
-	       (set (reg h-gr 14) tmp)
-	       (set (reg h-gr 15) (sub (reg h-gr 15) u10)))
-     ((fr30-1 (unit u-exec (cycles 2))))
-)
-
-(dni leave
-     "leave"
-     ()
-     "leave"
-     (+ OP1_9 OP2_F OP3_9 OP4_0)
-     (sequence ()
-	       (set (reg h-gr 15) (add (reg h-gr 14) (const 4)))
-	       (set (reg h-gr 14) (mem WI (sub (reg h-gr 15) (const 4)))))
-     ()
-)
-
-(dni xchb  
-     "xchb @Rj,Ri"
-     (NOT-IN-DELAY-SLOT)
-     "xchb @$Rj,$Ri"
-     (+ OP1_8 OP2_A Rj Ri)
-     (sequence ((WI tmp))
-	       (set tmp Ri)
-	       (set Ri (mem UQI Rj))
-	       (set (mem UQI Rj) tmp))
-     ((fr30-1 (unit u-load) (unit u-store)))
-)
diff -rupN binutils-2.19.1-original/cgen/cpu/fr30.opc binutils-2.19.1/cgen/cpu/fr30.opc
--- binutils-2.19.1-original/cgen/cpu/fr30.opc	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/fr30.opc	1969-12-31 19:00:00.000000000 -0500
@@ -1,254 +0,0 @@
-
-/* -*- C -*-
-   Copyright 2011 Free Software Foundation, Inc.
-
-   Contributed by Red Hat Inc;
-
-   This file is part of the GNU Binutils.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-/* This file is an addendum to fr30.cpu.  Heavy use of C code isn't
-   appropriate in .cpu files, so it resides here.  This especially applies
-   to assembly/disassembly where parsing/printing can be quite involved.
-   Such things aren't really part of the specification of the cpu, per se,
-   so .cpu files provide the general framework and .opc files handle the
-   nitty-gritty details as necessary.
-
-   Each section is delimited with start and end markers.
-
-   <arch>-opc.h additions use: "-- opc.h"
-   <arch>-opc.c additions use: "-- opc.c"
-   <arch>-asm.c additions use: "-- asm.c"
-   <arch>-dis.c additions use: "-- dis.c"
-   <arch>-ibd.h additions use: "-- ibd.h".  */
-
-/* -- opc.h */
-
-/* ??? This can be improved upon.  */
-#undef  CGEN_DIS_HASH_SIZE
-#define CGEN_DIS_HASH_SIZE 16
-#undef  CGEN_DIS_HASH
-#define CGEN_DIS_HASH(buffer, value) (((unsigned char *) (buffer))[0] >> 4)
-
-/* -- */
-
-/* -- asm.c */
-/* Handle register lists for LDMx and STMx.  */
-
-static int
-parse_register_number (const char **strp)
-{
-  int regno;
-
-  if (**strp < '0' || **strp > '9')
-    return -1; /* Error.  */
-  regno = **strp - '0';
-  ++*strp;
-
-  if (**strp >= '0' && **strp <= '9')
-    {
-      regno = regno * 10 + (**strp - '0');
-      ++*strp;
-    }
-
-  return regno;
-}
-
-static const char *
-parse_register_list (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-		     const char **strp,
-		     int opindex ATTRIBUTE_UNUSED,
-		     unsigned long *valuep,
-		     int high_low,   /* 0 == high, 1 == low.  */
-		     int load_store) /* 0 == load, 1 == store.  */
-{
-  *valuep = 0;
-  while (**strp && **strp != ')')
-    {
-      int regno;
-
-      if (**strp != 'R' && **strp != 'r')
-	break;
-      ++*strp;
-
-      regno = parse_register_number (strp);
-      if (regno == -1)
-	return _("Register number is not valid");
-      if (regno > 7 && !high_low)
-	return _("Register must be between r0 and r7");
-      if (regno < 8 && high_low)
-	return _("Register must be between r8 and r15");
-
-      if (high_low)
-	regno -= 8;
-
-      if (load_store) /* Mask is reversed for store.  */
-	*valuep |= 0x80 >> regno;
-      else
-	*valuep |= 1 << regno;
-
-      if (**strp == ',')
-	{
-	  if (*(*strp + 1) == ')')
-	    break;
-	  ++*strp;
-	}
-    }
-
-  if (!*strp || **strp != ')')
-    return _("Register list is not valid");
-
-  return NULL;
-}
-
-static const char *
-parse_low_register_list_ld (CGEN_CPU_DESC cd,
-			    const char **strp,
-			    int opindex,
-			    unsigned long *valuep)
-{
-  return parse_register_list (cd, strp, opindex, valuep,
-			      0 /* Low.  */, 0 /* Load.  */);
-}
-
-static const char *
-parse_hi_register_list_ld (CGEN_CPU_DESC cd,
-			   const char **strp,
-			   int opindex,
-			   unsigned long *valuep)
-{
-  return parse_register_list (cd, strp, opindex, valuep,
-			      1 /* High.  */, 0 /* Load.  */);
-}
-
-static const char *
-parse_low_register_list_st (CGEN_CPU_DESC cd,
-			    const char **strp,
-			    int opindex,
-			    unsigned long *valuep)
-{
-  return parse_register_list (cd, strp, opindex, valuep,
-			      0 /* Low.  */, 1 /* Store.  */);
-}
-
-static const char *
-parse_hi_register_list_st (CGEN_CPU_DESC cd,
-			   const char **strp,
-			   int opindex,
-			   unsigned long *valuep)
-{
-  return parse_register_list (cd, strp, opindex, valuep,
-			      1 /* High.  */, 1 /* Store.  */);
-}
-
-/* -- */
-
-/* -- dis.c */
-static void
-print_register_list (void * dis_info,
-		     long value,
-		     long offset,
-		     int load_store) /* 0 == load, 1 == store.  */
-{
-  disassemble_info *info = dis_info;
-  int mask;
-  int index = 0;
-  char * comma = "";
-
-  if (load_store)
-    mask = 0x80;
-  else
-    mask = 1;
-
-  if (value & mask)
-    {
-      (*info->fprintf_func) (info->stream, "r%li", index + offset);
-      comma = ",";
-    }
-    
-  for (index = 1; index <= 7; ++index)
-    {
-      if (load_store)
-	mask >>= 1;
-      else
-	mask <<= 1;
-
-      if (value & mask)
-	{
-	  (*info->fprintf_func) (info->stream, "%sr%li", comma, index + offset);
-	  comma = ",";
-	}
-    }
-}
-
-static void
-print_hi_register_list_ld (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-			   void * dis_info,
-			   long value,
-			   unsigned int attrs ATTRIBUTE_UNUSED,
-			   bfd_vma pc ATTRIBUTE_UNUSED,
-			   int length ATTRIBUTE_UNUSED)
-{
-  print_register_list (dis_info, value, 8, 0 /* Load.  */);
-}
-
-static void
-print_low_register_list_ld (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-			    void * dis_info,
-			    long value,
-			    unsigned int attrs ATTRIBUTE_UNUSED,
-			    bfd_vma pc ATTRIBUTE_UNUSED,
-			    int length ATTRIBUTE_UNUSED)
-{
-  print_register_list (dis_info, value, 0, 0 /* Load.  */);
-}
-
-static void
-print_hi_register_list_st (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-			   void * dis_info,
-			   long value,
-			   unsigned int attrs ATTRIBUTE_UNUSED,
-			   bfd_vma pc ATTRIBUTE_UNUSED,
-			   int length ATTRIBUTE_UNUSED)
-{
-  print_register_list (dis_info, value, 8, 1 /* Store.  */);
-}
-
-static void
-print_low_register_list_st (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-			    void * dis_info,
-			    long value,
-			    unsigned int attrs ATTRIBUTE_UNUSED,
-			    bfd_vma pc ATTRIBUTE_UNUSED,
-			    int length ATTRIBUTE_UNUSED)
-{
-  print_register_list (dis_info, value, 0, 1 /* Store.  */);
-}
-
-static void
-print_m4 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	  void * dis_info,
-	  long value,
-	  unsigned int attrs ATTRIBUTE_UNUSED,
-	  bfd_vma pc ATTRIBUTE_UNUSED,
-	  int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  (*info->fprintf_func) (info->stream, "%ld", value);
-}
-/* -- */
diff -rupN binutils-2.19.1-original/cgen/cpu/ip2k.cpu binutils-2.19.1/cgen/cpu/ip2k.cpu
--- binutils-2.19.1-original/cgen/cpu/ip2k.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/ip2k.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,1480 +0,0 @@
-
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-(include "simplify.inc")
-
-; define-arch must appear first
-
-(define-arch
-  (name ip2k) ; name of cpu family
-  (comment "Ubicom IP2000 family")
-  (default-alignment aligned)
-  (insn-lsb0? #t)
-  (machs ip2022 ip2022ext)
-  (isas ip2k)
-)
-
-; Attributes.
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name EXT-SKIP-INSN)
-  (comment "instruction is a PAGE, LOADL, LOADH or BREAKX instruction")
-)
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name SKIPA)
-  (comment "instruction is a SKIP instruction")
-)
-
-; Instruction set parameters.
-
-(define-isa
-  (name ip2k)
-  (comment "Ubicom IP2000 ISA")
-
-  (default-insn-word-bitsize 16)
-  (default-insn-bitsize 16)
-  (base-insn-bitsize 16)
-)
-
-; Cpu family definitions.
-
-
-(define-cpu
-  ; cpu names must be distinct from the architecture name and machine names.
-  (name ip2kbf)
-  (comment "Ubicom IP2000 Family")
-  (endian big)
-  (word-bitsize 16)
-)
-
-(define-mach
-  (name ip2022)
-  (comment "Ubicom IP2022")
-  (cpu ip2kbf)
-)
-
-(define-mach
-  (name ip2022ext)
-  (comment "Ubicom IP2022 extended")
-  (cpu ip2kbf)
-)
-
-
-; Model descriptions.
-
-(define-model
-  (name ip2k) (comment "VPE 2xxx") (attrs)
-  (mach ip2022ext)
-
-  (unit u-exec "Execution Unit" ()
-	1 1 ; issue done
-	() ; state
-	() ; inputs
-	() ; outputs
-	() ; profile action (default)
-	)
-)
-
-
-; FIXME: It might simplify things to separate the execute process from the
-; one that updates the PC.
-
-; Instruction fields.
-;
-; Attributes:
-; XXX: what VPE attrs
-; PCREL-ADDR: pc relative value (for reloc and disassembly purposes)
-; ABS-ADDR: absolute address (for reloc and disassembly purposes?)
-; RESERVED: bits are not used to decode insn, must be all 0
-; RELOC: there is a relocation associated with this field (experiment)
-
-
-(dnf f-imm8      "imm8"                () 7 8)
-(dnf f-reg       "reg"         (ABS-ADDR) 8 9)
-(dnf f-addr16cjp "addr16cjp"   (ABS-ADDR) 12 13)
-(dnf f-dir       "dir"                 () 9 1)
-(dnf f-bitno     "bit number"          () 11 3)
-(dnf f-op3       "op3"                 () 15 3)
-(dnf f-op4       "op4"                 () 15 4)
-(dnf f-op4mid    "op4mid"              () 11 4)
-(dnf f-op6       "op6"                 () 15 6)
-(dnf f-op8       "op8"                 () 15 8)
-(dnf f-op6-10low "op6-10low"           () 9 10)
-(dnf f-op6-7low  "op6-7low"            () 9 7)
-(dnf f-reti3     "reti3"               () 2 3)
-(dnf f-skipb     "sb/snb"      (ABS-ADDR) 12 1)
-(dnf f-page3     "page3"               ()  2 3)
-;(define-ifield (name f-page3) (comment "page3") (attrs) (start 2) (length 3)
-;  (encode (value pc) (srl WI value 13))
-;  (decode (value pc) (sll WI value 13))
-;)
-; To fix the page/call asymmetry
-;(define-ifield (name f-page3) (comment "page3") (attrs) (start 2) (length 3)
-;  (encode (value pc) (srl WI value 13))
-;  (decode (value pc) (sll WI value 13))
-;)
-
-
-
-; Enums.
-
-; insn-op6: bits 15-10
-(define-normal-insn-enum insn-op6 "op6 enums" () OP6_ f-op6
-  (OTHER1 OTHER2 SUB DEC OR AND XOR ADD 
-   TEST NOT INC DECSZ RR RL SWAP INCSZ
-   CSE POP SUBC DECSNZ MULU MULS INCSNZ  ADDC
-   - - - - - - - -   
-   - - - - - - - -
-   - - - - - - - -
-   - - - - - - - -
-   - - - - - - - -   
-   )
-)
-
-; insn-dir: bit 9
-(define-normal-insn-enum insn-dir "dir enums" () DIR_ f-dir
-  ; This bit specifies the polarity of many two-operand instructions:
-  ; TO_W writes result to W regiser  (eg. ADDC W,$fr)
-  ; NOTTO_W writes result in general register  (eg. ADDC $fr,W)
-  (TO_W NOTTO_W)
-)
-
-
-; insn-op4: bits 15-12
-(define-normal-insn-enum insn-op4 "op4 enums" () OP4_ f-op4
-  (- - - - - - - LITERAL
-   CLRB SETB SNB SB - - - -
-   )
-)
-
-; insn-op4mid: bits 11-8
-; used for f-op4=LITERAL
-(define-normal-insn-enum insn-op4mid "op4mid enums" () OP4MID_ f-op4mid
-  (LOADH_L LOADL_L MULU_L MULS_L PUSH_L  -  CSNE_L CSE_L
-   RETW_L CMP_L SUB_L ADD_L MOV_L OR_L AND_L XOR_L)
-)
-
-; insn-op3: bits 15-13
-(define-normal-insn-enum insn-op3 "op3 enums" () OP3_ f-op3
-  (- - - - - - CALL JMP)
-)
-
-
-  
-; Hardware pieces.
-
-; Bank-relative general purpose registers
-
-; (define-pmacro (build-reg-name n) (.splice (.str "$" n) n))
-
-(define-keyword
-  (name register-names)
-  (print-name h-registers)
-  (prefix "")
-  (values
-   ; These are the "Special Purpose Registers" that are not reserved
-   ("ADDRSEL" #x2) ("ADDRX" #x3)
-   ("IPH" #x4) ("IPL" #x5) ("SPH" #x6) ("SPL" #x7)
-   ("PCH" #x8) ("PCL" #x9) ("WREG" #xA) ("STATUS" #xB)
-   ("DPH" #xC) ("DPL" #xD) ("SPDREG" #xE) ("MULH" #xF)
-   ("ADDRH" #x10) ("ADDRL" #x11) ("DATAH" #x12) ("DATAL" #x13)
-   ("INTVECH" #x14) ("INTVECL" #x15) ("INTSPD" #x16) ("INTF" #x17)
-   ("INTE" #x18) ("INTED" #x19) ("FCFG" #x1A) ("TCTRL" #x1B)
-   ("XCFG" #x1C) ("EMCFG" #x1D) ("IPCH" #x1E) ("IPCL" #x1F)
-   ("RAIN" #x20) ("RAOUT" #x21) ("RADIR" #x22) ("LFSRH" #x23)
-   ("RBIN" #x24) ("RBOUT" #x25) ("RBDIR" #x26) ("LFSRL" #x27)
-   ("RCIN" #x28) ("RCOUT" #x29) ("RCDIR" #x2A) ("LFSRA" #x2B)
-   ("RDIN" #x2C) ("RDOUT" #x2D) ("RDDIR" #x2E)   
-   ("REIN" #x30) ("REOUT" #x31) ("REDIR" #x32)   
-   ("RFIN" #x34) ("RFOUT" #x35) ("RFDIR" #x36)
-                 ("RGOUT" #x39) ("RGDIR" #x3A)
-   ("RTTMR" #x40) ("RTCFG" #x41) ("T0TMR" #x42) ("T0CFG" #x43)
-   ("T1CNTH" #x44) ("T1CNTL" #x45) ("T1CAP1H" #x46) ("T1CAP1L" #x47)
-   ("T1CAP2H" #x48) ("T1CMP2H" #x48) ("T1CAP2L" #x49) ("T1CMP2L" #x49) ; note aliases
-                                     ("T1CMP1H" #x4A) ("T1CMP1L" #x4B)
-   ("T1CFG1H" #x4C) ("T1CFG1L" #x4D) ("T1CFG2H" #x4E) ("T1CFG2L" #x4F)
-   ("ADCH" #x50) ("ADCL" #x51) ("ADCCFG" #x52) ("ADCTMR" #x53)
-   ("T2CNTH" #x54) ("T2CNTL" #x55) ("T2CAP1H" #x56) ("T2CAP1L" #x57)
-   ("T2CAP2H" #x58) ("T2CMP2H" #x58) ("T2CAP2L" #x59) ("T2CMP2L" #x59) ; note aliases
-                                     ("T2CMP1H" #x5A) ("T2CMP1L" #x5B)
-   ("T2CFG1H" #x5C) ("T2CFG1L" #x5D) ("T2CFG2H" #x5E) ("T2CFG2L" #x5F)
-   ("S1TMRH" #x60) ("S1TMRL" #x61) ("S1TBUFH" #x62) ("S1TBUFL" #x63)
-   ("S1TCFG" #x64) ("S1RCNT" #x65) ("S1RBUFH" #x66) ("S1RBUFL" #x67)
-   ("S1RCFG" #x68) ("S1RSYNC" #x69) ("S1INTF" #x6A) ("S1INTE" #x6B)
-   ("S1MODE" #x6C) ("S1SMASK" #x6D) ("PSPCFG" #x6E) ("CMPCFG" #x6F)
-   ("S2TMRH" #x70) ("S2TMRL" #x71) ("S2TBUFH" #x72) ("S2TBUFL" #x73)
-   ("S2TCFG" #x74) ("S2RCNT" #x75) ("S2RBUFH" #x76) ("S2RBUFL" #x77)
-   ("S2RCFG" #x78) ("S2RSYNC" #x79) ("S2INTF" #x7A) ("S2INTE" #x7B)
-   ("S2MODE" #x7C) ("S2SMASK" #x7D) ("CALLH" #x7E) ("CALLL" #x7F))
-  )
-
-(define-hardware
-  (name h-spr)
-  (comment "special-purpose registers")
-  (type register QI (128))
-  (get (index) (c-call QI "get_spr" index ))
-  (set (index newval) (c-call VOID "set_spr" index newval ))
-)
-
-
-;;(define-hardware
-;;  (name h-gpr-global)
-;;  (comment "gpr registers - global")
-;;  (type register QI (128))
-;;)
-
-; The general register
-
-(define-hardware
-  (name h-registers)
-  (comment "all addressable registers")
-  (attrs VIRTUAL)
-  (type register QI (512))
-  (get (index) (c-call QI "get_h_registers" index ))
-  (set (index newval) (c-call VOID "set_h_registers" index newval ))
-)
-
-; The hardware stack.
-; Use {push,pop}_pc_stack c-calls to operate on this hardware element.
-
-(define-hardware
-  (name h-stack)
-  (comment "hardware stack")
-  (type register UHI (16))
-)
-
-(dsh h-pabits "page bits" () (register QI))
-(dsh h-zbit "zero bit" () (register BI))
-(dsh h-cbit "carry bit" () (register BI))
-(dsh h-dcbit "digit-carry bit" () (register BI))
-(dnh h-pc "program counter" (PC PROFILE) (pc) () () ())
-
-
-; Operands
-
-(define-operand (name addr16cjp) (comment "13-bit address") (attrs) 
-  (type h-uint) (index f-addr16cjp) (handlers (parse "addr16_cjp") (print "dollarhex_cj"))) ; overload lit8 printer
-(define-operand (name fr) (comment "register") (attrs) 
-  (type h-registers) (index f-reg) (handlers (parse "fr") (print "fr")))
-(define-operand (name lit8) (comment "8-bit signed literal") (attrs)
-  (type h-sint) (index f-imm8) (handlers (parse "lit8") (print "dollarhex8")))
-(define-operand (name bitno) (comment "bit number") (attrs)
-  (type h-uint) (index f-bitno) (handlers (parse "bit3")(print "decimal")))
-(define-operand (name addr16p) (comment "page number") (attrs)
-  (type h-uint) (index f-page3) (handlers (parse "addr16_cjp") (print "dollarhex_p")))
-(define-operand (name addr16h) (comment "high 8 bits of address") (attrs)
-  (type h-uint) (index f-imm8) (handlers (parse "addr16") (print "dollarhex_addr16h")))
-(define-operand (name addr16l) (comment "low 8 bits of address") (attrs)
-  (type h-uint) (index f-imm8) (handlers (parse "addr16") (print "dollarhex_addr16l")))
-(define-operand (name reti3) (comment "reti flags") (attrs)
-  (type h-uint) (index f-reti3) (handlers (print "dollarhex")))
-(dnop pabits   "page bits"                 () h-pabits f-nil)
-(dnop zbit     "zero bit"                  () h-zbit f-nil)
-(dnop cbit     "carry bit"                 () h-cbit f-nil)
-(dnop dcbit    "digit carry bit"           () h-dcbit f-nil)
-;;(dnop bank     "bank register"             () h-bank-no f-nil)
-
-(define-pmacro w     (reg h-spr #x0A))
-(define-pmacro mulh  (reg h-spr #x0F))
-(define-pmacro dph   (reg h-spr #x0C))
-(define-pmacro dpl   (reg h-spr #x0D))
-(define-pmacro sph   (reg h-spr #x06))
-(define-pmacro spl   (reg h-spr #x07))
-(define-pmacro iph   (reg h-spr #x04))
-(define-pmacro ipl   (reg h-spr #x05))
-(define-pmacro addrh (reg h-spr #x10))
-(define-pmacro addrl (reg h-spr #x11))
-
-
-
-; Pseudo-RTL for DC flag calculations
-; "DC" = "digit carry", ie carry between nibbles
-(define-pmacro (add-dcflag a b c)
-  (add-cflag (sll QI a 4) (sll QI b 4) c)
-)
-
-(define-pmacro (sub-dcflag a b c)
-  (sub-cflag (sll QI a 4) (sll QI b 4) c)
-)
-
-; Check to see if an fr is one of IPL, SPL, DPL, ADDRL, PCL.
-(define-pmacro (LregCheck isLreg fr9bit)
-   (sequence()
-      (set isLreg #x0) ;; Assume it's not an Lreg
-      (if (or (or (eq fr9bit #x5) (eq fr9bit #x7))
-	      (or (eq fr9bit #x9)
-		  (or (eq fr9bit #xd) (eq fr9bit #x11))))
-          (set isLreg #x1)
-      )
-   )
-) 
-
-
-; Instructions, in order of the "Instruction Set Map" table on
-; pp 19-20 of IP2022 spec V1.09
-
-(dni jmp "Jump"
-     ()
-     "jmp $addr16cjp"
-     (+ OP3_JMP addr16cjp)
-     (set pc (or (sll pabits 13) addr16cjp))
-     ()
-)
-
-; note that in call, we push pc instead of pc + 1 because the ip2k increments
-; the pc prior to execution of the instruction
-(dni call "Call"
-     ()
-     "call $addr16cjp"
-     (+ OP3_CALL addr16cjp)
-     (sequence ()
-	       (c-call "push_pc_stack" pc)
-	       (set pc (or (sll pabits 13) addr16cjp)))
-     ()
-)
-
-(dni sb "Skip if bit set"
-     ()
-     "sb $fr,$bitno"
-     (+ OP4_SB bitno fr)
-     (if (and fr (sll 1 bitno))
-	 (skip 1))
-     ()
-)
-
-(dni snb "Skip if bit clear"
-     ()
-     "snb $fr,$bitno"
-     (+ OP4_SNB bitno fr)
-     (if (not (and fr (sll 1 bitno)))
-	 (skip 1))
-     ()
-)
-
-(dni setb "Set bit"
-     ()
-     "setb $fr,$bitno"
-     (+ OP4_SETB bitno fr)
-     (set fr (or fr (sll 1 bitno)))
-     ()
-)
-
-(dni clrb "Clear bit"
-     ()
-     "clrb $fr,$bitno"
-     (+ OP4_CLRB bitno fr)
-     (set fr (and fr (inv (sll 1 bitno))))
-     ()
-)
-
-(dni xorw_l "XOR W,literal"
-     ()
-     "xor W,#$lit8"
-     (+ OP4_LITERAL OP4MID_XOR_L lit8)
-     (sequence ()
-	       (set w (xor w lit8))
-	       (set zbit (zflag w)))
-     ()
-)
-
-(dni andw_l "AND W,literal"
-     ()
-     "and W,#$lit8"
-     (+ OP4_LITERAL OP4MID_AND_L lit8)
-     (sequence ()
-	       (set w (and w lit8))
-	       (set zbit (zflag w)))
-     ()
-)
-
-(dni orw_l "OR W,literal"
-     ()
-     "or W,#$lit8"
-     (+ OP4_LITERAL OP4MID_OR_L lit8)
-     (sequence ()
-	       (set w (or w lit8))
-	       (set zbit (zflag w)))
-     ()
-)
-
-(dni addw_l "ADD W,literal"
-     ()
-     "add W,#$lit8"
-     (+ OP4_LITERAL OP4MID_ADD_L lit8)
-     (sequence ()
-	       (set cbit (add-cflag w lit8 0))
-	       (set dcbit (add-dcflag w lit8 0))
-	       (set w (add w lit8))
-	       (set zbit (zflag w)))
-     ()
-)
-
-(dni subw_l "SUB W,literal"
-     ()
-     "sub W,#$lit8"
-     (+ OP4_LITERAL OP4MID_SUB_L lit8)
-     (sequence ()
-	       (set cbit (not (sub-cflag lit8 w 0)))
-	       (set dcbit (not (sub-dcflag lit8 w 0)))
-	       (set zbit (zflag (sub w lit8)))
-	       (set w (sub lit8 w)))
-     ()
-)
-
-(dni cmpw_l "CMP W,literal"
-     ()
-     "cmp W,#$lit8"
-     (+ OP4_LITERAL OP4MID_CMP_L lit8)
-     (sequence ()
-	       (set cbit (not (sub-cflag lit8 w 0)))
-	       (set dcbit (not (sub-dcflag lit8 w 0)))
-	       (set zbit (zflag (sub w lit8))))
-     ()
-)
-
-(dni retw_l "RETW literal"
-     ()
-     "retw #$lit8"
-     (+ OP4_LITERAL OP4MID_RETW_L lit8)
-     (sequence ((USI new_pc))
-	       (set w lit8)
-	       (set new_pc (c-call UHI "pop_pc_stack"))
-	       (set pabits (srl new_pc 13))
-	       (set pc new_pc))
-     ()
-)
-
-(dni csew_l "CSE W,literal"
-     ()
-     "cse W,#$lit8"
-     (+ OP4_LITERAL OP4MID_CSE_L lit8)
-     (if (eq w lit8)
-	 (skip 1))
-     ()
-)
-
-(dni csnew_l "CSNE W,literal"
-     ()
-     "csne W,#$lit8"
-     (+ OP4_LITERAL OP4MID_CSNE_L lit8)
-     (if (not (eq w lit8))
-	 (skip 1))
-     ()
-)
-
-(dni push_l "Push #lit8"
-     ()
-     "push #$lit8"
-     (+ OP4_LITERAL OP4MID_PUSH_L lit8)
-     (sequence ()
-        (c-call "push" lit8)
-        (c-call VOID "adjuststackptr" (const -1))
-
-     )
-     ()
-)
-
-(dni mulsw_l "Multiply W,literal (signed)"
-     ()
-     "muls W,#$lit8"
-     (+ OP4_LITERAL OP4MID_MULS_L lit8)
-     (sequence ((SI tmp))
-	       (set tmp (mul (ext SI w) (ext SI (and UQI #xff lit8))))
-	       (set w (and tmp #xFF))
-	       (set mulh (srl tmp 8)))
-     ()
-)
-
-(dni muluw_l "Multiply W,literal (unsigned)"
-     ()
-     "mulu W,#$lit8"
-     (+ OP4_LITERAL OP4MID_MULU_L lit8)
-     (sequence ((USI tmp))
-	       (set tmp (and #xFFFF (mul (zext USI w) (zext USI lit8))))
-	       (set w (and tmp #xFF))
-	       (set mulh (srl tmp 8)))
-     ()
-)
-
-(dni loadl_l "LoadL literal"
-    (EXT-SKIP-INSN)
-    "loadl #$lit8"
-    (+ OP4_LITERAL OP4MID_LOADL_L lit8)
-    (set dpl (and lit8 #x00FF))
-    ()
-)
-
-(dni loadh_l "LoadH literal"
-    (EXT-SKIP-INSN)
-    "loadh #$lit8"
-    (+ OP4_LITERAL OP4MID_LOADH_L lit8)
-    (set dph (and lit8 #x00FF))
-    ()
-)
-
-(dni loadl_a "LoadL addr16l"
-    (EXT-SKIP-INSN)
-    "loadl $addr16l"
-    (+ OP4_LITERAL OP4MID_LOADL_L addr16l)
-    (set dpl (and addr16l #x00FF))
-    ()
-)
-
-(dni loadh_a "LoadH addr16h"
-    (EXT-SKIP-INSN)
-    "loadh $addr16h"
-    (+ OP4_LITERAL OP4MID_LOADH_L addr16h)
-    (set dph (and addr16l #x0FF00))
-    ()
-)
-
-;; THIS NO LONGER EXISTS -> Now LOADL
-;;(dni bank_l "Bank literal"
-;;     ()
-;;     "bank #$lit8"
-;;     (+ OP4_LITERAL OP4MID_BANK_L lit8)
-;;     (set bank lit8)
-;;     ()
-;;)
-
-(dni addcfr_w "Add w/carry fr,W"
-     ()
-     "addc $fr,W"
-     (+ OP6_ADDC DIR_NOTTO_W fr)
-     (sequence ((QI result) (BI newcbit) (QI isLreg) (HI 16bval))
-	       (set newcbit (add-cflag w fr cbit))
-	       (set dcbit (add-dcflag w fr cbit))
-               ;; If fr is an Lreg, then we have to do 16-bit arithmetic.
-               ;; We can take advantage of the fact that by a lucky
-               ;; coincidence, the address of register xxxH is always      
-               ;; one lower than the address of register xxxL.
-               (LregCheck isLreg (ifield f-reg))
-	       (if (eq isLreg #x1)
-                  (sequence() 
-                     (set 16bval (reg h-spr (sub (ifield f-reg) 1)))
-		     (set 16bval (sll 16bval 8))
-		     (set 16bval (or 16bval (and (reg h-spr (ifield f-reg)) #xFF))) 
-                     (set 16bval (addc HI 16bval w cbit))
-		     (set (reg h-spr (ifield f-reg)) (and 16bval #xFF))
-		     (set (reg h-spr (sub (ifield f-reg) 1)) 
-                          (and (srl 16bval 8) #xFF))
-                     (set result (reg h-spr (ifield f-reg)))
-                  )      
-	       (set result (addc w fr cbit)) ;; else part
-               )
-
-	       (set zbit (zflag result))
-	       (set cbit newcbit)
-	       (set fr result))
-     ()
-)
-
-(dni addcw_fr "Add w/carry W,fr"
-     ()
-     "addc W,$fr"
-     (+ OP6_ADDC DIR_TO_W fr)
-     (sequence ((QI result) (BI newcbit))
-	       (set newcbit (add-cflag w fr cbit))
-	       (set dcbit (add-dcflag w fr cbit))
-	       (set result (addc w fr cbit))
-	       (set zbit (zflag result))
-	       (set cbit newcbit)
-	       (set w result))
-     ()
-)
-
-
-(dni incsnz_fr "Skip if fr++ not zero"
-     ()
-     "incsnz $fr"
-     (+ OP6_INCSNZ DIR_NOTTO_W fr)
-     (sequence ((QI isLreg) (HI 16bval))
-        (LregCheck isLreg (ifield f-reg))
-        ;; If fr is an Lreg, then we have to do 16-bit arithmetic.
-        ;; We can take advantage of the fact that by a lucky
-        ;; coincidence, the address of register xxxH is always
-        ;; one lower than the address of register xxxL.
-        (if (eq isLreg #x1)
-           (sequence()
-              ; Create the 16 bit value
-              (set 16bval (reg h-spr (sub (ifield f-reg) 1)))
-              (set 16bval (sll 16bval 8))
-              (set 16bval (or 16bval (and (reg h-spr (ifield f-reg)) #xFF)))
-              ; Do 16 bit arithmetic.
-	      (set 16bval (add HI 16bval 1))
-              ; Separate the 16 bit values into the H and L regs
-              (set (reg h-spr (ifield f-reg)) (and 16bval #xFF))
-              (set (reg h-spr (sub (ifield f-reg) 1))
-                   (and (srl 16bval 8) #xFF))
-              (set fr (reg h-spr (ifield f-reg)))
-           )
-	   (set fr (add fr 1)) ; Do 8 bit arithmetic.
-        )
-	(if (not (zflag fr))
-	   (skip 1)))
-     ()
-)
-
-(dni incsnzw_fr "Skip if W=fr+1  not zero"
-     ()
-     "incsnz W,$fr"
-     (+ OP6_INCSNZ DIR_TO_W fr)
-     (sequence ()
-	       (set w (add fr 1))
-	       (if (not (zflag w))
-		   (skip 1)))
-     ()
-)
-
-(dni mulsw_fr "Multiply W,fr (signed)"
-     ()
-     "muls W,$fr"
-     (+ OP6_MULS DIR_TO_W fr)
-     (sequence ((SI tmp))
-	       (set tmp (mul (ext SI w) (ext SI fr)))
-	       (set w (and tmp #xFF))
-	       (set mulh (srl tmp 8)))
-     ()
-)
-
-(dni muluw_fr "Multiply W,fr (unsigned)"
-     ()
-     "mulu W,$fr"
-     (+ OP6_MULU DIR_TO_W fr)
-     (sequence ((USI tmp))
-	       (set tmp (and #xFFFF (mul (zext USI w) (zext USI fr))))
-	       (set w (and tmp #xFF))
-	       (set mulh (srl tmp 8)))
-     ()
-)
-
-(dni decsnz_fr "Skip if fr-- not zero"
-     ()
-     "decsnz $fr"
-     (+ OP6_DECSNZ DIR_NOTTO_W fr)
-     (sequence ((QI isLreg) (HI 16bval))
-         (LregCheck isLreg (ifield f-reg))
-         ;; If fr is an Lreg, then we have to do 16-bit arithmetic.
-         ;; We can take advantage of the fact that by a lucky
-         ;; coincidence, the address of register xxxH is always
-         ;; one lower than the address of register xxxL.
-         (if (eq isLreg #x1)
-            (sequence()
-               ; Create the 16 bit value
-               (set 16bval (reg h-spr (sub (ifield f-reg) 1)))
-               (set 16bval (sll 16bval 8))
-               (set 16bval (or 16bval (and (reg h-spr (ifield f-reg)) #xFF)))
-               ; New 16 bit instruction
-               (set 16bval (sub HI 16bval 1))
-               ; Separate the 16 bit values into the H and L regs
-               (set (reg h-spr (ifield f-reg)) (and 16bval #xFF))
-               (set (reg h-spr (sub (ifield f-reg) 1))
-                    (and (srl 16bval 8) #xFF))
-               (set fr (reg h-spr (ifield f-reg)))
-            )
-            ; Original instruction
-	    (set fr (sub fr 1))
-         )
-	    (if (not (zflag fr))
-	       (skip 1)))
-     ()
-)
-
-(dni decsnzw_fr "Skip if W=fr-1 not zero"
-     ()
-     "decsnz W,$fr"
-     (+ OP6_DECSNZ DIR_TO_W fr)
-     (sequence ()
-	       (set w (sub fr 1))
-	       (if (not (zflag w))
-		   (skip 1)))
-     ()
-)
-
-(dni subcw_fr "Subract w/carry W,fr"
-     ()
-     "subc W,$fr"
-     (+ OP6_SUBC DIR_TO_W fr)
-     (sequence ((QI result) (BI newcbit))
-	       (set newcbit (not (sub-cflag fr w (not cbit))))
-	       (set dcbit (not (sub-dcflag fr w (not cbit))))
-	       (set result (subc fr w (not cbit)))
-	       (set zbit (zflag result))
-	       (set cbit newcbit)
-	       (set w result))
-     ()
-)
-
-(dni subcfr_w "Subtract w/carry fr,W"
-     ()
-     "subc $fr,W"
-     (+ OP6_SUBC DIR_NOTTO_W fr)
-     (sequence ((QI result) (BI newcbit) (QI isLreg) (HI 16bval))
-	       (set newcbit (not (sub-cflag fr w (not cbit))))
-	       (set dcbit (not (sub-dcflag fr w (not cbit))))
-               (LregCheck isLreg (ifield f-reg))
-               ;; If fr is an Lreg, then we have to do 16-bit arithmetic.
-               ;; We can take advantage of the fact that by a lucky
-               ;; coincidence, the address of register xxxH is always
-               ;; one lower than the address of register xxxL.
-               (if (eq isLreg #x1)
-                  (sequence()
-                     ; Create the 16 bit value
-                     (set 16bval (reg h-spr (sub (ifield f-reg) 1)))
-                     (set 16bval (sll 16bval 8))
-                     (set 16bval (or 16bval (and (reg h-spr (ifield f-reg)) #xFF)))
-                     ; New 16 bit instruction
-	             (set 16bval (subc HI 16bval w (not cbit)))
-                     ; Separate the 16 bit values into the H and L regs
-                     (set (reg h-spr (ifield f-reg)) (and 16bval #xFF))
-                     (set (reg h-spr (sub (ifield f-reg) 1))
-                          (and (srl 16bval 8) #xFF))
-                     (set result (reg h-spr (ifield f-reg)))
-                  )
-               ; Original instruction
-	       (set result (subc fr w (not cbit)))
-               )
-
-
-	       (set zbit (zflag result))
-	       (set cbit newcbit)
-	       (set fr result))
-     ()
-)
-
-
-(dni pop_fr "Pop fr"
-     ()
-     "pop $fr"
-     (+ OP6_POP (f-dir 1) fr)
-     (sequence()
-        (set fr (c-call QI "pop")) 
-        (c-call VOID "adjuststackptr" (const 1))
-     )
-     ()
-)
-
-(dni push_fr "Push fr"
-     ()
-     "push $fr"
-     (+ OP6_POP (f-dir 0) fr)
-     (sequence()
-        (c-call "push" fr)
-        (c-call VOID "adjuststackptr" (const -1))
-     )
-     ()
-)
-
-(dni csew_fr "Skip if equal W,fr"
-     ()
-     "cse W,$fr"
-     (+ OP6_CSE (f-dir 1) fr)
-     (if (eq w fr)
-	 (skip 1))
-     ()
-)
-
-(dni csnew_fr "Skip if not-equal W,fr"
-     ()
-     "csne W,$fr"
-     (+ OP6_CSE (f-dir 0) fr)
-     (if (not (eq w fr))
-	 (skip 1))
-     ()
-)
-
-;;(dni csaw_fr "Skip if W above fr"
-;;     ((MACH ip2022ext))
-;;     "csa W,$fr"
-;;     (+ OP6_CSAB (f-dir 1) fr)
-;;     (if (gt w fr)
-;;	 (skip 1))
-;;    ()
-;;)
-
-;;(dni csbw_fr "Skip if W below fr"
-;;     ((MACH ip2022ext))
-;;     "csb W,$fr"
-;;     (+ OP6_CSAB (f-dir 0) fr)
-;;     (if (lt w fr)
-;;	 (skip 1))
-;;    ()
-;;)
-
-(dni incsz_fr "Skip if fr++ zero"
-     ()
-     "incsz $fr"
-     (+ OP6_INCSZ DIR_NOTTO_W fr)
-     (sequence ((QI isLreg) (HI 16bval))
-          (LregCheck isLreg (ifield f-reg))
-          ;; If fr is an Lreg, then we have to do 16-bit arithmetic.
-          ;; We can take advantage of the fact that by a lucky
-          ;; coincidence, the address of register xxxH is always
-          ;; one lower than the address of register xxxL.
-          (if (eq isLreg #x1)
-             (sequence()
-                ; Create the 16 bit value
-                (set 16bval (reg h-spr (sub (ifield f-reg) 1)))
-                (set 16bval (sll 16bval 8))
-                (set 16bval (or 16bval (and (reg h-spr (ifield f-reg)) #xFF)))
-                ; New 16 bit instruction
-                (set 16bval (add HI 16bval 1))
-                ; Separate the 16 bit values into the H and L regs
-                (set (reg h-spr (ifield f-reg)) (and 16bval #xFF))
-                (set (reg h-spr (sub (ifield f-reg) 1))
-                     (and (srl 16bval 8) #xFF))
-                (set fr (reg h-spr (ifield f-reg)))
-             )
-             ; Original instruction
-	     (set fr (add fr 1))
-          )
-	       (if (zflag fr)
-		   (skip 1)))
-     ()
-)
-
-(dni incszw_fr "Skip if W=fr+1 zero"
-     ()
-     "incsz W,$fr"
-     (+ OP6_INCSZ DIR_TO_W fr)
-     (sequence ()
-	       (set w (add fr 1))
-	       (if (zflag w)
-		   (skip 1)))
-     ()
-)
-
-(dni swap_fr "Swap fr nibbles"
-     ()
-     "swap $fr"
-     (+ OP6_SWAP DIR_NOTTO_W fr)
-     (set fr (or (and (sll fr 4) #xf0)
-		 (and (srl fr 4) #x0f)))
-     ()
-)
-
-(dni swapw_fr "Swap fr nibbles into W"
-     ()
-     "swap W,$fr"
-     (+ OP6_SWAP DIR_TO_W fr)
-     (set w (or (and (sll fr 4) #xf0)
-		(and (srl fr 4) #x0f)))
-     ()
-)
-
-(dni rl_fr "Rotate fr left with carry"
-     ()
-     "rl $fr"
-     (+ OP6_RL DIR_NOTTO_W fr)
-     (sequence ((QI newfr) (BI newc))
-	       (set newc (and fr #x80))
-	       (set newfr (or (sll fr 1) (if QI cbit 1 0)))
-	       (set cbit (if QI newc 1 0))
-	       (set fr newfr))
-     ()
-)
-
-(dni rlw_fr "Rotate fr left with carry into W"
-     ()
-     "rl W,$fr"
-     (+ OP6_RL DIR_TO_W fr)
-     (sequence ((QI newfr) (BI newc))
-	       (set newc (and fr #x80))
-	       (set newfr (or (sll fr 1) (if QI cbit 1 0)))
-	       (set cbit (if QI newc 1 0))
-	       (set w newfr))
-     ()
-)
-
-(dni rr_fr "Rotate fr right with carry"
-     ()
-     "rr $fr"
-     (+ OP6_RR DIR_NOTTO_W fr)
-     (sequence ((QI newfr) (BI newc))
-	       (set newc (and fr #x01))
-	       (set newfr (or (srl fr 1) (if QI cbit #x80 #x00)))
-	       (set cbit (if QI newc 1 0))
-	       (set fr newfr))
-     ()
-)
-
-(dni rrw_fr "Rotate fr right with carry into W"
-     ()
-     "rr W,$fr"
-     (+ OP6_RR DIR_TO_W fr)
-     (sequence ((QI newfr) (BI newc))
-	       (set newc (and fr #x01))
-	       (set newfr (or (srl fr 1) (if QI cbit #x80 #x00)))
-	       (set cbit (if QI newc 1 0))
-	       (set w newfr))
-     ()
-)
-
-(dni decsz_fr "Skip if fr-- zero"
-     ()
-     "decsz $fr"
-     (+ OP6_DECSZ DIR_NOTTO_W fr)
-     (sequence ((QI isLreg) (HI 16bval))
-          (LregCheck isLreg (ifield f-reg))
-          ;; If fr is an Lreg, then we have to do 16-bit arithmetic.
-          ;; We can take advantage of the fact that by a lucky
-          ;; coincidence, the address of register xxxH is always
-          ;; one lower than the address of register xxxL.
-          (if (eq isLreg #x1)
-             (sequence()
-                ; Create the 16 bit value
-                (set 16bval (reg h-spr (sub (ifield f-reg) 1)))
-                (set 16bval (sll 16bval 8))
-                (set 16bval (or 16bval (and (reg h-spr (ifield f-reg)) #xFF)))
-                ; New 16 bit instruction
-                (set 16bval (sub HI 16bval 1))
-                ; Separate the 16 bit values into the H and L regs
-                (set (reg h-spr (ifield f-reg)) (and 16bval #xFF))
-                (set (reg h-spr (sub (ifield f-reg) 1))
-                     (and (srl 16bval 8) #xFF))
-                (set fr (reg h-spr (ifield f-reg)))
-             )
-             ; Original instruction
-	     (set fr (sub fr 1))
-          )
-	       (if (zflag fr)
-		   (skip 1)))
-     ()
-)
-
-(dni decszw_fr "Skip if W=fr-1 zero"
-     ()
-     "decsz W,$fr"
-     (+ OP6_DECSZ DIR_TO_W fr)
-     (sequence ()
-	       (set w (sub fr 1))
-	       (if (zflag w)
-		   (skip 1)))
-     ()
-)
-
-(dni inc_fr "Increment fr"
-     ()
-     "inc $fr"
-     (+ OP6_INC DIR_NOTTO_W fr)
-     (sequence ((QI isLreg) (HI 16bval))
-          (LregCheck isLreg (ifield f-reg))
-          ;; If fr is an Lreg, then we have to do 16-bit arithmetic.
-          ;; We can take advantage of the fact that by a lucky
-          ;; coincidence, the address of register xxxH is always
-          ;; one lower than the address of register xxxL.
-          (if (eq isLreg #x1)
-             (sequence()
-                ; Create the 16 bit value
-                (set 16bval (reg h-spr (sub (ifield f-reg) 1)))
-                (set 16bval (sll 16bval 8))
-                (set 16bval (or 16bval (and (reg h-spr (ifield f-reg)) #xFF)))
-                ; New 16 bit instruction
-		(set 16bval (add HI 16bval 1))
-                ; Separate the 16 bit values into the H and L regs
-                (set (reg h-spr (ifield f-reg)) (and 16bval #xFF))
-                (set (reg h-spr (sub (ifield f-reg) 1))
-                     (and (srl 16bval 8) #xFF))
-                (set fr (reg h-spr (ifield f-reg)))
-             )
-             ; Original instruction
-	     (set fr (add fr 1))
-           )
-	       (set zbit (zflag fr)))
-     ()
-)
-
-(dni incw_fr "Increment fr into w"
-     ()
-     "inc W,$fr"
-     (+ OP6_INC DIR_TO_W fr)
-     (sequence ()
-	       (set w (add fr 1))
-	       (set zbit (zflag w)))
-     ()
-)
-
-(dni not_fr "Invert fr"
-     ()
-     "not $fr"
-     (+ OP6_NOT DIR_NOTTO_W fr)
-     (sequence ()
-	       (set fr (inv fr))
-	       (set zbit (zflag fr)))
-     ()
-)
-
-(dni notw_fr "Invert fr into w"
-     ()
-     "not W,$fr"
-     (+ OP6_NOT DIR_TO_W fr)
-     (sequence ()
-	       (set w (inv fr))
-	       (set zbit (zflag w)))
-     ()
-)
-
-(dni test_fr "Test fr"
-     ()
-     "test $fr"
-     (+ OP6_TEST DIR_NOTTO_W fr)
-     (sequence ()
-	       (set zbit (zflag fr)))
-     ()
-)
-
-(dni movw_l "MOV W,literal"
-     ()
-     "mov W,#$lit8"
-     (+ OP4_LITERAL OP4MID_MOV_L lit8)
-     (set w lit8)
-     ()
-)
-
-(dni movfr_w "Move/test w into fr"
-     ()
-     "mov $fr,W"
-     (+ OP6_OTHER1 DIR_NOTTO_W fr)
-     (set fr w)
-     ()
-)
-
-(dni movw_fr "Move/test fr into w"
-     ()
-     "mov W,$fr"
-     (+ OP6_TEST DIR_TO_W fr)
-     (sequence ()
-	       (set w fr)
-	       (set zbit (zflag w)))
-     ()
-)
-
-
-(dni addfr_w "Add fr,W"
-     ()
-     "add $fr,W"
-     (+ OP6_ADD DIR_NOTTO_W fr)
-     (sequence ((QI result) (QI isLreg) (HI 16bval))
-	       (set cbit (add-cflag w fr 0))
-	       (set dcbit (add-dcflag w fr 0))
-               (LregCheck isLreg (ifield f-reg))
-
-               ;; If fr is an Lreg, then we have to do 16-bit arithmetic.
-               ;; We can take advantage of the fact that by a lucky
-               ;; coincidence, the address of register xxxH is always 
-               ;; one lower than the address of register xxxL.
-               (if (eq isLreg #x1)
-                  (sequence()
-                     (set 16bval (reg h-spr (sub (ifield f-reg) 1)))
-                     (set 16bval (sll 16bval 8))
-                     (set 16bval (or 16bval (and (reg h-spr (ifield f-reg)) #xFF)))
-                     (set 16bval (add HI (and w #xFF) 16bval))
-                     (set (reg h-spr (ifield f-reg)) (and 16bval #xFF))
-                     (set (reg h-spr (sub (ifield f-reg) 1))
-                          (and (srl 16bval 8) #xFF))
-                     (set result (reg h-spr (ifield f-reg)))
-                  )
-	       (set result (addc w fr 0)) ;; else part
-               )
-	       (set zbit (zflag result))
-	       (set fr result))
-     ()
-)
-
-(dni addw_fr "Add W,fr"
-     ()
-     "add W,$fr"
-     (+ OP6_ADD DIR_TO_W fr)
-     (sequence ((QI result))
-	       (set cbit (add-cflag w fr 0))
-	       (set dcbit (add-dcflag w fr 0))
-	       (set result (addc w fr 0))
-	       (set zbit (zflag result))
-	       (set w result))
-     ()
-)
-
-(dni xorfr_w "XOR fr,W"
-     ()
-     "xor $fr,W"
-     (+ OP6_XOR DIR_NOTTO_W fr)
-     (sequence ()
-	       (set fr (xor w fr))
-	       (set zbit (zflag fr)))
-     ()
-)
-
-(dni xorw_fr "XOR W,fr"
-     ()
-     "xor W,$fr"
-     (+ OP6_XOR DIR_TO_W fr)
-     (sequence ()
-	       (set w (xor fr w))
-	       (set zbit (zflag w)))
-     ()
-)
-
-(dni andfr_w "AND fr,W"
-     ()
-     "and $fr,W"
-     (+ OP6_AND DIR_NOTTO_W fr)
-     (sequence ()
-	       (set fr (and w fr))
-	       (set zbit (zflag fr)))
-     ()
-)
-
-(dni andw_fr "AND W,fr"
-     ()
-     "and W,$fr"
-     (+ OP6_AND DIR_TO_W fr)
-     (sequence ()
-	       (set w (and fr w))
-	       (set zbit (zflag w)))
-     ()
-)
-
-(dni orfr_w "OR fr,W"
-     ()
-     "or $fr,W"
-     (+ OP6_OR DIR_NOTTO_W fr)
-     (sequence ()
-	       (set fr (or w fr))
-	       (set zbit (zflag fr)))
-     ()
-)
-
-(dni orw_fr "OR W,fr"
-     ()
-     "or W,$fr"
-     (+ OP6_OR DIR_TO_W fr)
-     (sequence ()
-	       (set w (or fr w))
-	       (set zbit (zflag w)))
-     ()
-)
-
-(dni dec_fr "Decrement fr"
-     ()
-     "dec $fr"
-     (+ OP6_DEC DIR_NOTTO_W fr)
-     (sequence ((QI isLreg) (HI 16bval))
-          (LregCheck isLreg (ifield f-reg))
-          ;; If fr is an Lreg, then we have to do 16-bit arithmetic.
-          ;; We can take advantage of the fact that by a lucky
-          ;; coincidence, the address of register xxxH is always
-          ;; one lower than the address of register xxxL.
-          (if (eq isLreg #x1)
-             (sequence()
-                ; Create the 16 bit value
-                (set 16bval (reg h-spr (sub (ifield f-reg) 1)))
-                (set 16bval (sll 16bval 8))
-                (set 16bval (or 16bval (and (reg h-spr (ifield f-reg)) #xFF)))
-                ; New 16 bit instruction
-		(set 16bval (sub HI 16bval 1))
-                ; Separate the 16 bit values into the H and L regs
-                (set (reg h-spr (ifield f-reg)) (and 16bval #xFF))
-                (set (reg h-spr (sub (ifield f-reg) 1))
-                     (and (srl 16bval 8) #xFF))
-                (set fr (reg h-spr (ifield f-reg)))
-             )
-             ; Original instruction
-	     (set fr (sub fr 1))
-	  )
-	     (set zbit (zflag fr)))
-     ()
-)
-
-(dni decw_fr "Decrement fr into w"
-     ()
-     "dec W,$fr"
-     (+ OP6_DEC DIR_TO_W fr)
-     (sequence ()
-	       (set w (sub fr 1))
-	       (set zbit (zflag w)))
-     ()
-)
-
-(dni subfr_w "Sub fr,W"
-     ()
-     "sub $fr,W"
-     (+ OP6_SUB DIR_NOTTO_W fr)
-     (sequence ((QI result) (QI isLreg) (HI 16bval))
-	       (set cbit (not (sub-cflag fr w 0)))
-	       (set dcbit (not (sub-dcflag fr w 0)))
-               (LregCheck isLreg (ifield f-reg))
-               ;; If fr is an Lreg, then we have to do 16-bit arithmetic.
-               ;; We can take advantage of the fact that by a lucky
-               ;; coincidence, the address of register xxxH is always
-               ;; one lower than the address of register xxxL.
-               (if (eq isLreg #x1)
-                  (sequence()
-                     ; Create the 16 bit value
-                     (set 16bval (reg h-spr (sub (ifield f-reg) 1)))
-                     (set 16bval (sll 16bval 8))
-                     (set 16bval (or 16bval (and (reg h-spr (ifield f-reg)) #xFF)))
-                     ; New 16 bit instruction
-                     (set 16bval (sub HI 16bval (and w #xFF)))
-                     ; Separate the 16 bit values into the H and L regs
-                     (set (reg h-spr (ifield f-reg)) (and 16bval #xFF))
-                     (set (reg h-spr (sub (ifield f-reg) 1))
-                          (and (srl 16bval 8) #xFF))
-                     (set result (reg h-spr (ifield f-reg)))
-                  )
-               ; Original instruction
-	       (set result (subc fr w 0))
-               )
-	       (set zbit (zflag result))
-	       (set fr result))
-     ()
-)
-
-(dni subw_fr "Sub W,fr"
-     ()
-     "sub W,$fr"
-     (+ OP6_SUB DIR_TO_W fr)
-     (sequence ((QI result))
-	       (set cbit (not (sub-cflag fr w 0)))
-	       (set dcbit (not (sub-dcflag fr w 0)))
-	       (set result (subc fr w 0))
-	       (set zbit (zflag result))
-	       (set w result))
-     ()
-)
-
-(dni clr_fr "Clear fr"
-     ()
-     "clr $fr"
-     (+ OP6_OTHER2 (f-dir 1) fr)
-     (sequence ()
-	       (set fr 0)
-	       (set zbit (zflag fr)))
-     ()
-)
-
-(dni cmpw_fr "CMP W,fr"
-     ()
-     "cmp W,$fr"
-     (+ OP6_OTHER2 (f-dir 0) fr)
-     (sequence ()
-	       (set cbit (not (sub-cflag fr w 0)))
-	       (set dcbit (not (sub-dcflag fr w 0)))
-	       (set zbit (zflag (sub w fr))))
-     ()
-)
-
-(dni speed "Set speed"
-     ()
-     "speed #$lit8"
-     (+ (f-op8 1) lit8)
-     (set (reg h-registers #x0E) lit8)
-     ()
-)
-
-(dni ireadi "Insn memory read with increment"
-     ()
-     "ireadi"
-     (+ OP6_OTHER1 (f-op6-10low #x1D))
-     (c-call "do_insn_read")
-     ()
-)
-
-(dni iwritei "Insn memory write with increment"
-     ()
-     "iwritei"
-     (+ OP6_OTHER1 (f-op6-10low #x1C))
-     (c-call "do_insn_write")
-     ()
-)
-
-(dni fread "Flash read"
-     ()
-     "fread"
-     (+ OP6_OTHER1 (f-op6-10low #x1B))
-     (c-call "do_flash_read")
-     ()
-)
-
-(dni fwrite "Flash write"
-     ()
-     "fwrite"
-     (+ OP6_OTHER1 (f-op6-10low #x1A))
-     (c-call "do_flash_write")
-     ()
-)
-
-(dni iread "Insn memory read"
-     ()
-     "iread"
-     (+ OP6_OTHER1 (f-op6-10low #x19))
-     (c-call "do_insn_read")
-     ()
-)
-
-(dni iwrite "Insn memory write"
-     ()
-     "iwrite"
-     (+ OP6_OTHER1 (f-op6-10low #x18))
-     (c-call "do_insn_write")
-     ()
-)
-
-(dni page "Set insn page"
-     (EXT-SKIP-INSN)
-     ;"page $page3"
-     "page $addr16p"
-     ;(+ OP6_OTHER1 (f-op6-7low #x2) page3)
-     ;(set pabits (srl page3 13))
-     (+ OP6_OTHER1 (f-op6-7low #x2) addr16p)
-     (set pabits addr16p)
-     ()
-)
-
-(dni system "System call"
-     ()
-     "system"
-     (+ OP6_OTHER1 (f-op6-10low #xff))
-     (c-call "do_system")
-     ()
-)
-
-(dni reti "Return from interrupt"
-     ()
-     "reti #$reti3"
-     (+ OP6_OTHER1 (f-op6-7low #x1) reti3)
-     (c-call "do_reti" reti3)
-     ()
-)
-
-(dni ret "Return"
-     ()
-     "ret"
-     (+ OP6_OTHER1 (f-op6-10low #x07))
-     (sequence ((USI new_pc))
-	       (set new_pc (c-call UHI "pop_pc_stack"))
-	       (set pabits (srl new_pc 13))
-	       (set pc new_pc))
-     ()
-)
-
-(dni int "Software interrupt"
-     ()
-     "int"
-     (+ OP6_OTHER1 (f-op6-10low #x6))
-     (nop)
-     ()
-)
-
-(dni breakx "Breakpoint with extended skip"
-     (EXT-SKIP-INSN)
-     "breakx"
-     (+ OP6_OTHER1 (f-op6-10low #x5))
-     (c-call "do_break" pc)
-     ()
-)
-
-(dni cwdt "Clear watchdog timer"
-     ()
-     "cwdt"
-     (+ OP6_OTHER1 (f-op6-10low #x4))
-     (c-call "do_clear_wdt")
-     ()
-)
-
-(dni ferase "Flash erase"
-     ()
-     "ferase"
-     (+ OP6_OTHER1 (f-op6-10low #x3))
-     (c-call "do_flash_erase")
-     ()
-)
-
-(dni retnp "Return, no page"
-     ()
-     "retnp"
-     (+ OP6_OTHER1 (f-op6-10low #x2))
-     (sequence ((USI new_pc))
-	       (set new_pc (c-call UHI "pop_pc_stack"))
-	       (set pc new_pc))
-     ()
-)
-
-(dni break "Breakpoint"
-     ()
-     "break"
-     (+ OP6_OTHER1 (f-op6-10low #x1))
-     (c-call "do_break" pc)
-     ()
-)
-
-(dni nop "No operation"
-     ()
-     "nop"
-     (+ OP6_OTHER1 (f-op6-10low #x0))
-     (nop)
-     ()
-)
-			   
-
-; Macro instructions
-(dnmi sc "Skip on carry"
-      ()
-      "sc"
-      (emit sb (bitno 0) (fr #xB)) ; sb status.0
-)
-
-(dnmi snc "Skip on no carry"
-      ()
-      "snc"
-      (emit snb (bitno 0) (fr #xB)) ; snb status.0
-)
-      
-(dnmi sz "Skip on zero"
-      ()
-      "sz"
-      (emit sb (bitno 2) (fr #xB)) ; sb status.2
-)
-
-(dnmi snz "Skip on no zero"
-      ()
-      "snz"
-      (emit snb (bitno 2) (fr #xB)) ; snb status.2
-)
-
-(dnmi skip "Skip always"
-      (SKIPA)
-      "skip"
-      (emit snb (bitno 0) (fr 9)) ; snb pcl.0 | (pcl&1)<<12
-)
-
-(dnmi skipb "Skip always"
-      (SKIPA)
-      "skip"
-      (emit sb (bitno 0) (fr 9)) ; sb pcl.0 | (pcl&1)<<12
-)
-
diff -rupN binutils-2.19.1-original/cgen/cpu/ip2k.opc binutils-2.19.1/cgen/cpu/ip2k.opc
--- binutils-2.19.1-original/cgen/cpu/ip2k.opc	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/ip2k.opc	1969-12-31 19:00:00.000000000 -0500
@@ -1,634 +0,0 @@
-
-/* -*- C -*-
-   Copyright 2011 Free Software Foundation, Inc.
-
-   Contributed by Red Hat Inc;
-
-   This file is part of the GNU Binutils.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-/*
-   Each section is delimited with start and end markers.
-
-   <arch>-opc.h additions use: "-- opc.h"
-   <arch>-opc.c additions use: "-- opc.c"
-   <arch>-asm.c additions use: "-- asm.c"
-   <arch>-dis.c additions use: "-- dis.c"
-   <arch>-ibd.h additions use: "-- ibd.h".  */
-
-/* -- opc.h */
-
-/* Check applicability of instructions against machines.  */
-#define CGEN_VALIDATE_INSN_SUPPORTED
-
-/* Allows reason codes to be output when assembler errors occur.  */
-#define CGEN_VERBOSE_ASSEMBLER_ERRORS
-
-/* Override disassembly hashing - there are variable bits in the top
-   byte of these instructions.  */
-#define CGEN_DIS_HASH_SIZE 8
-#define CGEN_DIS_HASH(buf, value) \
-  (((* (unsigned char*) (buf)) >> 5) % CGEN_DIS_HASH_SIZE)
-
-#define CGEN_ASM_HASH_SIZE 127
-#define CGEN_ASM_HASH(insn) ip2k_asm_hash (insn)
-
-extern unsigned int ip2k_asm_hash (const char *);
-extern int ip2k_cgen_insn_supported (CGEN_CPU_DESC, const CGEN_INSN *);
-
-/* -- opc.c */
-
-#include "safe-ctype.h"
-
-/* A better hash function for instruction mnemonics.  */
-unsigned int
-ip2k_asm_hash (const char* insn)
-{
-  unsigned int hash;
-  const char* m = insn;
-
-  for (hash = 0; *m && ! ISSPACE (*m); m++)
-    hash = (hash * 23) ^ (0x1F & TOLOWER (*m));
-
-  /* printf ("%s %d\n", insn, (hash % CGEN_ASM_HASH_SIZE)); */
-
-  return hash % CGEN_ASM_HASH_SIZE;
-}
-
-
-/* Special check to ensure that instruction exists for given machine.  */
-
-int
-ip2k_cgen_insn_supported (CGEN_CPU_DESC cd, const CGEN_INSN *insn)
-{
-  int machs = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_MACH);
-
-  /* No mach attribute?  Assume it's supported for all machs.  */
-  if (machs == 0)
-    return 1;
-  
-  return (machs & cd->machs) != 0;
-}
-
-
-/* -- asm.c */
-
-static const char *
-parse_fr (CGEN_CPU_DESC cd,
-	  const char **strp,
-	  int opindex,
-	  unsigned long *valuep)
-{
-  const char *errmsg;
-  const char *old_strp;
-  char *afteroffset; 
-  enum cgen_parse_operand_result result_type;
-  bfd_vma value;
-  extern CGEN_KEYWORD ip2k_cgen_opval_register_names;
-  bfd_vma tempvalue;
-
-  old_strp = *strp;
-  afteroffset = NULL;
-
-  /* Check here to see if you're about to try parsing a w as the first arg
-     and return an error if you are.  */
-  if ((strncmp (*strp, "w", 1) == 0) || (strncmp (*strp, "W", 1) == 0))
-    {
-      (*strp)++;
-
-      if ((strncmp (*strp, ",", 1) == 0) || ISSPACE (**strp))
-	{
-	  /* We've been passed a w.  Return with an error message so that
-	     cgen will try the next parsing option.  */
-	  errmsg = _("W keyword invalid in FR operand slot.");
-	  return errmsg;
-	}
-      *strp = old_strp;
-    }
-
-  /* Attempt parse as register keyword. */
-  errmsg = cgen_parse_keyword (cd, strp, & ip2k_cgen_opval_register_names,
-			       (long *) valuep);
-  if (*strp != NULL
-      && errmsg == NULL)
-    return errmsg;
-
-  /* Attempt to parse for "(IP)".  */
-  afteroffset = strstr (*strp, "(IP)");
-
-  if (afteroffset == NULL)
-    /* Make sure it's not in lower case.  */
-    afteroffset = strstr (*strp, "(ip)");
-
-  if (afteroffset != NULL)
-    {
-      if (afteroffset != *strp)
-	{
-	  /* Invalid offset present.  */
-	  errmsg = _("offset(IP) is not a valid form");
-	  return errmsg;
-	}
-      else
-	{
-	  *strp += 4; 
-	  *valuep = 0;
-	  errmsg = NULL;
-	  return errmsg;
-	}
-    }
-
-  /* Attempt to parse for DP. ex: mov w, offset(DP)
-                                  mov offset(DP),w   */
-
-  /* Try parsing it as an address and see what comes back.  */
-  afteroffset = strstr (*strp, "(DP)");
-
-  if (afteroffset == NULL)
-    /* Maybe it's in lower case.  */
-    afteroffset = strstr (*strp, "(dp)");
-
-  if (afteroffset != NULL)
-    {
-      if (afteroffset == *strp)
-	{
-	  /* No offset present. Use 0 by default.  */
-	  tempvalue = 0;
-	  errmsg = NULL;
-	}
-      else
-	errmsg = cgen_parse_address (cd, strp, opindex,
-				     BFD_RELOC_IP2K_FR_OFFSET,
-				     & result_type, & tempvalue);
-
-      if (errmsg == NULL)
-	{
-	  if (tempvalue <= 127)
-	    {
-	      /* Value is ok.  Fix up the first 2 bits and return.  */
-	      *valuep = 0x0100 | tempvalue;
-	      *strp += 4; /* Skip over the (DP) in *strp.  */
-	      return errmsg;
-	    }
-	  else
-	    {
-	      /* Found something there in front of (DP) but it's out
-		 of range.  */
-	      errmsg = _("(DP) offset out of range.");
-	      return errmsg;
-	    }
-	}
-    }
-
-
-  /* Attempt to parse for SP. ex: mov w, offset(SP)
-                                  mov offset(SP), w.  */
-  afteroffset = strstr (*strp, "(SP)");
-
-  if (afteroffset == NULL)
-    /* Maybe it's in lower case.  */
-    afteroffset = strstr (*strp, "(sp)");
-
-  if (afteroffset != NULL)
-    {
-      if (afteroffset == *strp)
-	{
-	  /* No offset present. Use 0 by default.  */
-	  tempvalue = 0;
-	  errmsg = NULL;
-	}
-      else
-	errmsg = cgen_parse_address (cd, strp, opindex,
-				     BFD_RELOC_IP2K_FR_OFFSET,
-				     & result_type, & tempvalue);
-
-      if (errmsg == NULL)
-	{
-	  if (tempvalue <= 127)
-	    {
-	      /* Value is ok.  Fix up the first 2 bits and return.  */
-	      *valuep = 0x0180 | tempvalue;
-	      *strp += 4; /* Skip over the (SP) in *strp.  */
-	      return errmsg;
-	    }
-	  else
-	    {
-	      /* Found something there in front of (SP) but it's out
-		 of range.  */
-	      errmsg = _("(SP) offset out of range.");
-	      return errmsg;
-	    }
-	}
-    }
-
-  /* Attempt to parse as an address.  */
-  *strp = old_strp;
-  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_IP2K_FR9,
-			       & result_type, & value);
-  if (errmsg == NULL)
-    {
-      *valuep = value;
-
-      /* If a parenthesis is found, warn about invalid form.  */
-      if (**strp == '(')
-	errmsg = _("illegal use of parentheses");
-
-      /* If a numeric value is specified, ensure that it is between
-	 1 and 255.  */
-      else if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
-	{
-	  if (value < 0x1 || value > 0xff)
-	    errmsg = _("operand out of range (not between 1 and 255)");
-	}
-    }
-  return errmsg;
-}
-
-static const char *
-parse_addr16 (CGEN_CPU_DESC cd,
-	      const char **strp,
-	      int opindex,
-	      unsigned long *valuep)
-{
-  const char *errmsg;
-  enum cgen_parse_operand_result result_type;
-  bfd_reloc_code_real_type code = BFD_RELOC_NONE;
-  bfd_vma value;
-
-  if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16H)
-    code = BFD_RELOC_IP2K_HI8DATA;
-  else if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16L)
-    code = BFD_RELOC_IP2K_LO8DATA;
-  else
-    {
-      /* Something is very wrong. opindex has to be one of the above.  */
-      errmsg = _("parse_addr16: invalid opindex.");
-      return errmsg;
-    }
-  
-  errmsg = cgen_parse_address (cd, strp, opindex, code,
-			       & result_type, & value);
-  if (errmsg == NULL)
-    {
-      /* We either have a relocation or a number now.  */
-      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
-	{
-	  /* We got a number back.  */
-	  if (code == BFD_RELOC_IP2K_HI8DATA)
-            value >>= 8;
-	  else
-	    /* code = BFD_RELOC_IP2K_LOW8DATA.  */
-	    value &= 0x00FF;
-	}   
-      *valuep = value;
-    }
-
-  return errmsg;
-}
-
-static const char *
-parse_addr16_cjp (CGEN_CPU_DESC cd,
-		  const char **strp,
-		  int opindex,
-		  unsigned long *valuep)
-{
-  const char *errmsg;
-  enum cgen_parse_operand_result result_type;
-  bfd_reloc_code_real_type code = BFD_RELOC_NONE;
-  bfd_vma value;
- 
-  if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16CJP)
-    code = BFD_RELOC_IP2K_ADDR16CJP;
-  else if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16P)
-    code = BFD_RELOC_IP2K_PAGE3;
-
-  errmsg = cgen_parse_address (cd, strp, opindex, code,
-			       & result_type, & value);
-  if (errmsg == NULL)
-    {
-      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
-	{
-	  if ((value & 0x1) == 0)  /* If the address is even .... */
-	    {
-	      if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16CJP)
-                *valuep = (value >> 1) & 0x1FFF;  /* Should mask be 1FFF?  */
-	      else if (opindex == (CGEN_OPERAND_TYPE) IP2K_OPERAND_ADDR16P)
-                *valuep = (value >> 14) & 0x7;
-	    }
-          else
- 	    errmsg = _("Byte address required. - must be even.");
-	}
-      else if (result_type == CGEN_PARSE_OPERAND_RESULT_QUEUED)
-	{
-	  /* This will happen for things like (s2-s1) where s2 and s1
-	     are labels.  */
-	  *valuep = value;
-	}
-      else 
-        errmsg = _("cgen_parse_address returned a symbol. Literal required.");
-    }
-  return errmsg; 
-}
-
-static const char *
-parse_lit8 (CGEN_CPU_DESC cd,
-	    const char **strp,
-	    int opindex,
-	    long *valuep)
-{
-  const char *errmsg;
-  enum cgen_parse_operand_result result_type;
-  bfd_reloc_code_real_type code = BFD_RELOC_NONE;
-  bfd_vma value;
-
-  /* Parse %OP relocating operators.  */
-  if (strncmp (*strp, "%bank", 5) == 0)
-    {
-      *strp += 5;
-      code = BFD_RELOC_IP2K_BANK;
-    }
-  else if (strncmp (*strp, "%lo8data", 8) == 0)
-    {
-      *strp += 8;
-      code = BFD_RELOC_IP2K_LO8DATA;
-    }
-  else if (strncmp (*strp, "%hi8data", 8) == 0)
-    {
-      *strp += 8;
-      code = BFD_RELOC_IP2K_HI8DATA;
-    }
-  else if (strncmp (*strp, "%ex8data", 8) == 0)
-    {
-      *strp += 8;
-      code = BFD_RELOC_IP2K_EX8DATA;
-    }
-  else if (strncmp (*strp, "%lo8insn", 8) == 0)
-    {
-      *strp += 8;
-      code = BFD_RELOC_IP2K_LO8INSN;
-    }
-  else if (strncmp (*strp, "%hi8insn", 8) == 0)
-    {
-      *strp += 8;
-      code = BFD_RELOC_IP2K_HI8INSN;
-    }
-
-  /* Parse %op operand.  */
-  if (code != BFD_RELOC_NONE)
-    {
-      errmsg = cgen_parse_address (cd, strp, opindex, code, 
-				   & result_type, & value);
-      if ((errmsg == NULL) &&
-	  (result_type != CGEN_PARSE_OPERAND_RESULT_QUEUED))
-	errmsg = _("percent-operator operand is not a symbol");
-
-      *valuep = value;
-    }
-  /* Parse as a number.  */
-  else
-    {
-      errmsg = cgen_parse_signed_integer (cd, strp, opindex, valuep);
-
-      /* Truncate to eight bits to accept both signed and unsigned input.  */
-      if (errmsg == NULL)
-	*valuep &= 0xFF;
-    }
-
-  return errmsg;
-}
-
-static const char *
-parse_bit3 (CGEN_CPU_DESC cd,
-	    const char **strp,
-	    int opindex,
-	    unsigned long *valuep)
-{
-  const char *errmsg;
-  char mode = 0;
-  long count = 0;
-  unsigned long value;
-
-  if (strncmp (*strp, "%bit", 4) == 0)
-    {
-      *strp += 4;
-      mode = 1;
-    }
-  else if (strncmp (*strp, "%msbbit", 7) == 0)
-    {
-      *strp += 7;
-      mode = 1;
-    }
-  else if (strncmp (*strp, "%lsbbit", 7) == 0)
-    {
-      *strp += 7;
-      mode = 2;
-    }
-
-  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
-  if (errmsg)
-    return errmsg;
-
-  if (mode)
-    {
-      value = * valuep;
-      if (value == 0)
-	{
-	  errmsg = _("Attempt to find bit index of 0");
-	  return errmsg;
-	}
-    
-      if (mode == 1)
-	{
-	  count = 31;
-	  while ((value & 0x80000000) == 0)
-	    {
-	      count--;
-	      value <<= 1;
-	    }
-	}
-      else if (mode == 2)
-	{
-	  count = 0;
-	  while ((value & 0x00000001) == 0)
-	    {
-	      count++;
-	      value >>= 1;
-	    }
-	}
-    
-      *valuep = count;
-    }
-
-  return errmsg;
-}
-
-/* -- dis.c */
-
-static void
-print_fr (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	  void * dis_info,
-	  long value,
-	  unsigned int attrs ATTRIBUTE_UNUSED,
-	  bfd_vma pc ATTRIBUTE_UNUSED,
-	  int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-  const CGEN_KEYWORD_ENTRY *ke;
-  extern CGEN_KEYWORD ip2k_cgen_opval_register_names;
-  long offsettest;
-  long offsetvalue;
-
-  if (value == 0) /* This is (IP).  */
-    {
-      (*info->fprintf_func) (info->stream, "%s", "(IP)");
-      return;
-    }
-
-  offsettest = value >> 7;
-  offsetvalue = value & 0x7F;
-
-  /* Check to see if first two bits are 10 -> (DP).  */
-  if (offsettest == 2)
-    {
-      if (offsetvalue == 0)
-	(*info->fprintf_func) (info->stream, "%s","(DP)");
-      else
-	(*info->fprintf_func) (info->stream, "$%lx%s", offsetvalue, "(DP)");
-      return;
-    }
-
-  /* Check to see if first two bits are 11 -> (SP).  */
-  if (offsettest == 3)
-    {
-      if (offsetvalue == 0)
-	(*info->fprintf_func) (info->stream, "%s", "(SP)");
-      else
-	(*info->fprintf_func) (info->stream, "$%lx%s", offsetvalue,"(SP)");
-      return;
-    }
-
-  /* Attempt to print as a register keyword.  */
-  ke = cgen_keyword_lookup_value (& ip2k_cgen_opval_register_names, value);
-
-  if (ke != NULL)
-    (*info->fprintf_func) (info->stream, "%s", ke->name);
-  else
-    /* Print as an address literal.  */
-    (*info->fprintf_func) (info->stream, "$%02lx", value);
-}
-
-static void
-print_dollarhex (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-		 void * dis_info,
-		 long value,
-		 unsigned int attrs ATTRIBUTE_UNUSED,
-		 bfd_vma pc ATTRIBUTE_UNUSED,
-		 int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  (*info->fprintf_func) (info->stream, "$%lx", value);
-}
-
-static void
-print_dollarhex8 (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-		  void * dis_info,
-		  long value,
-		  unsigned int attrs ATTRIBUTE_UNUSED,
-		  bfd_vma pc ATTRIBUTE_UNUSED,
-		  int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  (*info->fprintf_func) (info->stream, "$%02lx", value);
-}
-
-static void
-print_dollarhex_addr16h (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-			 void * dis_info,
-			 long value,
-			 unsigned int attrs ATTRIBUTE_UNUSED,
-			 bfd_vma pc ATTRIBUTE_UNUSED,
-			 int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  /* This is a loadh instruction. Shift the value to the left
-     by 8 bits so that disassembled code will reassemble properly.  */
-  value = ((value << 8) & 0xFF00);
-
-  (*info->fprintf_func) (info->stream, "$%04lx", value);
-}
-
-static void
-print_dollarhex_addr16l (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-			 void * dis_info,
-			 long value,
-			 unsigned int attrs ATTRIBUTE_UNUSED,
-			 bfd_vma pc ATTRIBUTE_UNUSED,
-			 int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  (*info->fprintf_func) (info->stream, "$%04lx", value);
-}
-
-static void
-print_dollarhex_p (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-		   void * dis_info,
-		   long value,
-		   unsigned int attrs ATTRIBUTE_UNUSED,
-		   bfd_vma pc ATTRIBUTE_UNUSED,
-		   int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  value = ((value << 14) & 0x1C000);
-  ;value = (value  & 0x1FFFF);
-  (*info->fprintf_func) (info->stream, "$%05lx", value);
-}
-
-static void
-print_dollarhex_cj (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-		    void * dis_info,
-		    long value,
-		    unsigned int attrs ATTRIBUTE_UNUSED,
-		    bfd_vma pc ATTRIBUTE_UNUSED,
-		    int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  value = ((value << 1) & 0x1FFFF);
-  (*info->fprintf_func) (info->stream, "$%05lx", value);
-}
-
-static void
-print_decimal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	       void * dis_info,
-	       long value,
-	       unsigned int attrs ATTRIBUTE_UNUSED,
-	       bfd_vma pc ATTRIBUTE_UNUSED,
-	       int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  (*info->fprintf_func) (info->stream, "%ld", value);
-}
-
-
-
-/* -- */
-
diff -rupN binutils-2.19.1-original/cgen/cpu/mep-avc2.cpu binutils-2.19.1/cgen/cpu/mep-avc2.cpu
--- binutils-2.19.1-original/cgen/cpu/mep-avc2.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/mep-avc2.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,1988 +0,0 @@
-;
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-; This file was customized based upon the output of a2cgen 0.42
-
-;------------------------------------------------------------------------------
-; MeP-Integrator will redefine the isa pmacros below to allow the bit widths
-; specified below for each ME_MODULE using this coprocessor.
-; This coprocessor requires 16 and 32 bit insns.
-;------------------------------------------------------------------------------
-; begin-isas
-(define-pmacro avc2-core-isa () (ISA ext_core1))
-(define-pmacro avc2-16-isa   () (ISA ext_cop1_16))
-(define-pmacro avc2-32-isa   () (ISA ext_cop1_32))
-(define-pmacro all-avc2-isas () (ISA ext_core1,ext_cop1_16,ext_cop1_32))
-; end-isas
-
-(define-pmacro (dncpi xname xcomment xattrs xsyntax xformat xsemantics xtiming)
-   (dni xname xcomment (.splice (.unsplice xattrs) avc2-core-isa) xsyntax xformat xsemantics xtiming))
-(define-pmacro (dn16i xname xcomment xattrs xsyntax xformat xsemantics xtiming)
-   (dni xname xcomment (.splice (.unsplice xattrs) avc2-16-isa) xsyntax xformat xsemantics xtiming))
-(define-pmacro (dn32i xname xcomment xattrs xsyntax xformat xsemantics xtiming)
-   (dni xname xcomment (.splice (.unsplice xattrs) avc2-32-isa) xsyntax xformat xsemantics xtiming))
-
-; register definitions
-; ---------------------
-; NOTE: This exists solely for the purpose of providing the proper register names for this coprocessor.
-; GDB will use the hardware table generated from this declaration. The operands use h-cr
-; from mep-core.cpu so that SID's semantic trace will be consistent between
-; the core and the coprocessor but use parse/print handlers which reference the hardware table
-; generated from this declarations
-(define-hardware
-  (name h-cr-avc2)
-  (comment "32-bit coprocessor registers for avc2 coprocessor")
-  (attrs VIRTUAL all-avc2-isas)
-  (type register SI (32))
-  (set (index newval) (c-call VOID "h_cr64_set" index (ext DI newval)))
-  (get (index) (trunc SI (c-call DI "h_cr64_get" index)))
-  (indices keyword "$c" (.map -reg-pair (.iota 8)))
-)
-; NOTE: This exists solely for the purpose of providing the proper register names for this coprocessor.
-; GDB will use the hardware table generated from this declaration. The operands use h-ccr
-; from mep-core.cpu so that SID's semantic trace will be consistent between
-; the core and the coprocessor but use parse/print handlers which reference the hardware table
-; generated from this declarations
-(define-hardware
-  (name h-ccr-avc2)
-  (comment "Coprocessor control registers for avc2 coprocessor")
-  (attrs VIRTUAL all-avc2-isas)
-  (type register SI (64))
-  (set (index newval) (c-call VOID "h_ccr_set" index newval))
-  (get (index) (c-call SI "h_ccr_get" index))
-  (indices keyword ""
-	(.splice
-        ($accl1 5) ($acch1 4) ($accl0 3) ($acch0 2) ($CBCR 1) ($csar 0) 
-        ($cbcr 1) 
-		(.unsplice (.map -ccr-reg-pair (.iota 6)))
-        )
-  )
-)
-(dnop avc2copCCR5 "Audio Copro Accumulator" (all-avc2-isas) h-ccr 5)
-(dnop avc2copCCR4 "Audio Copro Accumulator" (all-avc2-isas) h-ccr 4)
-(dnop avc2copCCR3 "Audio Copro Accumulator" (all-avc2-isas) h-ccr 3)
-(dnop avc2copCCR2 "Audio Copro Accumulator" (all-avc2-isas) h-ccr 2)
-(dnop avc2copCCR1 "Audio Copro Branch Condition Register" (all-avc2-isas) h-ccr 1)
-(dnop avc2copCCR0 "Audio Copro Shift-Amount Register" (all-avc2-isas) h-ccr 0)
-
-; instruction field and operand definitions
-(dnf f-avc2-v3sub4u0 "sub opecode field" (avc2-32-isa) 0 4)
-(dnf f-avc2-v1sub4u0 "sub opecode field" (avc2-16-isa) 0 4)
-(dnf f-avc2-v3Rn "register field" (avc2-32-isa) 4 4)
-(dnop avc2v3Rn "the operand definition" (avc2-32-isa) h-gpr f-avc2-v3Rn)
-(dnf f-avc2-v3CCRn "register field" (avc2-32-isa) 4 4)
-(define-full-operand avc2v3CCRn "the operand definition" (avc2-32-isa (CDATA REGNUM)) h-ccr DFLT f-avc2-v3CCRn ((parse "avc2_ccr") (print "avc2_ccr")) () ())
-(df f-avc2-v3Imm16s4x24e32-hi "split immediate field hi" (avc2-32-isa) 4 8 INT #f #f)
-(df f-avc2-v3Imm16s4x24e32-lo "split immediate field lo" (avc2-32-isa) 24 8 UINT #f #f)
-(define-multi-ifield
- (name f-avc2-v3Imm16s4x24e32)
- (comment "split immediate field")
- (attrs avc2-32-isa)
- (mode INT)
- (subfields f-avc2-v3Imm16s4x24e32-hi f-avc2-v3Imm16s4x24e32-lo)
- (insert (sequence ()
-    (set (ifield f-avc2-v3Imm16s4x24e32-hi) (sra INT (ifield f-avc2-v3Imm16s4x24e32) 8))
-    (set (ifield f-avc2-v3Imm16s4x24e32-lo) (and (ifield f-avc2-v3Imm16s4x24e32) #xff))))
- (extract (set (ifield f-avc2-v3Imm16s4x24e32)
-    (or (sll (ifield f-avc2-v3Imm16s4x24e32-hi) 8) (ifield f-avc2-v3Imm16s4x24e32-lo))))
- )
-(dnop avc2v3Imm16s4x24e32 "the operand definition" (avc2-32-isa) h-sint f-avc2-v3Imm16s4x24e32)
-(dnf f-avc2-v3CRn "register field" (avc2-32-isa) 4 4)
-(define-full-operand avc2v3CRn "the operand definition" (avc2-32-isa) h-cr DFLT f-avc2-v3CRn ((parse "avc2_cr") (print "avc2_cr")) () ())
-(dnf f-avc2-v1CRq "register field" (avc2-16-isa) 4 4)
-(define-full-operand avc2v1CRq "the operand definition" (avc2-16-isa) h-cr DFLT f-avc2-v1CRq ((parse "avc2_cr") (print "avc2_cr")) () ())
-(dnf f-avc2-v1sub4u4 "sub opecode field" (avc2-16-isa) 4 4)
-(dnf f-avc2-c3Rn "register field" (avc2-core-isa) 4 4)
-(dnop avc2c3Rn "the operand definition" (avc2-core-isa) h-gpr f-avc2-c3Rn)
-(dnf f-avc2-c3CCRn "register field" (avc2-core-isa) 4 4)
-(define-full-operand avc2c3CCRn "the operand definition" (avc2-core-isa (CDATA REGNUM)) h-ccr DFLT f-avc2-c3CCRn ((parse "avc2_ccr") (print "avc2_ccr")) () ())
-(df f-avc2-c3Imm16s4x24e32-hi "split immediate field hi" (avc2-core-isa) 4 8 INT #f #f)
-(df f-avc2-c3Imm16s4x24e32-lo "split immediate field lo" (avc2-core-isa) 24 8 UINT #f #f)
-(define-multi-ifield
- (name f-avc2-c3Imm16s4x24e32)
- (comment "split immediate field")
- (attrs avc2-core-isa)
- (mode INT)
- (subfields f-avc2-c3Imm16s4x24e32-hi f-avc2-c3Imm16s4x24e32-lo)
- (insert (sequence ()
-    (set (ifield f-avc2-c3Imm16s4x24e32-hi) (sra INT (ifield f-avc2-c3Imm16s4x24e32) 8))
-    (set (ifield f-avc2-c3Imm16s4x24e32-lo) (and (ifield f-avc2-c3Imm16s4x24e32) #xff))))
- (extract (set (ifield f-avc2-c3Imm16s4x24e32)
-    (or (sll (ifield f-avc2-c3Imm16s4x24e32-hi) 8) (ifield f-avc2-c3Imm16s4x24e32-lo))))
- )
-(dnop avc2c3Imm16s4x24e32 "the operand definition" (avc2-core-isa) h-sint f-avc2-c3Imm16s4x24e32)
-(dnf f-avc2-c3CRn "register field" (avc2-core-isa) 4 4)
-(define-full-operand avc2c3CRn "the operand definition" (avc2-core-isa) h-cr DFLT f-avc2-c3CRn ((parse "avc2_cr") (print "avc2_cr")) () ())
-(dnf f-avc2-c3sub4u4 "sub opecode field" (avc2-core-isa) 4 4)
-(dnf f-avc2-v3Rm "register field" (avc2-32-isa) 8 4)
-(dnop avc2v3Rm "the operand definition" (avc2-32-isa) h-gpr f-avc2-v3Rm)
-(df f-avc2-v1Imm6u8 "immediate field" (avc2-16-isa) 8 6 UINT #f #f)
-(dnop avc2v1Imm6u8 "the operand definition" (avc2-16-isa) h-uint f-avc2-v1Imm6u8)
-(df f-avc2-v1Imm5u8 "immediate field" (avc2-16-isa) 8 5 UINT #f #f)
-(dnop avc2v1Imm5u8 "the operand definition" (avc2-16-isa) h-uint f-avc2-v1Imm5u8)
-(df f-avc2-v1Imm6s8 "immediate field" (avc2-16-isa) 8 6 INT #f #f)
-(dnop avc2v1Imm6s8 "the operand definition" (avc2-16-isa) h-sint f-avc2-v1Imm6s8)
-(df f-avc2-v1Imm8s8 "immediate field" (avc2-16-isa) 8 8 INT #f #f)
-(dnop avc2v1Imm8s8 "the operand definition" (avc2-16-isa) h-sint f-avc2-v1Imm8s8)
-(dnf f-avc2-v1CRp "register field" (avc2-16-isa) 8 4)
-(define-full-operand avc2v1CRp "the operand definition" (avc2-16-isa) h-cr DFLT f-avc2-v1CRp ((parse "avc2_cr") (print "avc2_cr")) () ())
-(dnf f-avc2-v1sub4u8 "sub opecode field" (avc2-16-isa) 8 4)
-(dnf f-avc2-c3Rm "register field" (avc2-core-isa) 8 4)
-(dnop avc2c3Rm "the operand definition" (avc2-core-isa) h-gpr f-avc2-c3Rm)
-(dnf f-avc2-c3sub4u8 "sub opecode field" (avc2-core-isa) 8 4)
-(dnf f-avc2-v3sub4u12 "sub opecode field" (avc2-32-isa) 12 4)
-(dnf f-avc2-v1CRo "register field" (avc2-16-isa) 12 4)
-(define-full-operand avc2v1CRo "the operand definition" (avc2-16-isa) h-cr DFLT f-avc2-v1CRo ((parse "avc2_cr") (print "avc2_cr")) () ())
-(dnf f-avc2-v1sub4u12 "sub opecode field" (avc2-16-isa) 12 4)
-(dnf f-avc2-v1sub3u13 "sub opecode field" (avc2-16-isa) 13 3)
-(dnf f-avc2-v1sub2u14 "sub opecode field" (avc2-16-isa) 14 2)
-(dnf f-avc2-v3sub4u16 "sub opecode field" (avc2-32-isa) 16 4)
-(dnf f-avc2-c3sub4u16 "sub opecode field" (avc2-core-isa) 16 4)
-(dnf f-avc2-v3CRq "register field" (avc2-32-isa) 20 4)
-(define-full-operand avc2v3CRq "the operand definition" (avc2-32-isa) h-cr DFLT f-avc2-v3CRq ((parse "avc2_cr") (print "avc2_cr")) () ())
-(dnf f-avc2-v3sub4u20 "sub opecode field" (avc2-32-isa) 20 4)
-(dnf f-avc2-c3CRq "register field" (avc2-core-isa) 20 4)
-(define-full-operand avc2c3CRq "the operand definition" (avc2-core-isa) h-cr DFLT f-avc2-c3CRq ((parse "avc2_cr") (print "avc2_cr")) () ())
-(dnf f-avc2-c3sub4u20 "sub opecode field" (avc2-core-isa) 20 4)
-(dnf f-avc2-v3sub4u24 "sub opecode field" (avc2-32-isa) 24 4)
-(df f-avc2-c3Imm6u24 "immediate field" (avc2-core-isa) 24 6 UINT #f #f)
-(dnop avc2c3Imm6u24 "the operand definition" (avc2-core-isa) h-uint f-avc2-c3Imm6u24)
-(df f-avc2-c3Imm5u24 "immediate field" (avc2-core-isa) 24 5 UINT #f #f)
-(dnop avc2c3Imm5u24 "the operand definition" (avc2-core-isa) h-uint f-avc2-c3Imm5u24)
-(df f-avc2-c3Imm6s24 "immediate field" (avc2-core-isa) 24 6 INT #f #f)
-(dnop avc2c3Imm6s24 "the operand definition" (avc2-core-isa) h-sint f-avc2-c3Imm6s24)
-(dnf f-avc2-c3CRp "register field" (avc2-core-isa) 24 4)
-(define-full-operand avc2c3CRp "the operand definition" (avc2-core-isa) h-cr DFLT f-avc2-c3CRp ((parse "avc2_cr") (print "avc2_cr")) () ())
-(dnf f-avc2-c3sub4u24 "sub opecode field" (avc2-core-isa) 24 4)
-(dnf f-avc2-v3sub4u28 "sub opecode field" (avc2-32-isa) 28 4)
-(dnf f-avc2-c3CRo "register field" (avc2-core-isa) 28 4)
-(define-full-operand avc2c3CRo "the operand definition" (avc2-core-isa) h-cr DFLT f-avc2-c3CRo ((parse "avc2_cr") (print "avc2_cr")) () ())
-(dnf f-avc2-c3sub4u28 "sub opecode field" (avc2-core-isa) 28 4)
-(dnf f-avc2-c3sub3u29 "sub opecode field" (avc2-core-isa) 29 3)
-(dnf f-avc2-c3sub2u30 "sub opecode field" (avc2-core-isa) 30 2)
-
-; instruction definitions
-(dncpi cnop_avc2_c3 "cnop" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cnop"))
- "cnop"
-(+ MAJ_15 (f-sub4 7) (f-avc2-c3sub4u28 #x0) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(c-call "check_option_cp" pc)
- ())
-(dncpi cmov1_avc2_c3 "cmov1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmov1"))
- "cmov $avc2c3CRn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3CRn avc2c3Rm (f-avc2-c3sub4u28 #x0) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRn avc2c3Rm)
-)
- ())
-(dncpi cmov2_avc2_c3 "cmov2" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmov2"))
- "cmov $avc2c3Rm,$avc2c3CRn"
-(+ MAJ_15 (f-sub4 7) avc2c3Rm avc2c3CRn (f-avc2-c3sub4u28 #x1) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3Rm avc2c3CRn)
-)
- ())
-(dncpi cmovi_avc2_c3 "cmovi" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmovi"))
- "cmovi $avc2c3CRq,$avc2c3Imm16s4x24e32"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3Imm16s4x24e32 (f-avc2-c3sub4u16 #xe))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (ext SI avc2c3Imm16s4x24e32))
-)
- ())
-(dncpi cmovc1_avc2_c3 "cmovc1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmovc1"))
- "cmovc $avc2c3CCRn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3CCRn avc2c3Rm (f-avc2-c3sub4u28 #x2) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CCRn avc2c3Rm)
-)
- ())
-(dncpi cmovc2_avc2_c3 "cmovc2" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmovc2"))
- "cmovc $avc2c3Rm,$avc2c3CCRn"
-(+ MAJ_15 (f-sub4 7) avc2c3Rm avc2c3CCRn (f-avc2-c3sub4u28 #x3) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3Rm avc2c3CCRn)
-)
- ())
-(dncpi cmov_avc2_c3 "cmov" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmov"))
- "cmov $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x3) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq avc2c3CRp)
-)
- ())
-(dncpi cadd3_avc2_c3 "cadd3" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cadd3"))
- "cadd3 $avc2c3CRo,$avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRo avc2c3CRq avc2c3CRp (f-avc2-c3sub4u16 #x3) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRo (add avc2c3CRq avc2c3CRp))
-)
- ())
-(dncpi caddi_avc2_c3 "caddi" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "caddi"))
- "caddi $avc2c3CRq,$avc2c3Imm6s24"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3Imm6s24 (f-avc2-c3sub2u30 #x0) (f-avc2-c3sub4u16 #x1) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (add avc2c3CRq (ext SI avc2c3Imm6s24)))
-)
- ())
-(dncpi csub_avc2_c3 "csub" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csub"))
- "csub $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x2) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (sub avc2c3CRq avc2c3CRp))
-)
- ())
-(dncpi cneg_avc2_c3 "cneg" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cneg"))
- "cneg $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x1) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (neg avc2c3CRp))
-)
- ())
-(dncpi cextb_avc2_c3 "cextb" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cextb"))
- "cextb $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #x9) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (ext SI (and QI (srl avc2c3CRq 0) #xff)))
-)
- ())
-(dncpi cexth_avc2_c3 "cexth" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cexth"))
- "cexth $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #x9) (f-avc2-c3sub4u24 #x2) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (ext SI (and HI (srl avc2c3CRq 0) #xffff)))
-)
- ())
-(dncpi cextub_avc2_c3 "cextub" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cextub"))
- "cextub $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #x9) (f-avc2-c3sub4u24 #x8) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (zext SI (and QI (srl avc2c3CRq 0) #xff)))
-)
- ())
-(dncpi cextuh_avc2_c3 "cextuh" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cextuh"))
- "cextuh $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #x9) (f-avc2-c3sub4u24 #xa) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (zext SI (and HI (srl avc2c3CRq 0) #xffff)))
-)
- ())
-(dncpi cscltz_avc2_c3 "cscltz" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cscltz"))
- "cscltz $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #xa) (f-avc2-c3sub4u24 #xa) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (lt (ext SI avc2c3CRq) (ext SI 0)) (set avc2copCCR1 (or (sll (srl avc2copCCR1 1) 1) (srl (sll (zext SI 1) 31) 31)))
-(set avc2copCCR1 (or (sll (srl avc2copCCR1 1) 1) (srl (sll (zext SI 0) 31) 31)))
-)
-)
- ())
-(dncpi cldz_avc2_c3 "cldz" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cldz"))
- "cldz $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x0) (f-avc2-c3sub4u16 #x5) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (and avc2c3CRp #x80000000) (set avc2c3CRq 0)
-(if (and avc2c3CRp #x40000000) (set avc2c3CRq 1)
-(if (and avc2c3CRp #x20000000) (set avc2c3CRq 2)
-(if (and avc2c3CRp #x10000000) (set avc2c3CRq 3)
-(if (and avc2c3CRp #x8000000) (set avc2c3CRq 4)
-(if (and avc2c3CRp #x4000000) (set avc2c3CRq 5)
-(if (and avc2c3CRp #x2000000) (set avc2c3CRq 6)
-(if (and avc2c3CRp #x1000000) (set avc2c3CRq 7)
-(if (and avc2c3CRp #x800000) (set avc2c3CRq 8)
-(if (and avc2c3CRp #x400000) (set avc2c3CRq 9)
-(if (and avc2c3CRp #x200000) (set avc2c3CRq 10)
-(if (and avc2c3CRp #x100000) (set avc2c3CRq 11)
-(if (and avc2c3CRp #x80000) (set avc2c3CRq 12)
-(if (and avc2c3CRp #x40000) (set avc2c3CRq 13)
-(if (and avc2c3CRp #x20000) (set avc2c3CRq 14)
-(if (and avc2c3CRp #x10000) (set avc2c3CRq 15)
-(if (and avc2c3CRp #x8000) (set avc2c3CRq 16)
-(if (and avc2c3CRp #x4000) (set avc2c3CRq 17)
-(if (and avc2c3CRp #x2000) (set avc2c3CRq 18)
-(if (and avc2c3CRp #x1000) (set avc2c3CRq 19)
-(if (and avc2c3CRp #x800) (set avc2c3CRq 20)
-(if (and avc2c3CRp #x400) (set avc2c3CRq 21)
-(if (and avc2c3CRp #x200) (set avc2c3CRq 22)
-(if (and avc2c3CRp #x100) (set avc2c3CRq 23)
-(if (and avc2c3CRp #x80) (set avc2c3CRq 24)
-(if (and avc2c3CRp #x40) (set avc2c3CRq 25)
-(if (and avc2c3CRp #x20) (set avc2c3CRq 26)
-(if (and avc2c3CRp #x10) (set avc2c3CRq 27)
-(if (and avc2c3CRp #x8) (set avc2c3CRq 28)
-(if (and avc2c3CRp #x4) (set avc2c3CRq 29)
-(if (and avc2c3CRp #x2) (set avc2c3CRq 30)
-(if (and avc2c3CRp #x1) (set avc2c3CRq 31)
-(set avc2c3CRq 32)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
- ())
-(dncpi cabs_avc2_c3 "cabs" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cabs"))
- "cabs $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x3) (f-avc2-c3sub4u16 #x5) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (abs (ext SI (subword SI (sub avc2c3CRq avc2c3CRp) 1))))
-)
- ())
-(dncpi cad1s_avc2_c3 "cad1s" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cad1s"))
- "cad1s $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x1) (f-avc2-c3sub4u16 #x5) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((SI tmp0)) (c-call "check_option_cp" pc)
-(set tmp0 (subword SI (add avc2c3CRq avc2c3CRp) 1))
-(set avc2c3CRq (sra tmp0 1))
-)
- ())
-(dncpi csb1s_avc2_c3 "csb1s" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csb1s"))
- "csb1s $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x2) (f-avc2-c3sub4u16 #x5) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((SI tmp0)) (c-call "check_option_cp" pc)
-(set tmp0 (subword SI (sub avc2c3CRq avc2c3CRp) 1))
-(set avc2c3CRq (sra tmp0 1))
-)
- ())
-(dncpi cmin_avc2_c3 "cmin" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmin"))
- "cmin $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x8) (f-avc2-c3sub4u16 #x5) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (lt (ext SI avc2c3CRq) (ext SI avc2c3CRp)) (set avc2c3CRq avc2c3CRq)
-(set avc2c3CRq avc2c3CRp)
-)
-)
- ())
-(dncpi cmax_avc2_c3 "cmax" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmax"))
- "cmax $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x9) (f-avc2-c3sub4u16 #x5) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (gt (ext SI avc2c3CRq) (ext SI avc2c3CRp)) (set avc2c3CRq avc2c3CRq)
-(set avc2c3CRq avc2c3CRp)
-)
-)
- ())
-(dncpi cminu_avc2_c3 "cminu" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cminu"))
- "cminu $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xa) (f-avc2-c3sub4u16 #x5) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (ltu (zext SI avc2c3CRq) (zext SI avc2c3CRp)) (set avc2c3CRq avc2c3CRq)
-(set avc2c3CRq avc2c3CRp)
-)
-)
- ())
-(dncpi cmaxu_avc2_c3 "cmaxu" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmaxu"))
- "cmaxu $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xb) (f-avc2-c3sub4u16 #x5) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (gtu (zext SI avc2c3CRq) (zext SI avc2c3CRp)) (set avc2c3CRq avc2c3CRq)
-(set avc2c3CRq avc2c3CRp)
-)
-)
- ())
-(dncpi cclipi_avc2_c3 "cclipi" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cclipi"))
- "cclipi $avc2c3CRq,$avc2c3Imm5u24"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3Imm5u24 (f-avc2-c3sub3u29 #x4) (f-avc2-c3sub4u16 #x5) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((SI tmp1)(SI tmp0)) (c-call "check_option_cp" pc)
-(if (eq (zext SI avc2c3Imm5u24) (ext SI 0)) (set avc2c3CRq 0)
-(sequence() (set tmp0 (sll 1 (sub avc2c3Imm5u24 1)))
-(set tmp1 (sub tmp0 1))
-(if (gt (ext SI avc2c3CRq) (ext SI tmp1)) (set avc2c3CRq tmp1)
-(if (lt (ext SI avc2c3CRq) (ext SI (neg tmp0))) (set avc2c3CRq (neg tmp0))
-(set avc2c3CRq avc2c3CRq)
-)
-)
-)
-)
-)
- ())
-(dncpi cclipiu_avc2_c3 "cclipiu" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cclipiu"))
- "cclipiu $avc2c3CRq,$avc2c3Imm5u24"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3Imm5u24 (f-avc2-c3sub3u29 #x5) (f-avc2-c3sub4u16 #x5) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((SI tmp0)(SI tmp1)) (c-call "check_option_cp" pc)
-(if (eq (zext SI avc2c3Imm5u24) (ext SI 0)) (set avc2c3CRq 0)
-(sequence() (set tmp0 (sub (sll 1 avc2c3Imm5u24) 1))
-(if (gtu (ext SI avc2c3CRq) (zext SI tmp0)) (set avc2c3CRq tmp0)
-(if (lt (ext SI avc2c3CRq) (ext SI 0)) (set avc2c3CRq 0)
-(set avc2c3CRq avc2c3CRq)
-)
-)
-)
-)
-)
- ())
-(dncpi cor_avc2_c3 "cor" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cor"))
- "cor $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x4) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (or avc2c3CRq avc2c3CRp))
-)
- ())
-(dncpi cand_avc2_c3 "cand" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cand"))
- "cand $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x5) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (and avc2c3CRq avc2c3CRp))
-)
- ())
-(dncpi cxor_avc2_c3 "cxor" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cxor"))
- "cxor $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x6) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (xor avc2c3CRq avc2c3CRp))
-)
- ())
-(dncpi cnor_avc2_c3 "cnor" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cnor"))
- "cnor $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x7) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (inv (or avc2c3CRq avc2c3CRp)))
-)
- ())
-(dncpi csra_avc2_c3 "csra" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csra"))
- "csra $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xc) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (sra avc2c3CRq (and QI (srl avc2c3CRp 0) #x1f)))
-)
- ())
-(dncpi csrl_avc2_c3 "csrl" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csrl"))
- "csrl $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xd) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (srl avc2c3CRq (and QI (srl avc2c3CRp 0) #x1f)))
-)
- ())
-(dncpi csll_avc2_c3 "csll" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csll"))
- "csll $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xe) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (sll avc2c3CRq (and QI (srl avc2c3CRp 0) #x1f)))
-)
- ())
-(dncpi csrai_avc2_c3 "csrai" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csrai"))
- "csrai $avc2c3CRq,$avc2c3Imm5u24"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3Imm5u24 (f-avc2-c3sub3u29 #x2) (f-avc2-c3sub4u16 #x1) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (sra avc2c3CRq avc2c3Imm5u24))
-)
- ())
-(dncpi csrli_avc2_c3 "csrli" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csrli"))
- "csrli $avc2c3CRq,$avc2c3Imm5u24"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3Imm5u24 (f-avc2-c3sub3u29 #x3) (f-avc2-c3sub4u16 #x1) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (srl avc2c3CRq avc2c3Imm5u24))
-)
- ())
-(dncpi cslli_avc2_c3 "cslli" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cslli"))
- "cslli $avc2c3CRq,$avc2c3Imm5u24"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3Imm5u24 (f-avc2-c3sub3u29 #x6) (f-avc2-c3sub4u16 #x1) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (sll avc2c3CRq avc2c3Imm5u24))
-)
- ())
-(dncpi cfsft_avc2_c3 "cfsft" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cfsft"))
- "cfsft $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xf) (f-avc2-c3sub4u16 #x0) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (subword SI (sll (or (sll (zext DI avc2c3CRq) 32) (zext DI avc2c3CRp)) (and QI (srl avc2copCCR0 0) #x3f)) 0))
-)
- ())
-(dncpi cfsfta0_avc2_c3 "cfsfta0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cfsfta0"))
- "cfsfta0 $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #x7) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u16 #x1) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (subword SI (sll (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (and QI (srl avc2copCCR0 0) #x3f)) 0))
-)
- ())
-(dncpi cfsfta1_avc2_c3 "cfsfta1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cfsfta1"))
- "cfsfta1 $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #xf) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u16 #x1) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2c3CRq (subword SI (sll (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (and QI (srl avc2copCCR0 0) #x3f)) 0))
-)
- ())
-(dncpi cmula0_avc2_c3 "cmula0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmula0"))
- "cmula0 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x0) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat0)) (c-call "check_option_cp" pc)
-(set concat0 (mul (ext DI avc2c3CRq) (ext DI avc2c3CRp)))
-(set avc2copCCR2 (subword SI concat0 0))
-(set avc2copCCR3 (subword SI concat0 1))
-)
- ())
-(dncpi cmulua0_avc2_c3 "cmulua0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmulua0"))
- "cmulua0 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x1) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat1)) (c-call "check_option_cp" pc)
-(set concat1 (mul (zext DI avc2c3CRq) (zext DI avc2c3CRp)))
-(set avc2copCCR2 (subword SI concat1 0))
-(set avc2copCCR3 (subword SI concat1 1))
-)
- ())
-(dncpi cnmula0_avc2_c3 "cnmula0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cnmula0"))
- "cnmula0 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x2) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat2)) (c-call "check_option_cp" pc)
-(set concat2 (neg (mul (ext DI avc2c3CRq) (ext DI avc2c3CRp))))
-(set avc2copCCR2 (subword SI concat2 0))
-(set avc2copCCR3 (subword SI concat2 1))
-)
- ())
-(dncpi cmada0_avc2_c3 "cmada0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmada0"))
- "cmada0 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x4) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat3)) (c-call "check_option_cp" pc)
-(set concat3 (add (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (ext DI avc2c3CRq) (ext DI avc2c3CRp))))
-(set avc2copCCR2 (subword SI concat3 0))
-(set avc2copCCR3 (subword SI concat3 1))
-)
- ())
-(dncpi cmadua0_avc2_c3 "cmadua0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmadua0"))
- "cmadua0 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x5) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat4)) (c-call "check_option_cp" pc)
-(set concat4 (add (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (zext DI avc2c3CRq) (zext DI avc2c3CRp))))
-(set avc2copCCR2 (subword SI concat4 0))
-(set avc2copCCR3 (subword SI concat4 1))
-)
- ())
-(dncpi cmsba0_avc2_c3 "cmsba0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmsba0"))
- "cmsba0 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x6) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat5)) (c-call "check_option_cp" pc)
-(set concat5 (sub (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (ext DI avc2c3CRq) (ext DI avc2c3CRp))))
-(set avc2copCCR2 (subword SI concat5 0))
-(set avc2copCCR3 (subword SI concat5 1))
-)
- ())
-(dncpi cmsbua0_avc2_c3 "cmsbua0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmsbua0"))
- "cmsbua0 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x7) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat6)) (c-call "check_option_cp" pc)
-(set concat6 (sub (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (zext DI avc2c3CRq) (zext DI avc2c3CRp))))
-(set avc2copCCR2 (subword SI concat6 0))
-(set avc2copCCR3 (subword SI concat6 1))
-)
- ())
-(dncpi cmula1_avc2_c3 "cmula1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmula1"))
- "cmula1 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x8) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat7)) (c-call "check_option_cp" pc)
-(set concat7 (mul (ext DI avc2c3CRq) (ext DI avc2c3CRp)))
-(set avc2copCCR4 (subword SI concat7 0))
-(set avc2copCCR5 (subword SI concat7 1))
-)
- ())
-(dncpi cmulua1_avc2_c3 "cmulua1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmulua1"))
- "cmulua1 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x9) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat8)) (c-call "check_option_cp" pc)
-(set concat8 (mul (zext DI avc2c3CRq) (zext DI avc2c3CRp)))
-(set avc2copCCR4 (subword SI concat8 0))
-(set avc2copCCR5 (subword SI concat8 1))
-)
- ())
-(dncpi cnmula1_avc2_c3 "cnmula1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cnmula1"))
- "cnmula1 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xa) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat9)) (c-call "check_option_cp" pc)
-(set concat9 (neg (mul (ext DI avc2c3CRq) (ext DI avc2c3CRp))))
-(set avc2copCCR4 (subword SI concat9 0))
-(set avc2copCCR5 (subword SI concat9 1))
-)
- ())
-(dncpi cmada1_avc2_c3 "cmada1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmada1"))
- "cmada1 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xc) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat10)) (c-call "check_option_cp" pc)
-(set concat10 (add (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (ext DI avc2c3CRq) (ext DI avc2c3CRp))))
-(set avc2copCCR4 (subword SI concat10 0))
-(set avc2copCCR5 (subword SI concat10 1))
-)
- ())
-(dncpi cmadua1_avc2_c3 "cmadua1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmadua1"))
- "cmadua1 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xd) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat11)) (c-call "check_option_cp" pc)
-(set concat11 (add (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (zext DI avc2c3CRq) (zext DI avc2c3CRp))))
-(set avc2copCCR4 (subword SI concat11 0))
-(set avc2copCCR5 (subword SI concat11 1))
-)
- ())
-(dncpi cmsba1_avc2_c3 "cmsba1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmsba1"))
- "cmsba1 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xe) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat12)) (c-call "check_option_cp" pc)
-(set concat12 (sub (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (ext DI avc2c3CRq) (ext DI avc2c3CRp))))
-(set avc2copCCR4 (subword SI concat12 0))
-(set avc2copCCR5 (subword SI concat12 1))
-)
- ())
-(dncpi cmsbua1_avc2_c3 "cmsbua1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmsbua1"))
- "cmsbua1 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xf) (f-avc2-c3sub4u16 #x4) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat13)) (c-call "check_option_cp" pc)
-(set concat13 (sub (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (zext DI avc2c3CRq) (zext DI avc2c3CRp))))
-(set avc2copCCR4 (subword SI concat13 0))
-(set avc2copCCR5 (subword SI concat13 1))
-)
- ())
-(dncpi xmula0_avc2_c3 "xmula0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmula0"))
- "xmula0 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #x0) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat14)) (c-call "check_option_cp" pc)
-(set concat14 (mul (ext DI avc2c3Rn) (ext DI avc2c3Rm)))
-(set avc2copCCR2 (subword SI concat14 0))
-(set avc2copCCR3 (subword SI concat14 1))
-)
- ())
-(dncpi xmulua0_avc2_c3 "xmulua0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmulua0"))
- "xmulua0 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #x1) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat15)) (c-call "check_option_cp" pc)
-(set concat15 (mul (zext DI avc2c3Rn) (zext DI avc2c3Rm)))
-(set avc2copCCR2 (subword SI concat15 0))
-(set avc2copCCR3 (subword SI concat15 1))
-)
- ())
-(dncpi xnmula0_avc2_c3 "xnmula0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xnmula0"))
- "xnmula0 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #x2) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat16)) (c-call "check_option_cp" pc)
-(set concat16 (neg (mul (ext DI avc2c3Rn) (ext DI avc2c3Rm))))
-(set avc2copCCR2 (subword SI concat16 0))
-(set avc2copCCR3 (subword SI concat16 1))
-)
- ())
-(dncpi xmada0_avc2_c3 "xmada0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmada0"))
- "xmada0 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #x4) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat17)) (c-call "check_option_cp" pc)
-(set concat17 (add (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (ext DI avc2c3Rn) (ext DI avc2c3Rm))))
-(set avc2copCCR2 (subword SI concat17 0))
-(set avc2copCCR3 (subword SI concat17 1))
-)
- ())
-(dncpi xmadua0_avc2_c3 "xmadua0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmadua0"))
- "xmadua0 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #x5) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat18)) (c-call "check_option_cp" pc)
-(set concat18 (add (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (zext DI avc2c3Rn) (zext DI avc2c3Rm))))
-(set avc2copCCR2 (subword SI concat18 0))
-(set avc2copCCR3 (subword SI concat18 1))
-)
- ())
-(dncpi xmsba0_avc2_c3 "xmsba0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmsba0"))
- "xmsba0 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #x6) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat19)) (c-call "check_option_cp" pc)
-(set concat19 (sub (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (ext DI avc2c3Rn) (ext DI avc2c3Rm))))
-(set avc2copCCR2 (subword SI concat19 0))
-(set avc2copCCR3 (subword SI concat19 1))
-)
- ())
-(dncpi xmsbua0_avc2_c3 "xmsbua0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmsbua0"))
- "xmsbua0 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #x7) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat20)) (c-call "check_option_cp" pc)
-(set concat20 (sub (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (zext DI avc2c3Rn) (zext DI avc2c3Rm))))
-(set avc2copCCR2 (subword SI concat20 0))
-(set avc2copCCR3 (subword SI concat20 1))
-)
- ())
-(dncpi xmula1_avc2_c3 "xmula1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmula1"))
- "xmula1 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #x8) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat21)) (c-call "check_option_cp" pc)
-(set concat21 (mul (ext DI avc2c3Rn) (ext DI avc2c3Rm)))
-(set avc2copCCR4 (subword SI concat21 0))
-(set avc2copCCR5 (subword SI concat21 1))
-)
- ())
-(dncpi xmulua1_avc2_c3 "xmulua1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmulua1"))
- "xmulua1 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #x9) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat22)) (c-call "check_option_cp" pc)
-(set concat22 (mul (zext DI avc2c3Rn) (zext DI avc2c3Rm)))
-(set avc2copCCR4 (subword SI concat22 0))
-(set avc2copCCR5 (subword SI concat22 1))
-)
- ())
-(dncpi xnmula1_avc2_c3 "xnmula1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xnmula1"))
- "xnmula1 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #xa) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat23)) (c-call "check_option_cp" pc)
-(set concat23 (neg (mul (ext DI avc2c3Rn) (ext DI avc2c3Rm))))
-(set avc2copCCR4 (subword SI concat23 0))
-(set avc2copCCR5 (subword SI concat23 1))
-)
- ())
-(dncpi xmada1_avc2_c3 "xmada1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmada1"))
- "xmada1 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #xc) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat24)) (c-call "check_option_cp" pc)
-(set concat24 (add (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (ext DI avc2c3Rn) (ext DI avc2c3Rm))))
-(set avc2copCCR4 (subword SI concat24 0))
-(set avc2copCCR5 (subword SI concat24 1))
-)
- ())
-(dncpi xmadua1_avc2_c3 "xmadua1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmadua1"))
- "xmadua1 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #xd) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat25)) (c-call "check_option_cp" pc)
-(set concat25 (add (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (zext DI avc2c3Rn) (zext DI avc2c3Rm))))
-(set avc2copCCR4 (subword SI concat25 0))
-(set avc2copCCR5 (subword SI concat25 1))
-)
- ())
-(dncpi xmsba1_avc2_c3 "xmsba1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmsba1"))
- "xmsba1 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #xe) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat26)) (c-call "check_option_cp" pc)
-(set concat26 (sub (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (ext DI avc2c3Rn) (ext DI avc2c3Rm))))
-(set avc2copCCR4 (subword SI concat26 0))
-(set avc2copCCR5 (subword SI concat26 1))
-)
- ())
-(dncpi xmsbua1_avc2_c3 "xmsbua1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmsbua1"))
- "xmsbua1 $avc2c3Rn,$avc2c3Rm"
-(+ MAJ_15 (f-sub4 7) avc2c3Rn avc2c3Rm (f-avc2-c3sub4u28 #xf) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xc))
-(sequence((DI concat27)) (c-call "check_option_cp" pc)
-(set concat27 (sub (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (zext DI avc2c3Rn) (zext DI avc2c3Rm))))
-(set avc2copCCR4 (subword SI concat27 0))
-(set avc2copCCR5 (subword SI concat27 1))
-)
- ())
-(dncpi cclipa0_avc2_c3 "cclipa0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cclipa0"))
- "cclipa0 $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #x0) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u16 #x6) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI tmp_rslt)(DI min)(DI max)) (c-call "check_option_cp" pc)
-(set max #x000000007FFFFFFF)
-(set min #xFFFFFFFF80000000)
-(if (gt (ext DI (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3))) (ext DI max)) (set tmp_rslt max)
-(if (lt (ext DI (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3))) (ext DI min)) (set tmp_rslt min)
-(set tmp_rslt (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)))
-)
-)
-(set avc2c3CRq (subword SI tmp_rslt 1))
-)
- ())
-(dncpi cclipa1_avc2_c3 "cclipa1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cclipa1"))
- "cclipa1 $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #x1) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u16 #x6) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI tmp_rslt)(DI min)(DI max)) (c-call "check_option_cp" pc)
-(set max #x000000007FFFFFFF)
-(set min #xFFFFFFFF80000000)
-(if (gt (ext DI (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5))) (ext DI max)) (set tmp_rslt max)
-(if (lt (ext DI (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5))) (ext DI min)) (set tmp_rslt min)
-(set tmp_rslt (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)))
-)
-)
-(set avc2c3CRq (subword SI tmp_rslt 1))
-)
- ())
-(dncpi cmvsla0i_avc2_c3 "cmvsla0i" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmvsla0i"))
- "cmvsla0i $avc2c3CRq,$avc2c3Imm6u24"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3Imm6u24 (f-avc2-c3sub2u30 #x2) (f-avc2-c3sub4u16 #xb) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat28)) (c-call "check_option_cp" pc)
-(set concat28 (sll (ext DI avc2c3CRq) avc2c3Imm6u24))
-(set avc2copCCR2 (subword SI concat28 0))
-(set avc2copCCR3 (subword SI concat28 1))
-)
- ())
-(dncpi cmvsra0i_avc2_c3 "cmvsra0i" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmvsra0i"))
- "cmvsra0i $avc2c3CRq,$avc2c3Imm6u24"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3Imm6u24 (f-avc2-c3sub2u30 #x0) (f-avc2-c3sub4u16 #xb) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat29)) (c-call "check_option_cp" pc)
-(set concat29 (sra (ext DI avc2c3CRq) avc2c3Imm6u24))
-(set avc2copCCR2 (subword SI concat29 0))
-(set avc2copCCR3 (subword SI concat29 1))
-)
- ())
-(dncpi cmvsla1i_avc2_c3 "cmvsla1i" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmvsla1i"))
- "cmvsla1i $avc2c3CRq,$avc2c3Imm6u24"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3Imm6u24 (f-avc2-c3sub2u30 #x3) (f-avc2-c3sub4u16 #xb) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat30)) (c-call "check_option_cp" pc)
-(set concat30 (sll (ext DI avc2c3CRq) avc2c3Imm6u24))
-(set avc2copCCR4 (subword SI concat30 0))
-(set avc2copCCR5 (subword SI concat30 1))
-)
- ())
-(dncpi cmvsra1i_avc2_c3 "cmvsra1i" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmvsra1i"))
- "cmvsra1i $avc2c3CRq,$avc2c3Imm6u24"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3Imm6u24 (f-avc2-c3sub2u30 #x1) (f-avc2-c3sub4u16 #xb) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat31)) (c-call "check_option_cp" pc)
-(set concat31 (sra (ext DI avc2c3CRq) avc2c3Imm6u24))
-(set avc2copCCR4 (subword SI concat31 0))
-(set avc2copCCR5 (subword SI concat31 1))
-)
- ())
-(dncpi csraa0i_avc2_c3 "csraa0i" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csraa0i"))
- "csraa0i $avc2c3Imm6u24"
-(+ MAJ_15 (f-sub4 7) avc2c3Imm6u24 (f-avc2-c3sub2u30 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #x9) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat32)) (c-call "check_option_cp" pc)
-(set concat32 (sra (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) avc2c3Imm6u24))
-(set avc2copCCR2 (subword SI concat32 0))
-(set avc2copCCR3 (subword SI concat32 1))
-)
- ())
-(dncpi csraa1i_avc2_c3 "csraa1i" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csraa1i"))
- "csraa1i $avc2c3Imm6u24"
-(+ MAJ_15 (f-sub4 7) avc2c3Imm6u24 (f-avc2-c3sub2u30 #x1) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #x9) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat33)) (c-call "check_option_cp" pc)
-(set concat33 (sra (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) avc2c3Imm6u24))
-(set avc2copCCR4 (subword SI concat33 0))
-(set avc2copCCR5 (subword SI concat33 1))
-)
- ())
-(dncpi csrla0i_avc2_c3 "csrla0i" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csrla0i"))
- "csrla0i $avc2c3Imm6u24"
-(+ MAJ_15 (f-sub4 7) avc2c3Imm6u24 (f-avc2-c3sub2u30 #x0) (f-avc2-c3sub4u20 #x1) (f-avc2-c3sub4u16 #x9) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat34)) (c-call "check_option_cp" pc)
-(set concat34 (srl (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) avc2c3Imm6u24))
-(set avc2copCCR2 (subword SI concat34 0))
-(set avc2copCCR3 (subword SI concat34 1))
-)
- ())
-(dncpi csrla1i_avc2_c3 "csrla1i" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csrla1i"))
- "csrla1i $avc2c3Imm6u24"
-(+ MAJ_15 (f-sub4 7) avc2c3Imm6u24 (f-avc2-c3sub2u30 #x1) (f-avc2-c3sub4u20 #x1) (f-avc2-c3sub4u16 #x9) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat35)) (c-call "check_option_cp" pc)
-(set concat35 (srl (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) avc2c3Imm6u24))
-(set avc2copCCR4 (subword SI concat35 0))
-(set avc2copCCR5 (subword SI concat35 1))
-)
- ())
-(dncpi cslla0i_avc2_c3 "cslla0i" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cslla0i"))
- "cslla0i $avc2c3Imm6u24"
-(+ MAJ_15 (f-sub4 7) avc2c3Imm6u24 (f-avc2-c3sub2u30 #x0) (f-avc2-c3sub4u20 #x3) (f-avc2-c3sub4u16 #x9) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat36)) (c-call "check_option_cp" pc)
-(set concat36 (sll (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) avc2c3Imm6u24))
-(set avc2copCCR2 (subword SI concat36 0))
-(set avc2copCCR3 (subword SI concat36 1))
-)
- ())
-(dncpi cslla1i_avc2_c3 "cslla1i" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cslla1i"))
- "cslla1i $avc2c3Imm6u24"
-(+ MAJ_15 (f-sub4 7) avc2c3Imm6u24 (f-avc2-c3sub2u30 #x1) (f-avc2-c3sub4u20 #x3) (f-avc2-c3sub4u16 #x9) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat37)) (c-call "check_option_cp" pc)
-(set concat37 (sll (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) avc2c3Imm6u24))
-(set avc2copCCR4 (subword SI concat37 0))
-(set avc2copCCR5 (subword SI concat37 1))
-)
- ())
-(dncpi csraa0_avc2_c3 "csraa0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csraa0"))
- "csraa0"
-(+ MAJ_15 (f-sub4 7) (f-avc2-c3sub4u28 #x0) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #xc) (f-avc2-c3sub4u16 #x9) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat38)) (c-call "check_option_cp" pc)
-(set concat38 (sra (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) (and QI (srl avc2copCCR0 0) #x3f)))
-(set avc2copCCR2 (subword SI concat38 0))
-(set avc2copCCR3 (subword SI concat38 1))
-)
- ())
-(dncpi csraa1_avc2_c3 "csraa1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csraa1"))
- "csraa1"
-(+ MAJ_15 (f-sub4 7) (f-avc2-c3sub4u28 #x1) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #xc) (f-avc2-c3sub4u16 #x9) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat39)) (c-call "check_option_cp" pc)
-(set concat39 (sra (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (and QI (srl avc2copCCR0 0) #x3f)))
-(set avc2copCCR4 (subword SI concat39 0))
-(set avc2copCCR5 (subword SI concat39 1))
-)
- ())
-(dncpi csrla0_avc2_c3 "csrla0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csrla0"))
- "csrla0"
-(+ MAJ_15 (f-sub4 7) (f-avc2-c3sub4u28 #x0) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #xd) (f-avc2-c3sub4u16 #x9) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat40)) (c-call "check_option_cp" pc)
-(set concat40 (srl (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) (and QI (srl avc2copCCR0 0) #x3f)))
-(set avc2copCCR2 (subword SI concat40 0))
-(set avc2copCCR3 (subword SI concat40 1))
-)
- ())
-(dncpi csrla1_avc2_c3 "csrla1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csrla1"))
- "csrla1"
-(+ MAJ_15 (f-sub4 7) (f-avc2-c3sub4u28 #x1) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #xd) (f-avc2-c3sub4u16 #x9) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat41)) (c-call "check_option_cp" pc)
-(set concat41 (srl (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (and QI (srl avc2copCCR0 0) #x3f)))
-(set avc2copCCR4 (subword SI concat41 0))
-(set avc2copCCR5 (subword SI concat41 1))
-)
- ())
-(dncpi cslla0_avc2_c3 "cslla0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cslla0"))
- "cslla0"
-(+ MAJ_15 (f-sub4 7) (f-avc2-c3sub4u28 #x0) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #xf) (f-avc2-c3sub4u16 #x9) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat42)) (c-call "check_option_cp" pc)
-(set concat42 (sll (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) (and QI (srl avc2copCCR0 0) #x3f)))
-(set avc2copCCR2 (subword SI concat42 0))
-(set avc2copCCR3 (subword SI concat42 1))
-)
- ())
-(dncpi cslla1_avc2_c3 "cslla1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cslla1"))
- "cslla1"
-(+ MAJ_15 (f-sub4 7) (f-avc2-c3sub4u28 #x1) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #xf) (f-avc2-c3sub4u16 #x9) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat43)) (c-call "check_option_cp" pc)
-(set concat43 (sll (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (and QI (srl avc2copCCR0 0) #x3f)))
-(set avc2copCCR4 (subword SI concat43 0))
-(set avc2copCCR5 (subword SI concat43 1))
-)
- ())
-(dncpi cadda0_avc2_c3 "cadda0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cadda0"))
- "cadda0 $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #x0) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u16 #x8) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat44)) (c-call "check_option_cp" pc)
-(set concat44 (add (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) (ext DI avc2c3CRq)))
-(set avc2copCCR2 (subword SI concat44 0))
-(set avc2copCCR3 (subword SI concat44 1))
-)
- ())
-(dncpi cadda1_avc2_c3 "cadda1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cadda1"))
- "cadda1 $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #x1) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u16 #x8) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat45)) (c-call "check_option_cp" pc)
-(set concat45 (add (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (ext DI avc2c3CRq)))
-(set avc2copCCR4 (subword SI concat45 0))
-(set avc2copCCR5 (subword SI concat45 1))
-)
- ())
-(dncpi csuba0_avc2_c3 "csuba0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csuba0"))
- "csuba0 $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #x2) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u16 #x8) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat46)) (c-call "check_option_cp" pc)
-(set concat46 (sub (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) (ext DI avc2c3CRq)))
-(set avc2copCCR2 (subword SI concat46 0))
-(set avc2copCCR3 (subword SI concat46 1))
-)
- ())
-(dncpi csuba1_avc2_c3 "csuba1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csuba1"))
- "csuba1 $avc2c3CRq"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq (f-avc2-c3sub4u28 #x3) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u16 #x8) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat47)) (c-call "check_option_cp" pc)
-(set concat47 (sub (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (ext DI avc2c3CRq)))
-(set avc2copCCR4 (subword SI concat47 0))
-(set avc2copCCR5 (subword SI concat47 1))
-)
- ())
-(dncpi cadd2a0_avc2_c3 "cadd2a0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cadd2a0"))
- "cadd2a0 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x8) (f-avc2-c3sub4u16 #x8) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat48)) (c-call "check_option_cp" pc)
-(set concat48 (add (ext DI avc2c3CRq) (ext DI avc2c3CRp)))
-(set avc2copCCR2 (subword SI concat48 0))
-(set avc2copCCR3 (subword SI concat48 1))
-)
- ())
-(dncpi cadd2a1_avc2_c3 "cadd2a1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cadd2a1"))
- "cadd2a1 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #x9) (f-avc2-c3sub4u16 #x8) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat49)) (c-call "check_option_cp" pc)
-(set concat49 (add (ext DI avc2c3CRq) (ext DI avc2c3CRp)))
-(set avc2copCCR4 (subword SI concat49 0))
-(set avc2copCCR5 (subword SI concat49 1))
-)
- ())
-(dncpi csub2a0_avc2_c3 "csub2a0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csub2a0"))
- "csub2a0 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xa) (f-avc2-c3sub4u16 #x8) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat50)) (c-call "check_option_cp" pc)
-(set concat50 (sub (ext DI avc2c3CRq) (ext DI avc2c3CRp)))
-(set avc2copCCR2 (subword SI concat50 0))
-(set avc2copCCR3 (subword SI concat50 1))
-)
- ())
-(dncpi csub2a1_avc2_c3 "csub2a1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csub2a1"))
- "csub2a1 $avc2c3CRq,$avc2c3CRp"
-(+ MAJ_15 (f-sub4 7) avc2c3CRq avc2c3CRp (f-avc2-c3sub4u28 #xb) (f-avc2-c3sub4u16 #x8) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat51)) (c-call "check_option_cp" pc)
-(set concat51 (sub (ext DI avc2c3CRq) (ext DI avc2c3CRp)))
-(set avc2copCCR4 (subword SI concat51 0))
-(set avc2copCCR5 (subword SI concat51 1))
-)
- ())
-(dncpi caddaa0_avc2_c3 "caddaa0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "caddaa0"))
- "caddaa0"
-(+ MAJ_15 (f-sub4 7) (f-avc2-c3sub4u28 #x0) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xa) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat52)) (c-call "check_option_cp" pc)
-(set concat52 (add (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3))))
-(set avc2copCCR2 (subword SI concat52 0))
-(set avc2copCCR3 (subword SI concat52 1))
-)
- ())
-(dncpi caddaa1_avc2_c3 "caddaa1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "caddaa1"))
- "caddaa1"
-(+ MAJ_15 (f-sub4 7) (f-avc2-c3sub4u28 #x1) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xa) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat53)) (c-call "check_option_cp" pc)
-(set concat53 (add (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3))))
-(set avc2copCCR4 (subword SI concat53 0))
-(set avc2copCCR5 (subword SI concat53 1))
-)
- ())
-(dncpi csubaa0_avc2_c3 "csubaa0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csubaa0"))
- "csubaa0"
-(+ MAJ_15 (f-sub4 7) (f-avc2-c3sub4u28 #x2) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xa) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat54)) (c-call "check_option_cp" pc)
-(set concat54 (sub (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3))))
-(set avc2copCCR2 (subword SI concat54 0))
-(set avc2copCCR3 (subword SI concat54 1))
-)
- ())
-(dncpi csubaa1_avc2_c3 "csubaa1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csubaa1"))
- "csubaa1"
-(+ MAJ_15 (f-sub4 7) (f-avc2-c3sub4u28 #x3) (f-avc2-c3sub4u24 #x0) (f-avc2-c3sub4u20 #x0) (f-avc2-c3sub4u16 #xa) (f-avc2-c3sub4u8 #x0) (f-avc2-c3sub4u4 #x0))
-(sequence((DI concat55)) (c-call "check_option_cp" pc)
-(set concat55 (sub (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3))))
-(set avc2copCCR4 (subword SI concat55 0))
-(set avc2copCCR5 (subword SI concat55 1))
-)
- ())
-(dn16i cnop_avc2_v1 "cnop" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cnop"))
- "cnop"
-(+ (f-avc2-v1sub4u12 #x0) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u4 #x0) (f-avc2-v1sub4u0 #x0))
-(c-call "check_option_cp" pc)
- ())
-(dnmi cpnop16_avc2_v1 "cpnop16"
-(avc2-16-isa NO-DIS)
-"cpnop16"
-(emit cnop_avc2_v1)
-)
-(dn16i cmov_avc2_v1 "cmov" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmov"))
- "cmov $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x3) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq avc2v1CRp)
-)
- ())
-(dn16i cmovi_avc2_v1 "cmovi" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmovi"))
- "cmovi $avc2v1CRq,$avc2v1Imm8s8"
-(+ avc2v1CRq avc2v1Imm8s8 (f-avc2-v1sub4u0 #x2))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (ext SI avc2v1Imm8s8))
-)
- ())
-(dn16i cadd3_avc2_v1 "cadd3" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cadd3"))
- "cadd3 $avc2v1CRo,$avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRo avc2v1CRq avc2v1CRp (f-avc2-v1sub4u0 #x3))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRo (add avc2v1CRq avc2v1CRp))
-)
- ())
-(dn16i caddi_avc2_v1 "caddi" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "caddi"))
- "caddi $avc2v1CRq,$avc2v1Imm6s8"
-(+ avc2v1CRq avc2v1Imm6s8 (f-avc2-v1sub2u14 #x0) (f-avc2-v1sub4u0 #x1))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (add avc2v1CRq (ext SI avc2v1Imm6s8)))
-)
- ())
-(dn16i csub_avc2_v1 "csub" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csub"))
- "csub $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x2) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (sub avc2v1CRq avc2v1CRp))
-)
- ())
-(dn16i cneg_avc2_v1 "cneg" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cneg"))
- "cneg $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x1) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (neg avc2v1CRp))
-)
- ())
-(dn16i cextb_avc2_v1 "cextb" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cextb"))
- "cextb $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #x9) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (ext SI (and QI (srl avc2v1CRq 0) #xff)))
-)
- ())
-(dn16i cexth_avc2_v1 "cexth" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cexth"))
- "cexth $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #x9) (f-avc2-v1sub4u8 #x2) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (ext SI (and HI (srl avc2v1CRq 0) #xffff)))
-)
- ())
-(dn16i cextub_avc2_v1 "cextub" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cextub"))
- "cextub $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #x9) (f-avc2-v1sub4u8 #x8) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (zext SI (and QI (srl avc2v1CRq 0) #xff)))
-)
- ())
-(dn16i cextuh_avc2_v1 "cextuh" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cextuh"))
- "cextuh $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #x9) (f-avc2-v1sub4u8 #xa) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (zext SI (and HI (srl avc2v1CRq 0) #xffff)))
-)
- ())
-(dn16i cscltz_avc2_v1 "cscltz" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cscltz"))
- "cscltz $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #xa) (f-avc2-v1sub4u8 #xa) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (lt (ext SI avc2v1CRq) (ext SI 0)) (set avc2copCCR1 (or (sll (srl avc2copCCR1 1) 1) (srl (sll (zext SI 1) 31) 31)))
-(set avc2copCCR1 (or (sll (srl avc2copCCR1 1) 1) (srl (sll (zext SI 0) 31) 31)))
-)
-)
- ())
-(dn16i cldz_avc2_v1 "cldz" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cldz"))
- "cldz $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x0) (f-avc2-v1sub4u0 #x5))
-(sequence() (c-call "check_option_cp" pc)
-(if (and avc2v1CRp #x80000000) (set avc2v1CRq 0)
-(if (and avc2v1CRp #x40000000) (set avc2v1CRq 1)
-(if (and avc2v1CRp #x20000000) (set avc2v1CRq 2)
-(if (and avc2v1CRp #x10000000) (set avc2v1CRq 3)
-(if (and avc2v1CRp #x8000000) (set avc2v1CRq 4)
-(if (and avc2v1CRp #x4000000) (set avc2v1CRq 5)
-(if (and avc2v1CRp #x2000000) (set avc2v1CRq 6)
-(if (and avc2v1CRp #x1000000) (set avc2v1CRq 7)
-(if (and avc2v1CRp #x800000) (set avc2v1CRq 8)
-(if (and avc2v1CRp #x400000) (set avc2v1CRq 9)
-(if (and avc2v1CRp #x200000) (set avc2v1CRq 10)
-(if (and avc2v1CRp #x100000) (set avc2v1CRq 11)
-(if (and avc2v1CRp #x80000) (set avc2v1CRq 12)
-(if (and avc2v1CRp #x40000) (set avc2v1CRq 13)
-(if (and avc2v1CRp #x20000) (set avc2v1CRq 14)
-(if (and avc2v1CRp #x10000) (set avc2v1CRq 15)
-(if (and avc2v1CRp #x8000) (set avc2v1CRq 16)
-(if (and avc2v1CRp #x4000) (set avc2v1CRq 17)
-(if (and avc2v1CRp #x2000) (set avc2v1CRq 18)
-(if (and avc2v1CRp #x1000) (set avc2v1CRq 19)
-(if (and avc2v1CRp #x800) (set avc2v1CRq 20)
-(if (and avc2v1CRp #x400) (set avc2v1CRq 21)
-(if (and avc2v1CRp #x200) (set avc2v1CRq 22)
-(if (and avc2v1CRp #x100) (set avc2v1CRq 23)
-(if (and avc2v1CRp #x80) (set avc2v1CRq 24)
-(if (and avc2v1CRp #x40) (set avc2v1CRq 25)
-(if (and avc2v1CRp #x20) (set avc2v1CRq 26)
-(if (and avc2v1CRp #x10) (set avc2v1CRq 27)
-(if (and avc2v1CRp #x8) (set avc2v1CRq 28)
-(if (and avc2v1CRp #x4) (set avc2v1CRq 29)
-(if (and avc2v1CRp #x2) (set avc2v1CRq 30)
-(if (and avc2v1CRp #x1) (set avc2v1CRq 31)
-(set avc2v1CRq 32)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
- ())
-(dn16i cabs_avc2_v1 "cabs" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cabs"))
- "cabs $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x3) (f-avc2-v1sub4u0 #x5))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (abs (ext SI (subword SI (sub avc2v1CRq avc2v1CRp) 1))))
-)
- ())
-(dn16i cad1s_avc2_v1 "cad1s" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cad1s"))
- "cad1s $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x1) (f-avc2-v1sub4u0 #x5))
-(sequence((SI tmp0)) (c-call "check_option_cp" pc)
-(set tmp0 (subword SI (add avc2v1CRq avc2v1CRp) 1))
-(set avc2v1CRq (sra tmp0 1))
-)
- ())
-(dn16i csb1s_avc2_v1 "csb1s" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csb1s"))
- "csb1s $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x2) (f-avc2-v1sub4u0 #x5))
-(sequence((SI tmp0)) (c-call "check_option_cp" pc)
-(set tmp0 (subword SI (sub avc2v1CRq avc2v1CRp) 1))
-(set avc2v1CRq (sra tmp0 1))
-)
- ())
-(dn16i cmin_avc2_v1 "cmin" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmin"))
- "cmin $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x8) (f-avc2-v1sub4u0 #x5))
-(sequence() (c-call "check_option_cp" pc)
-(if (lt (ext SI avc2v1CRq) (ext SI avc2v1CRp)) (set avc2v1CRq avc2v1CRq)
-(set avc2v1CRq avc2v1CRp)
-)
-)
- ())
-(dn16i cmax_avc2_v1 "cmax" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmax"))
- "cmax $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x9) (f-avc2-v1sub4u0 #x5))
-(sequence() (c-call "check_option_cp" pc)
-(if (gt (ext SI avc2v1CRq) (ext SI avc2v1CRp)) (set avc2v1CRq avc2v1CRq)
-(set avc2v1CRq avc2v1CRp)
-)
-)
- ())
-(dn16i cminu_avc2_v1 "cminu" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cminu"))
- "cminu $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xa) (f-avc2-v1sub4u0 #x5))
-(sequence() (c-call "check_option_cp" pc)
-(if (ltu (zext SI avc2v1CRq) (zext SI avc2v1CRp)) (set avc2v1CRq avc2v1CRq)
-(set avc2v1CRq avc2v1CRp)
-)
-)
- ())
-(dn16i cmaxu_avc2_v1 "cmaxu" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmaxu"))
- "cmaxu $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xb) (f-avc2-v1sub4u0 #x5))
-(sequence() (c-call "check_option_cp" pc)
-(if (gtu (zext SI avc2v1CRq) (zext SI avc2v1CRp)) (set avc2v1CRq avc2v1CRq)
-(set avc2v1CRq avc2v1CRp)
-)
-)
- ())
-(dn16i cclipi_avc2_v1 "cclipi" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cclipi"))
- "cclipi $avc2v1CRq,$avc2v1Imm5u8"
-(+ avc2v1CRq avc2v1Imm5u8 (f-avc2-v1sub3u13 #x4) (f-avc2-v1sub4u0 #x5))
-(sequence((SI tmp1)(SI tmp0)) (c-call "check_option_cp" pc)
-(if (eq (zext SI avc2v1Imm5u8) (ext SI 0)) (set avc2v1CRq 0)
-(sequence() (set tmp0 (sll 1 (sub avc2v1Imm5u8 1)))
-(set tmp1 (sub tmp0 1))
-(if (gt (ext SI avc2v1CRq) (ext SI tmp1)) (set avc2v1CRq tmp1)
-(if (lt (ext SI avc2v1CRq) (ext SI (neg tmp0))) (set avc2v1CRq (neg tmp0))
-(set avc2v1CRq avc2v1CRq)
-)
-)
-)
-)
-)
- ())
-(dn16i cclipiu_avc2_v1 "cclipiu" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cclipiu"))
- "cclipiu $avc2v1CRq,$avc2v1Imm5u8"
-(+ avc2v1CRq avc2v1Imm5u8 (f-avc2-v1sub3u13 #x5) (f-avc2-v1sub4u0 #x5))
-(sequence((SI tmp1)(SI tmp0)) (c-call "check_option_cp" pc)
-(if (eq (zext SI avc2v1Imm5u8) (ext SI 0)) (set avc2v1CRq 0)
-(sequence() (set tmp0 (sub (sll 1 avc2v1Imm5u8) 1))
-(if (gtu (ext SI avc2v1CRq) (zext SI tmp0)) (set avc2v1CRq tmp0)
-(if (lt (ext SI avc2v1CRq) (ext SI 0)) (set avc2v1CRq 0)
-(set avc2v1CRq avc2v1CRq)
-)
-)
-)
-)
-)
- ())
-(dn16i cor_avc2_v1 "cor" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cor"))
- "cor $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x4) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (or avc2v1CRq avc2v1CRp))
-)
- ())
-(dn16i cand_avc2_v1 "cand" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cand"))
- "cand $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x5) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (and avc2v1CRq avc2v1CRp))
-)
- ())
-(dn16i cxor_avc2_v1 "cxor" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cxor"))
- "cxor $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x6) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (xor avc2v1CRq avc2v1CRp))
-)
- ())
-(dn16i cnor_avc2_v1 "cnor" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cnor"))
- "cnor $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x7) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (inv (or avc2v1CRq avc2v1CRp)))
-)
- ())
-(dn16i csra_avc2_v1 "csra" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csra"))
- "csra $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xc) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (sra avc2v1CRq (and QI (srl avc2v1CRp 0) #x1f)))
-)
- ())
-(dn16i csrl_avc2_v1 "csrl" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csrl"))
- "csrl $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xd) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (srl avc2v1CRq (and QI (srl avc2v1CRp 0) #x1f)))
-)
- ())
-(dn16i csll_avc2_v1 "csll" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csll"))
- "csll $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xe) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (sll avc2v1CRq (and QI (srl avc2v1CRp 0) #x1f)))
-)
- ())
-(dn16i csrai_avc2_v1 "csrai" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csrai"))
- "csrai $avc2v1CRq,$avc2v1Imm5u8"
-(+ avc2v1CRq avc2v1Imm5u8 (f-avc2-v1sub3u13 #x2) (f-avc2-v1sub4u0 #x1))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (sra avc2v1CRq avc2v1Imm5u8))
-)
- ())
-(dn16i csrli_avc2_v1 "csrli" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csrli"))
- "csrli $avc2v1CRq,$avc2v1Imm5u8"
-(+ avc2v1CRq avc2v1Imm5u8 (f-avc2-v1sub3u13 #x3) (f-avc2-v1sub4u0 #x1))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (srl avc2v1CRq avc2v1Imm5u8))
-)
- ())
-(dn16i cslli_avc2_v1 "cslli" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cslli"))
- "cslli $avc2v1CRq,$avc2v1Imm5u8"
-(+ avc2v1CRq avc2v1Imm5u8 (f-avc2-v1sub3u13 #x6) (f-avc2-v1sub4u0 #x1))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (sll avc2v1CRq avc2v1Imm5u8))
-)
- ())
-(dn16i cfsft_avc2_v1 "cfsft" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cfsft"))
- "cfsft $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xf) (f-avc2-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (subword SI (sll (or (sll (zext DI (zext SI avc2v1CRq)) 32) (zext DI avc2v1CRp)) (and QI (srl avc2copCCR0 0) #x3f)) 0))
-)
- ())
-(dn16i cfsfta0_avc2_v1 "cfsfta0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cfsfta0"))
- "cfsfta0 $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #x7) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u0 #x1))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (subword SI (sll (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (and QI (srl avc2copCCR0 0) #x3f)) 0))
-)
- ())
-(dn16i cfsfta1_avc2_v1 "cfsfta1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cfsfta1"))
- "cfsfta1 $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #xf) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u0 #x1))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v1CRq (subword SI (sll (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (and QI (srl avc2copCCR0 0) #x3f)) 0))
-)
- ())
-(dn16i cmula0_avc2_v1 "cmula0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmula0"))
- "cmula0 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x0) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat56)) (c-call "check_option_cp" pc)
-(set concat56 (mul (ext DI avc2v1CRq) (ext DI avc2v1CRp)))
-(set avc2copCCR2 (subword SI concat56 0))
-(set avc2copCCR3 (subword SI concat56 1))
-)
- ())
-(dn16i cmulua0_avc2_v1 "cmulua0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmulua0"))
- "cmulua0 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x1) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat57)) (c-call "check_option_cp" pc)
-(set concat57 (mul (zext DI avc2v1CRq) (zext DI avc2v1CRp)))
-(set avc2copCCR2 (subword SI concat57 0))
-(set avc2copCCR3 (subword SI concat57 1))
-)
- ())
-(dn16i cnmula0_avc2_v1 "cnmula0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cnmula0"))
- "cnmula0 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x2) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat58)) (c-call "check_option_cp" pc)
-(set concat58 (neg (mul (ext DI avc2v1CRq) (ext DI avc2v1CRp))))
-(set avc2copCCR2 (subword SI concat58 0))
-(set avc2copCCR3 (subword SI concat58 1))
-)
- ())
-(dn16i cmada0_avc2_v1 "cmada0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmada0"))
- "cmada0 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x4) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat59)) (c-call "check_option_cp" pc)
-(set concat59 (add (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (ext DI avc2v1CRq) (ext DI avc2v1CRp))))
-(set avc2copCCR2 (subword SI concat59 0))
-(set avc2copCCR3 (subword SI concat59 1))
-)
- ())
-(dn16i cmadua0_avc2_v1 "cmadua0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmadua0"))
- "cmadua0 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x5) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat60)) (c-call "check_option_cp" pc)
-(set concat60 (add (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (zext DI avc2v1CRq) (zext DI avc2v1CRp))))
-(set avc2copCCR2 (subword SI concat60 0))
-(set avc2copCCR3 (subword SI concat60 1))
-)
- ())
-(dn16i cmsba0_avc2_v1 "cmsba0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmsba0"))
- "cmsba0 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x6) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat61)) (c-call "check_option_cp" pc)
-(set concat61 (sub (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (ext DI avc2v1CRq) (ext DI avc2v1CRp))))
-(set avc2copCCR2 (subword SI concat61 0))
-(set avc2copCCR3 (subword SI concat61 1))
-)
- ())
-(dn16i cmsbua0_avc2_v1 "cmsbua0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmsbua0"))
- "cmsbua0 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x7) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat62)) (c-call "check_option_cp" pc)
-(set concat62 (sub (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (zext DI avc2v1CRq) (zext DI avc2v1CRp))))
-(set avc2copCCR2 (subword SI concat62 0))
-(set avc2copCCR3 (subword SI concat62 1))
-)
- ())
-(dn16i cmula1_avc2_v1 "cmula1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmula1"))
- "cmula1 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x8) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat63)) (c-call "check_option_cp" pc)
-(set concat63 (mul (ext DI avc2v1CRq) (ext DI avc2v1CRp)))
-(set avc2copCCR4 (subword SI concat63 0))
-(set avc2copCCR5 (subword SI concat63 1))
-)
- ())
-(dn16i cmulua1_avc2_v1 "cmulua1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmulua1"))
- "cmulua1 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x9) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat64)) (c-call "check_option_cp" pc)
-(set concat64 (mul (zext DI avc2v1CRq) (zext DI avc2v1CRp)))
-(set avc2copCCR4 (subword SI concat64 0))
-(set avc2copCCR5 (subword SI concat64 1))
-)
- ())
-(dn16i cnmula1_avc2_v1 "cnmula1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cnmula1"))
- "cnmula1 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xa) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat65)) (c-call "check_option_cp" pc)
-(set concat65 (neg (mul (ext DI avc2v1CRq) (ext DI avc2v1CRp))))
-(set avc2copCCR4 (subword SI concat65 0))
-(set avc2copCCR5 (subword SI concat65 1))
-)
- ())
-(dn16i cmada1_avc2_v1 "cmada1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmada1"))
- "cmada1 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xc) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat66)) (c-call "check_option_cp" pc)
-(set concat66 (add (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (ext DI avc2v1CRq) (ext DI avc2v1CRp))))
-(set avc2copCCR4 (subword SI concat66 0))
-(set avc2copCCR5 (subword SI concat66 1))
-)
- ())
-(dn16i cmadua1_avc2_v1 "cmadua1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmadua1"))
- "cmadua1 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xd) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat67)) (c-call "check_option_cp" pc)
-(set concat67 (add (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (zext DI avc2v1CRq) (zext DI avc2v1CRp))))
-(set avc2copCCR4 (subword SI concat67 0))
-(set avc2copCCR5 (subword SI concat67 1))
-)
- ())
-(dn16i cmsba1_avc2_v1 "cmsba1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmsba1"))
- "cmsba1 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xe) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat68)) (c-call "check_option_cp" pc)
-(set concat68 (sub (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (ext DI avc2v1CRq) (ext DI avc2v1CRp))))
-(set avc2copCCR4 (subword SI concat68 0))
-(set avc2copCCR5 (subword SI concat68 1))
-)
- ())
-(dn16i cmsbua1_avc2_v1 "cmsbua1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmsbua1"))
- "cmsbua1 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xf) (f-avc2-v1sub4u0 #x4))
-(sequence((DI concat69)) (c-call "check_option_cp" pc)
-(set concat69 (sub (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (zext DI avc2v1CRq) (zext DI avc2v1CRp))))
-(set avc2copCCR4 (subword SI concat69 0))
-(set avc2copCCR5 (subword SI concat69 1))
-)
- ())
-(dn16i cclipa0_avc2_v1 "cclipa0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cclipa0"))
- "cclipa0 $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #x0) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u0 #x6))
-(sequence((DI tmp_rslt)(DI min)(DI max)) (c-call "check_option_cp" pc)
-(set max #x000000007FFFFFFF)
-(set min #xFFFFFFFF80000000)
-(if (gt (ext DI (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3))) (ext DI max)) (set tmp_rslt max)
-(if (lt (ext DI (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3))) (ext DI min)) (set tmp_rslt min)
-(set tmp_rslt (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)))
-)
-)
-(set avc2v1CRq (subword SI tmp_rslt 1))
-)
- ())
-(dn16i cclipa1_avc2_v1 "cclipa1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cclipa1"))
- "cclipa1 $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #x1) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u0 #x6))
-(sequence((DI tmp_rslt)(DI min)(DI max)) (c-call "check_option_cp" pc)
-(set max #x000000007FFFFFFF)
-(set min #xFFFFFFFF80000000)
-(if (gt (ext DI (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5))) (ext DI max)) (set tmp_rslt max)
-(if (lt (ext DI (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5))) (ext DI min)) (set tmp_rslt min)
-(set tmp_rslt (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)))
-)
-)
-(set avc2v1CRq (subword SI tmp_rslt 1))
-)
- ())
-(dn16i cmvsla0i_avc2_v1 "cmvsla0i" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmvsla0i"))
- "cmvsla0i $avc2v1CRq,$avc2v1Imm6u8"
-(+ avc2v1CRq avc2v1Imm6u8 (f-avc2-v1sub2u14 #x2) (f-avc2-v1sub4u0 #xb))
-(sequence((DI concat70)) (c-call "check_option_cp" pc)
-(set concat70 (sll (ext DI avc2v1CRq) avc2v1Imm6u8))
-(set avc2copCCR2 (subword SI concat70 0))
-(set avc2copCCR3 (subword SI concat70 1))
-)
- ())
-(dn16i cmvsra0i_avc2_v1 "cmvsra0i" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmvsra0i"))
- "cmvsra0i $avc2v1CRq,$avc2v1Imm6u8"
-(+ avc2v1CRq avc2v1Imm6u8 (f-avc2-v1sub2u14 #x0) (f-avc2-v1sub4u0 #xb))
-(sequence((DI concat71)) (c-call "check_option_cp" pc)
-(set concat71 (sra (ext DI avc2v1CRq) avc2v1Imm6u8))
-(set avc2copCCR2 (subword SI concat71 0))
-(set avc2copCCR3 (subword SI concat71 1))
-)
- ())
-(dn16i cmvsla1i_avc2_v1 "cmvsla1i" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmvsla1i"))
- "cmvsla1i $avc2v1CRq,$avc2v1Imm6u8"
-(+ avc2v1CRq avc2v1Imm6u8 (f-avc2-v1sub2u14 #x3) (f-avc2-v1sub4u0 #xb))
-(sequence((DI concat72)) (c-call "check_option_cp" pc)
-(set concat72 (sll (ext DI avc2v1CRq) avc2v1Imm6u8))
-(set avc2copCCR4 (subword SI concat72 0))
-(set avc2copCCR5 (subword SI concat72 1))
-)
- ())
-(dn16i cmvsra1i_avc2_v1 "cmvsra1i" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmvsra1i"))
- "cmvsra1i $avc2v1CRq,$avc2v1Imm6u8"
-(+ avc2v1CRq avc2v1Imm6u8 (f-avc2-v1sub2u14 #x1) (f-avc2-v1sub4u0 #xb))
-(sequence((DI concat73)) (c-call "check_option_cp" pc)
-(set concat73 (sra (ext DI avc2v1CRq) avc2v1Imm6u8))
-(set avc2copCCR4 (subword SI concat73 0))
-(set avc2copCCR5 (subword SI concat73 1))
-)
- ())
-(dn16i csraa0i_avc2_v1 "csraa0i" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csraa0i"))
- "csraa0i $avc2v1Imm6u8"
-(+ avc2v1Imm6u8 (f-avc2-v1sub2u14 #x0) (f-avc2-v1sub4u4 #x0) (f-avc2-v1sub4u0 #x9))
-(sequence((DI concat74)) (c-call "check_option_cp" pc)
-(set concat74 (sra (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) avc2v1Imm6u8))
-(set avc2copCCR2 (subword SI concat74 0))
-(set avc2copCCR3 (subword SI concat74 1))
-)
- ())
-(dn16i csraa1i_avc2_v1 "csraa1i" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csraa1i"))
- "csraa1i $avc2v1Imm6u8"
-(+ avc2v1Imm6u8 (f-avc2-v1sub2u14 #x1) (f-avc2-v1sub4u4 #x0) (f-avc2-v1sub4u0 #x9))
-(sequence((DI concat75)) (c-call "check_option_cp" pc)
-(set concat75 (sra (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) avc2v1Imm6u8))
-(set avc2copCCR4 (subword SI concat75 0))
-(set avc2copCCR5 (subword SI concat75 1))
-)
- ())
-(dn16i csrla0i_avc2_v1 "csrla0i" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csrla0i"))
- "csrla0i $avc2v1Imm6u8"
-(+ avc2v1Imm6u8 (f-avc2-v1sub2u14 #x0) (f-avc2-v1sub4u4 #x1) (f-avc2-v1sub4u0 #x9))
-(sequence((DI concat76)) (c-call "check_option_cp" pc)
-(set concat76 (srl (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) avc2v1Imm6u8))
-(set avc2copCCR2 (subword SI concat76 0))
-(set avc2copCCR3 (subword SI concat76 1))
-)
- ())
-(dn16i csrla1i_avc2_v1 "csrla1i" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csrla1i"))
- "csrla1i $avc2v1Imm6u8"
-(+ avc2v1Imm6u8 (f-avc2-v1sub2u14 #x1) (f-avc2-v1sub4u4 #x1) (f-avc2-v1sub4u0 #x9))
-(sequence((DI concat77)) (c-call "check_option_cp" pc)
-(set concat77 (srl (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) avc2v1Imm6u8))
-(set avc2copCCR4 (subword SI concat77 0))
-(set avc2copCCR5 (subword SI concat77 1))
-)
- ())
-(dn16i cslla0i_avc2_v1 "cslla0i" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cslla0i"))
- "cslla0i $avc2v1Imm6u8"
-(+ avc2v1Imm6u8 (f-avc2-v1sub2u14 #x0) (f-avc2-v1sub4u4 #x3) (f-avc2-v1sub4u0 #x9))
-(sequence((DI concat78)) (c-call "check_option_cp" pc)
-(set concat78 (sll (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) avc2v1Imm6u8))
-(set avc2copCCR2 (subword SI concat78 0))
-(set avc2copCCR3 (subword SI concat78 1))
-)
- ())
-(dn16i cslla1i_avc2_v1 "cslla1i" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cslla1i"))
- "cslla1i $avc2v1Imm6u8"
-(+ avc2v1Imm6u8 (f-avc2-v1sub2u14 #x1) (f-avc2-v1sub4u4 #x3) (f-avc2-v1sub4u0 #x9))
-(sequence((DI concat79)) (c-call "check_option_cp" pc)
-(set concat79 (sll (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) avc2v1Imm6u8))
-(set avc2copCCR4 (subword SI concat79 0))
-(set avc2copCCR5 (subword SI concat79 1))
-)
- ())
-(dn16i csraa0_avc2_v1 "csraa0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csraa0"))
- "csraa0"
-(+ (f-avc2-v1sub4u12 #x0) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u4 #xc) (f-avc2-v1sub4u0 #x9))
-(sequence((DI concat80)) (c-call "check_option_cp" pc)
-(set concat80 (sra (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) (and QI (srl avc2copCCR0 0) #x3f)))
-(set avc2copCCR2 (subword SI concat80 0))
-(set avc2copCCR3 (subword SI concat80 1))
-)
- ())
-(dn16i csraa1_avc2_v1 "csraa1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csraa1"))
- "csraa1"
-(+ (f-avc2-v1sub4u12 #x1) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u4 #xc) (f-avc2-v1sub4u0 #x9))
-(sequence((DI concat81)) (c-call "check_option_cp" pc)
-(set concat81 (sra (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (and QI (srl avc2copCCR0 0) #x3f)))
-(set avc2copCCR4 (subword SI concat81 0))
-(set avc2copCCR5 (subword SI concat81 1))
-)
- ())
-(dn16i csrla0_avc2_v1 "csrla0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csrla0"))
- "csrla0"
-(+ (f-avc2-v1sub4u12 #x0) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u4 #xd) (f-avc2-v1sub4u0 #x9))
-(sequence((DI concat82)) (c-call "check_option_cp" pc)
-(set concat82 (srl (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) (and QI (srl avc2copCCR0 0) #x3f)))
-(set avc2copCCR2 (subword SI concat82 0))
-(set avc2copCCR3 (subword SI concat82 1))
-)
- ())
-(dn16i csrla1_avc2_v1 "csrla1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csrla1"))
- "csrla1"
-(+ (f-avc2-v1sub4u12 #x1) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u4 #xd) (f-avc2-v1sub4u0 #x9))
-(sequence((DI concat83)) (c-call "check_option_cp" pc)
-(set concat83 (srl (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (and QI (srl avc2copCCR0 0) #x3f)))
-(set avc2copCCR4 (subword SI concat83 0))
-(set avc2copCCR5 (subword SI concat83 1))
-)
- ())
-(dn16i cslla0_avc2_v1 "cslla0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cslla0"))
- "cslla0"
-(+ (f-avc2-v1sub4u12 #x0) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u4 #xf) (f-avc2-v1sub4u0 #x9))
-(sequence((DI concat84)) (c-call "check_option_cp" pc)
-(set concat84 (sll (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) (and QI (srl avc2copCCR0 0) #x3f)))
-(set avc2copCCR2 (subword SI concat84 0))
-(set avc2copCCR3 (subword SI concat84 1))
-)
- ())
-(dn16i cslla1_avc2_v1 "cslla1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cslla1"))
- "cslla1"
-(+ (f-avc2-v1sub4u12 #x1) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u4 #xf) (f-avc2-v1sub4u0 #x9))
-(sequence((DI concat85)) (c-call "check_option_cp" pc)
-(set concat85 (sll (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (and QI (srl avc2copCCR0 0) #x3f)))
-(set avc2copCCR4 (subword SI concat85 0))
-(set avc2copCCR5 (subword SI concat85 1))
-)
- ())
-(dn16i cadda0_avc2_v1 "cadda0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cadda0"))
- "cadda0 $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #x0) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u0 #x8))
-(sequence((DI concat86)) (c-call "check_option_cp" pc)
-(set concat86 (add (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) (ext DI avc2v1CRq)))
-(set avc2copCCR2 (subword SI concat86 0))
-(set avc2copCCR3 (subword SI concat86 1))
-)
- ())
-(dn16i cadda1_avc2_v1 "cadda1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cadda1"))
- "cadda1 $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #x1) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u0 #x8))
-(sequence((DI concat87)) (c-call "check_option_cp" pc)
-(set concat87 (add (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (ext DI avc2v1CRq)))
-(set avc2copCCR4 (subword SI concat87 0))
-(set avc2copCCR5 (subword SI concat87 1))
-)
- ())
-(dn16i csuba0_avc2_v1 "csuba0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csuba0"))
- "csuba0 $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #x2) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u0 #x8))
-(sequence((DI concat88)) (c-call "check_option_cp" pc)
-(set concat88 (sub (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3)) (ext DI avc2v1CRq)))
-(set avc2copCCR2 (subword SI concat88 0))
-(set avc2copCCR3 (subword SI concat88 1))
-)
- ())
-(dn16i csuba1_avc2_v1 "csuba1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csuba1"))
- "csuba1 $avc2v1CRq"
-(+ avc2v1CRq (f-avc2-v1sub4u12 #x3) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u0 #x8))
-(sequence((DI concat89)) (c-call "check_option_cp" pc)
-(set concat89 (sub (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (ext DI avc2v1CRq)))
-(set avc2copCCR4 (subword SI concat89 0))
-(set avc2copCCR5 (subword SI concat89 1))
-)
- ())
-(dn16i cadd2a0_avc2_v1 "cadd2a0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cadd2a0"))
- "cadd2a0 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x8) (f-avc2-v1sub4u0 #x8))
-(sequence((DI concat90)) (c-call "check_option_cp" pc)
-(set concat90 (add (ext DI avc2v1CRq) (ext DI avc2v1CRp)))
-(set avc2copCCR2 (subword SI concat90 0))
-(set avc2copCCR3 (subword SI concat90 1))
-)
- ())
-(dn16i cadd2a1_avc2_v1 "cadd2a1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cadd2a1"))
- "cadd2a1 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #x9) (f-avc2-v1sub4u0 #x8))
-(sequence((DI concat91)) (c-call "check_option_cp" pc)
-(set concat91 (add (ext DI avc2v1CRq) (ext DI avc2v1CRp)))
-(set avc2copCCR4 (subword SI concat91 0))
-(set avc2copCCR5 (subword SI concat91 1))
-)
- ())
-(dn16i csub2a0_avc2_v1 "csub2a0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csub2a0"))
- "csub2a0 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xa) (f-avc2-v1sub4u0 #x8))
-(sequence((DI concat92)) (c-call "check_option_cp" pc)
-(set concat92 (sub (ext DI avc2v1CRq) (ext DI avc2v1CRp)))
-(set avc2copCCR2 (subword SI concat92 0))
-(set avc2copCCR3 (subword SI concat92 1))
-)
- ())
-(dn16i csub2a1_avc2_v1 "csub2a1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csub2a1"))
- "csub2a1 $avc2v1CRq,$avc2v1CRp"
-(+ avc2v1CRq avc2v1CRp (f-avc2-v1sub4u12 #xb) (f-avc2-v1sub4u0 #x8))
-(sequence((DI concat93)) (c-call "check_option_cp" pc)
-(set concat93 (sub (ext DI avc2v1CRq) (ext DI avc2v1CRp)))
-(set avc2copCCR4 (subword SI concat93 0))
-(set avc2copCCR5 (subword SI concat93 1))
-)
- ())
-(dn16i caddaa0_avc2_v1 "caddaa0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "caddaa0"))
- "caddaa0"
-(+ (f-avc2-v1sub4u12 #x0) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u4 #x0) (f-avc2-v1sub4u0 #xa))
-(sequence((DI concat94)) (c-call "check_option_cp" pc)
-(set concat94 (add (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3))))
-(set avc2copCCR2 (subword SI concat94 0))
-(set avc2copCCR3 (subword SI concat94 1))
-)
- ())
-(dn16i caddaa1_avc2_v1 "caddaa1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "caddaa1"))
- "caddaa1"
-(+ (f-avc2-v1sub4u12 #x1) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u4 #x0) (f-avc2-v1sub4u0 #xa))
-(sequence((DI concat95)) (c-call "check_option_cp" pc)
-(set concat95 (add (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3))))
-(set avc2copCCR4 (subword SI concat95 0))
-(set avc2copCCR5 (subword SI concat95 1))
-)
- ())
-(dn16i csubaa0_avc2_v1 "csubaa0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csubaa0"))
- "csubaa0"
-(+ (f-avc2-v1sub4u12 #x2) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u4 #x0) (f-avc2-v1sub4u0 #xa))
-(sequence((DI concat96)) (c-call "check_option_cp" pc)
-(set concat96 (sub (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3))))
-(set avc2copCCR2 (subword SI concat96 0))
-(set avc2copCCR3 (subword SI concat96 1))
-)
- ())
-(dn16i csubaa1_avc2_v1 "csubaa1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csubaa1"))
- "csubaa1"
-(+ (f-avc2-v1sub4u12 #x3) (f-avc2-v1sub4u8 #x0) (f-avc2-v1sub4u4 #x0) (f-avc2-v1sub4u0 #xa))
-(sequence((DI concat97)) (c-call "check_option_cp" pc)
-(set concat97 (sub (or (sll (zext DI avc2copCCR4) 32) (zext DI avc2copCCR5)) (or (sll (zext DI avc2copCCR2) 32) (zext DI avc2copCCR3))))
-(set avc2copCCR4 (subword SI concat97 0))
-(set avc2copCCR5 (subword SI concat97 1))
-)
- ())
-(dn32i cmov1_avc2_v3 "cmov1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "cmov1"))
- "cmov $avc2v3CRn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3CRn avc2v3Rm (f-avc2-v3sub4u28 #x0) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v3CRn avc2v3Rm)
-)
- ())
-(dn32i cmov2_avc2_v3 "cmov2" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "cmov2"))
- "cmov $avc2v3Rm,$avc2v3CRn"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rm avc2v3CRn (f-avc2-v3sub4u28 #x1) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v3Rm avc2v3CRn)
-)
- ())
-(dn32i cmovi_avc2_v3 "cmovi" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "cmovi"))
- "cmovi $avc2v3CRq,$avc2v3Imm16s4x24e32"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3CRq avc2v3Imm16s4x24e32 (f-avc2-v3sub4u16 #xe))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v3CRq (ext SI avc2v3Imm16s4x24e32))
-)
- ())
-(dn32i cmovc1_avc2_v3 "cmovc1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "cmovc1"))
- "cmovc $avc2v3CCRn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3CCRn avc2v3Rm (f-avc2-v3sub4u28 #x2) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v3CCRn avc2v3Rm)
-)
- ())
-(dn32i cmovc2_avc2_v3 "cmovc2" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "cmovc2"))
- "cmovc $avc2v3Rm,$avc2v3CCRn"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rm avc2v3CCRn (f-avc2-v3sub4u28 #x3) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avc2v3Rm avc2v3CCRn)
-)
- ())
-(dn32i xmula0_avc2_v3 "xmula0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmula0"))
- "xmula0 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #x0) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat98)) (c-call "check_option_cp" pc)
-(set concat98 (mul (ext DI avc2v3Rn) (ext DI avc2v3Rm)))
-(set avc2copCCR2 (subword SI concat98 0))
-(set avc2copCCR3 (subword SI concat98 1))
-)
- ())
-(dn32i xmulua0_avc2_v3 "xmulua0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmulua0"))
- "xmulua0 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #x1) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat99)) (c-call "check_option_cp" pc)
-(set concat99 (mul (zext DI avc2v3Rn) (zext DI avc2v3Rm)))
-(set avc2copCCR2 (subword SI concat99 0))
-(set avc2copCCR3 (subword SI concat99 1))
-)
- ())
-(dn32i xnmula0_avc2_v3 "xnmula0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xnmula0"))
- "xnmula0 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #x2) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat100)) (c-call "check_option_cp" pc)
-(set concat100 (neg (mul (ext DI avc2v3Rn) (ext DI avc2v3Rm))))
-(set avc2copCCR2 (subword SI concat100 0))
-(set avc2copCCR3 (subword SI concat100 1))
-)
- ())
-(dn32i xmada0_avc2_v3 "xmada0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmada0"))
- "xmada0 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #x4) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat101)) (c-call "check_option_cp" pc)
-(set concat101 (add (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (ext DI avc2v3Rn) (ext DI avc2v3Rm))))
-(set avc2copCCR2 (subword SI concat101 0))
-(set avc2copCCR3 (subword SI concat101 1))
-)
- ())
-(dn32i xmadua0_avc2_v3 "xmadua0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmadua0"))
- "xmadua0 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #x5) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat102)) (c-call "check_option_cp" pc)
-(set concat102 (add (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (zext DI avc2v3Rn) (zext DI avc2v3Rm))))
-(set avc2copCCR2 (subword SI concat102 0))
-(set avc2copCCR3 (subword SI concat102 1))
-)
- ())
-(dn32i xmsba0_avc2_v3 "xmsba0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmsba0"))
- "xmsba0 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #x6) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat103)) (c-call "check_option_cp" pc)
-(set concat103 (sub (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (ext DI avc2v3Rn) (ext DI avc2v3Rm))))
-(set avc2copCCR2 (subword SI concat103 0))
-(set avc2copCCR3 (subword SI concat103 1))
-)
- ())
-(dn32i xmsbua0_avc2_v3 "xmsbua0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmsbua0"))
- "xmsbua0 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #x7) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat104)) (c-call "check_option_cp" pc)
-(set concat104 (sub (or (sll (zext DI (zext SI avc2copCCR2)) 32) (zext DI avc2copCCR3)) (mul (zext DI avc2v3Rn) (zext DI avc2v3Rm))))
-(set avc2copCCR2 (subword SI concat104 0))
-(set avc2copCCR3 (subword SI concat104 1))
-)
- ())
-(dn32i xmula1_avc2_v3 "xmula1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmula1"))
- "xmula1 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #x8) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat105)) (c-call "check_option_cp" pc)
-(set concat105 (mul (ext DI avc2v3Rn) (ext DI avc2v3Rm)))
-(set avc2copCCR4 (subword SI concat105 0))
-(set avc2copCCR5 (subword SI concat105 1))
-)
- ())
-(dn32i xmulua1_avc2_v3 "xmulua1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmulua1"))
- "xmulua1 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #x9) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat106)) (c-call "check_option_cp" pc)
-(set concat106 (mul (zext DI avc2v3Rn) (zext DI avc2v3Rm)))
-(set avc2copCCR4 (subword SI concat106 0))
-(set avc2copCCR5 (subword SI concat106 1))
-)
- ())
-(dn32i xnmula1_avc2_v3 "xnmula1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xnmula1"))
- "xnmula1 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #xa) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat107)) (c-call "check_option_cp" pc)
-(set concat107 (neg (mul (ext DI avc2v3Rn) (ext DI avc2v3Rm))))
-(set avc2copCCR4 (subword SI concat107 0))
-(set avc2copCCR5 (subword SI concat107 1))
-)
- ())
-(dn32i xmada1_avc2_v3 "xmada1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmada1"))
- "xmada1 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #xc) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat108)) (c-call "check_option_cp" pc)
-(set concat108 (add (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (ext DI avc2v3Rn) (ext DI avc2v3Rm))))
-(set avc2copCCR4 (subword SI concat108 0))
-(set avc2copCCR5 (subword SI concat108 1))
-)
- ())
-(dn32i xmadua1_avc2_v3 "xmadua1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmadua1"))
- "xmadua1 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #xd) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat109)) (c-call "check_option_cp" pc)
-(set concat109 (add (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (zext DI avc2v3Rn) (zext DI avc2v3Rm))))
-(set avc2copCCR4 (subword SI concat109 0))
-(set avc2copCCR5 (subword SI concat109 1))
-)
- ())
-(dn32i xmsba1_avc2_v3 "xmsba1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmsba1"))
- "xmsba1 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #xe) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat110)) (c-call "check_option_cp" pc)
-(set concat110 (sub (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (ext DI avc2v3Rn) (ext DI avc2v3Rm))))
-(set avc2copCCR4 (subword SI concat110 0))
-(set avc2copCCR5 (subword SI concat110 1))
-)
- ())
-(dn32i xmsbua1_avc2_v3 "xmsbua1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmsbua1"))
- "xmsbua1 $avc2v3Rn,$avc2v3Rm"
-(+ (f-avc2-v3sub4u0 #xf) (f-avc2-v3sub4u12 #x7) avc2v3Rn avc2v3Rm (f-avc2-v3sub4u28 #xf) (f-avc2-v3sub4u24 #x0) (f-avc2-v3sub4u20 #x0) (f-avc2-v3sub4u16 #xc))
-(sequence((DI concat111)) (c-call "check_option_cp" pc)
-(set concat111 (sub (or (sll (zext DI (zext SI avc2copCCR4)) 32) (zext DI avc2copCCR5)) (mul (zext DI avc2v3Rn) (zext DI avc2v3Rm))))
-(set avc2copCCR4 (subword SI concat111 0))
-(set avc2copCCR5 (subword SI concat111 1))
-)
- ())
diff -rupN binutils-2.19.1-original/cgen/cpu/mep-avc.cpu binutils-2.19.1/cgen/cpu/mep-avc.cpu
--- binutils-2.19.1-original/cgen/cpu/mep-avc.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/mep-avc.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,1424 +0,0 @@
-;
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-; This file was customized based upon the output of a2cgen 0.42
-
-;------------------------------------------------------------------------------
-; MeP-Integrator will redefine the isa pmacros below to allow the bit widths
-; specified below for each ME_MODULE using this coprocessor.
-; This coprocessor requires 16 and 32 bit insns.
-;------------------------------------------------------------------------------
-; begin-isas
-(define-pmacro avc-core-isa () (ISA ext_core1))
-(define-pmacro avc-16-isa   () (ISA ext_cop1_16))
-(define-pmacro avc-32-isa   () (ISA ext_cop1_32))
-(define-pmacro all-avc-isas () (ISA ext_core1,ext_cop1_16,ext_cop1_32))
-; end-isas
-
-(define-pmacro (dncpi xname xcomment xattrs xsyntax xformat xsemantics xtiming)
-   (dni xname xcomment (.splice (.unsplice xattrs) avc-core-isa) xsyntax xformat xsemantics xtiming))
-(define-pmacro (dn16i xname xcomment xattrs xsyntax xformat xsemantics xtiming)
-   (dni xname xcomment (.splice (.unsplice xattrs) avc-16-isa) xsyntax xformat xsemantics xtiming))
-(define-pmacro (dn32i xname xcomment xattrs xsyntax xformat xsemantics xtiming)
-   (dni xname xcomment (.splice (.unsplice xattrs) avc-32-isa) xsyntax xformat xsemantics xtiming))
-
-; register definitions
-; ---------------------
-; NOTE: This exists solely for the purpose of providing the proper register names for this coprocessor.
-; GDB will use the hardware table generated from this declaration. The operands use h-cr
-; from mep-core.cpu so that SID's semantic trace will be consistent between
-; the core and the coprocessor but use parse/print handlers which reference the hardware table
-; generated from this declarations
-(define-hardware
-  (name h-cr-avc)
-  (comment "32-bit coprocessor registers for avc coprocessor")
-  (attrs VIRTUAL all-avc-isas)
-  (type register SI (32))
-  (set (index newval) (c-call VOID "h_cr64_set" index (ext DI newval)))
-  (get (index) (trunc SI (c-call DI "h_cr64_get" index)))
-  (indices keyword "$c" (.map -reg-pair (.iota 8)))
-)
-; NOTE: This exists solely for the purpose of providing the proper register names for this coprocessor.
-; GDB will use the hardware table generated from this declaration. The operands use h-ccr
-; from mep-core.cpu so that SID's semantic trace will be consistent between
-; the core and the coprocessor but use parse/print handlers which reference the hardware table
-; generated from this declarations
-(define-hardware
-  (name h-ccr-avc)
-  (comment "Coprocessor control registers for avc coprocessor")
-  (attrs VIRTUAL all-avc-isas)
-  (type register SI (64))
-  (set (index newval) (c-call VOID "h_ccr_set" index newval))
-  (get (index) (c-call SI "h_ccr_get" index))
-  (indices keyword ""
-	(.splice
-        ($accl1 5) ($acch1 4) ($accl0 3) ($acch0 2) ($CBCR 1) ($csar 0) 
-        ($cbcr 1) 
-		(.unsplice (.map -ccr-reg-pair (.iota 6)))
-        )
-  )
-)
-(dnop avccopCCR5 "Audio Copro Accumulator" (all-avc-isas) h-ccr 5)
-(dnop avccopCCR4 "Audio Copro Accumulator" (all-avc-isas) h-ccr 4)
-(dnop avccopCCR3 "Audio Copro Accumulator" (all-avc-isas) h-ccr 3)
-(dnop avccopCCR2 "Audio Copro Accumulator" (all-avc-isas) h-ccr 2)
-(dnop avccopCCR1 "Audio Copro Branch Condition Register" (all-avc-isas) h-ccr 1)
-(dnop avccopCCR0 "Audio Copro Shift-Amount Register" (all-avc-isas) h-ccr 0)
-
-; instruction field and operand definitions
-(dnf f-avc-v3sub4u0 "sub opecode field" (avc-32-isa) 0 4)
-(dnf f-avc-v1sub4u0 "sub opecode field" (avc-16-isa) 0 4)
-(dnf f-avc-v3Rn "register field" (avc-32-isa) 4 4)
-(dnop avcv3Rn "the operand definition" (avc-32-isa) h-gpr f-avc-v3Rn)
-(dnf f-avc-v3CCRn "register field" (avc-32-isa) 4 4)
-(define-full-operand avcv3CCRn "the operand definition" (avc-32-isa (CDATA REGNUM)) h-ccr DFLT f-avc-v3CCRn ( (parse "avc_ccr") (print "avc_ccr")) () ())
-(df f-avc-v3Imm16s4x24e32-hi "split immediate field hi" (avc-32-isa) 4 8 INT #f #f)
-(df f-avc-v3Imm16s4x24e32-lo "split immediate field lo" (avc-32-isa) 24 8 UINT #f #f)
-(define-multi-ifield
- (name f-avc-v3Imm16s4x24e32)
- (comment "split immediate field")
- (attrs avc-32-isa)
- (mode INT)
- (subfields f-avc-v3Imm16s4x24e32-hi f-avc-v3Imm16s4x24e32-lo)
- (insert (sequence ()
-    (set (ifield f-avc-v3Imm16s4x24e32-hi) (sra INT (ifield f-avc-v3Imm16s4x24e32) 8))
-    (set (ifield f-avc-v3Imm16s4x24e32-lo) (and (ifield f-avc-v3Imm16s4x24e32) #xff))))
- (extract (set (ifield f-avc-v3Imm16s4x24e32)
-    (or (sll (ifield f-avc-v3Imm16s4x24e32-hi) 8) (ifield f-avc-v3Imm16s4x24e32-lo))))
- )
-(dnop avcv3Imm16s4x24e32 "the operand definition" (avc-32-isa) h-sint f-avc-v3Imm16s4x24e32)
-(dnf f-avc-v3CRn "register field" (avc-32-isa) 4 4)
-(define-full-operand avcv3CRn "the operand definition" (avc-32-isa) h-cr DFLT f-avc-v3CRn ((parse "avc_cr") (print "avc_cr")) () ())
-(dnf f-avc-v1CRq "register field" (avc-16-isa) 4 4)
-(define-full-operand avcv1CRq "the operand definition" (avc-16-isa) h-cr DFLT f-avc-v1CRq ((parse "avc_cr") (print "avc_cr")) () ())
-(dnf f-avc-v1sub4u4 "sub opecode field" (avc-16-isa) 4 4)
-(dnf f-avc-c3Rn "register field" (avc-core-isa) 4 4)
-(dnop avcc3Rn "the operand definition" (avc-core-isa) h-gpr f-avc-c3Rn)
-(dnf f-avc-c3CCRn "register field" (avc-core-isa) 4 4)
-(define-full-operand avcc3CCRn "the operand definition" (avc-core-isa (CDATA REGNUM)) h-ccr DFLT f-avc-c3CCRn ( (parse "avc_ccr") (print "avc_ccr")) () ())
-(df f-avc-c3Imm16s4x24e32-hi "split immediate field hi" (avc-core-isa) 4 8 INT #f #f)
-(df f-avc-c3Imm16s4x24e32-lo "split immediate field lo" (avc-core-isa) 24 8 UINT #f #f)
-(define-multi-ifield
- (name f-avc-c3Imm16s4x24e32)
- (comment "split immediate field")
- (attrs avc-core-isa)
- (mode INT)
- (subfields f-avc-c3Imm16s4x24e32-hi f-avc-c3Imm16s4x24e32-lo)
- (insert (sequence ()
-    (set (ifield f-avc-c3Imm16s4x24e32-hi) (sra INT (ifield f-avc-c3Imm16s4x24e32) 8))
-    (set (ifield f-avc-c3Imm16s4x24e32-lo) (and (ifield f-avc-c3Imm16s4x24e32) #xff))))
- (extract (set (ifield f-avc-c3Imm16s4x24e32)
-    (or (sll (ifield f-avc-c3Imm16s4x24e32-hi) 8) (ifield f-avc-c3Imm16s4x24e32-lo))))
- )
-(dnop avcc3Imm16s4x24e32 "the operand definition" (avc-core-isa) h-sint f-avc-c3Imm16s4x24e32)
-(dnf f-avc-c3CRn "register field" (avc-core-isa) 4 4)
-(define-full-operand avcc3CRn "the operand definition" (avc-core-isa) h-cr DFLT f-avc-c3CRn ((parse "avc_cr") (print "avc_cr")) () ())
-(dnf f-avc-c3sub4u4 "sub opecode field" (avc-core-isa) 4 4)
-(dnf f-avc-v3Rm "register field" (avc-32-isa) 8 4)
-(dnop avcv3Rm "the operand definition" (avc-32-isa) h-gpr f-avc-v3Rm)
-(df f-avc-v1Imm5u8 "immediate field" (avc-16-isa) 8 5 UINT #f #f)
-(dnop avcv1Imm5u8 "the operand definition" (avc-16-isa) h-uint f-avc-v1Imm5u8)
-(df f-avc-v1Imm6s8 "immediate field" (avc-16-isa) 8 6 INT #f #f)
-(dnop avcv1Imm6s8 "the operand definition" (avc-16-isa) h-sint f-avc-v1Imm6s8)
-(df f-avc-v1Imm8s8 "immediate field" (avc-16-isa) 8 8 INT #f #f)
-(dnop avcv1Imm8s8 "the operand definition" (avc-16-isa) h-sint f-avc-v1Imm8s8)
-(dnf f-avc-v1CRp "register field" (avc-16-isa) 8 4)
-(define-full-operand avcv1CRp "the operand definition" (avc-16-isa) h-cr DFLT f-avc-v1CRp ((parse "avc_cr") (print "avc_cr")) () ())
-(dnf f-avc-v1sub4u8 "sub opecode field" (avc-16-isa) 8 4)
-(dnf f-avc-c3Rm "register field" (avc-core-isa) 8 4)
-(dnop avcc3Rm "the operand definition" (avc-core-isa) h-gpr f-avc-c3Rm)
-(dnf f-avc-c3sub4u8 "sub opecode field" (avc-core-isa) 8 4)
-(dnf f-avc-v3sub4u12 "sub opecode field" (avc-32-isa) 12 4)
-(dnf f-avc-v1CRo "register field" (avc-16-isa) 12 4)
-(define-full-operand avcv1CRo "the operand definition" (avc-16-isa) h-cr DFLT f-avc-v1CRo ((parse "avc_cr") (print "avc_cr")) () ())
-(dnf f-avc-v1sub4u12 "sub opecode field" (avc-16-isa) 12 4)
-(dnf f-avc-v1sub3u13 "sub opecode field" (avc-16-isa) 13 3)
-(dnf f-avc-v1sub2u14 "sub opecode field" (avc-16-isa) 14 2)
-(dnf f-avc-v3sub4u16 "sub opecode field" (avc-32-isa) 16 4)
-(dnf f-avc-c3sub4u16 "sub opecode field" (avc-core-isa) 16 4)
-(dnf f-avc-v3CRq "register field" (avc-32-isa) 20 4)
-(define-full-operand avcv3CRq "the operand definition" (avc-32-isa) h-cr DFLT f-avc-v3CRq ((parse "avc_cr") (print "avc_cr")) () ())
-(dnf f-avc-v3sub4u20 "sub opecode field" (avc-32-isa) 20 4)
-(dnf f-avc-c3CRq "register field" (avc-core-isa) 20 4)
-(define-full-operand avcc3CRq "the operand definition" (avc-core-isa) h-cr DFLT f-avc-c3CRq ((parse "avc_cr") (print "avc_cr")) () ())
-(dnf f-avc-c3sub4u20 "sub opecode field" (avc-core-isa) 20 4)
-(dnf f-avc-v3sub4u24 "sub opecode field" (avc-32-isa) 24 4)
-(df f-avc-c3Imm5u24 "immediate field" (avc-core-isa) 24 5 UINT #f #f)
-(dnop avcc3Imm5u24 "the operand definition" (avc-core-isa) h-uint f-avc-c3Imm5u24)
-(df f-avc-c3Imm6s24 "immediate field" (avc-core-isa) 24 6 INT #f #f)
-(dnop avcc3Imm6s24 "the operand definition" (avc-core-isa) h-sint f-avc-c3Imm6s24)
-(dnf f-avc-c3CRp "register field" (avc-core-isa) 24 4)
-(define-full-operand avcc3CRp "the operand definition" (avc-core-isa) h-cr DFLT f-avc-c3CRp ((parse "avc_cr") (print "avc_cr")) () ())
-(dnf f-avc-c3sub4u24 "sub opecode field" (avc-core-isa) 24 4)
-(dnf f-avc-v3sub4u28 "sub opecode field" (avc-32-isa) 28 4)
-(dnf f-avc-c3CRo "register field" (avc-core-isa) 28 4)
-(define-full-operand avcc3CRo "the operand definition" (avc-core-isa) h-cr DFLT f-avc-c3CRo ((parse "avc_cr") (print "avc_cr")) () ())
-(dnf f-avc-c3sub4u28 "sub opecode field" (avc-core-isa) 28 4)
-(dnf f-avc-c3sub3u29 "sub opecode field" (avc-core-isa) 29 3)
-(dnf f-avc-c3sub2u30 "sub opecode field" (avc-core-isa) 30 2)
-
-; instruction definitions
-(dncpi cnop_avc_c3 "cnop" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cnop"))
- "cnop"
-(+ MAJ_15 (f-sub4 7) (f-avc-c3sub4u28 #x0) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(c-call "check_option_cp" pc)
- ())
-(dncpi cmov1_avc_c3 "cmov1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmov1"))
- "cmov $avcc3CRn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3CRn avcc3Rm (f-avc-c3sub4u28 #x0) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRn avcc3Rm)
-)
- ())
-(dncpi cmov2_avc_c3 "cmov2" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmov2"))
- "cmov $avcc3Rm,$avcc3CRn"
-(+ MAJ_15 (f-sub4 7) avcc3Rm avcc3CRn (f-avc-c3sub4u28 #x1) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3Rm avcc3CRn)
-)
- ())
-(dncpi cmovi_avc_c3 "cmovi" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmovi"))
- "cmovi $avcc3CRq,$avcc3Imm16s4x24e32"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3Imm16s4x24e32 (f-avc-c3sub4u16 #xe))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (ext SI avcc3Imm16s4x24e32))
-)
- ())
-(dncpi cmovc1_avc_c3 "cmovc1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmovc1"))
- "cmovc $avcc3CCRn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3CCRn avcc3Rm (f-avc-c3sub4u28 #x2) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CCRn avcc3Rm)
-)
- ())
-(dncpi cmovc2_avc_c3 "cmovc2" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmovc2"))
- "cmovc $avcc3Rm,$avcc3CCRn"
-(+ MAJ_15 (f-sub4 7) avcc3Rm avcc3CCRn (f-avc-c3sub4u28 #x3) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3Rm avcc3CCRn)
-)
- ())
-(dncpi cmov_avc_c3 "cmov" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmov"))
- "cmov $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x3) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq avcc3CRp)
-)
- ())
-(dncpi cadd3_avc_c3 "cadd3" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cadd3"))
- "cadd3 $avcc3CRo,$avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRo avcc3CRq avcc3CRp (f-avc-c3sub4u16 #x3) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRo (add avcc3CRq avcc3CRp))
-)
- ())
-(dncpi caddi_avc_c3 "caddi" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "caddi"))
- "caddi $avcc3CRq,$avcc3Imm6s24"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3Imm6s24 (f-avc-c3sub2u30 #x0) (f-avc-c3sub4u16 #x1) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (add avcc3CRq (ext SI avcc3Imm6s24)))
-)
- ())
-(dncpi csub_avc_c3 "csub" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csub"))
- "csub $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x2) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (sub avcc3CRq avcc3CRp))
-)
- ())
-(dncpi cneg_avc_c3 "cneg" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cneg"))
- "cneg $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x1) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (neg avcc3CRp))
-)
- ())
-(dncpi cextb_avc_c3 "cextb" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cextb"))
- "cextb $avcc3CRq"
-(+ MAJ_15 (f-sub4 7) avcc3CRq (f-avc-c3sub4u28 #x9) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (ext SI (and QI (srl avcc3CRq 0) #xff)))
-)
- ())
-(dncpi cexth_avc_c3 "cexth" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cexth"))
- "cexth $avcc3CRq"
-(+ MAJ_15 (f-sub4 7) avcc3CRq (f-avc-c3sub4u28 #x9) (f-avc-c3sub4u24 #x2) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (ext SI (and HI (srl avcc3CRq 0) #xffff)))
-)
- ())
-(dncpi cextub_avc_c3 "cextub" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cextub"))
- "cextub $avcc3CRq"
-(+ MAJ_15 (f-sub4 7) avcc3CRq (f-avc-c3sub4u28 #x9) (f-avc-c3sub4u24 #x8) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (zext SI (and QI (srl avcc3CRq 0) #xff)))
-)
- ())
-(dncpi cextuh_avc_c3 "cextuh" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cextuh"))
- "cextuh $avcc3CRq"
-(+ MAJ_15 (f-sub4 7) avcc3CRq (f-avc-c3sub4u28 #x9) (f-avc-c3sub4u24 #xa) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (zext SI (and HI (srl avcc3CRq 0) #xffff)))
-)
- ())
-(dncpi cscltz_avc_c3 "cscltz" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cscltz"))
- "cscltz $avcc3CRq"
-(+ MAJ_15 (f-sub4 7) avcc3CRq (f-avc-c3sub4u28 #xa) (f-avc-c3sub4u24 #xa) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (lt (ext SI avcc3CRq) (ext SI 0)) (set avccopCCR1 (or (sll (srl avccopCCR1 1) 1) (srl (sll (zext SI 1) 31) 31)))
-(set avccopCCR1 (or (sll (srl avccopCCR1 1) 1) (srl (sll (zext SI 0) 31) 31)))
-)
-)
- ())
-(dncpi cldz_avc_c3 "cldz" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cldz"))
- "cldz $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x0) (f-avc-c3sub4u16 #x5) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (and avcc3CRp #x80000000) (set avcc3CRq 0)
-(if (and avcc3CRp #x40000000) (set avcc3CRq 1)
-(if (and avcc3CRp #x20000000) (set avcc3CRq 2)
-(if (and avcc3CRp #x10000000) (set avcc3CRq 3)
-(if (and avcc3CRp #x8000000) (set avcc3CRq 4)
-(if (and avcc3CRp #x4000000) (set avcc3CRq 5)
-(if (and avcc3CRp #x2000000) (set avcc3CRq 6)
-(if (and avcc3CRp #x1000000) (set avcc3CRq 7)
-(if (and avcc3CRp #x800000) (set avcc3CRq 8)
-(if (and avcc3CRp #x400000) (set avcc3CRq 9)
-(if (and avcc3CRp #x200000) (set avcc3CRq 10)
-(if (and avcc3CRp #x100000) (set avcc3CRq 11)
-(if (and avcc3CRp #x80000) (set avcc3CRq 12)
-(if (and avcc3CRp #x40000) (set avcc3CRq 13)
-(if (and avcc3CRp #x20000) (set avcc3CRq 14)
-(if (and avcc3CRp #x10000) (set avcc3CRq 15)
-(if (and avcc3CRp #x8000) (set avcc3CRq 16)
-(if (and avcc3CRp #x4000) (set avcc3CRq 17)
-(if (and avcc3CRp #x2000) (set avcc3CRq 18)
-(if (and avcc3CRp #x1000) (set avcc3CRq 19)
-(if (and avcc3CRp #x800) (set avcc3CRq 20)
-(if (and avcc3CRp #x400) (set avcc3CRq 21)
-(if (and avcc3CRp #x200) (set avcc3CRq 22)
-(if (and avcc3CRp #x100) (set avcc3CRq 23)
-(if (and avcc3CRp #x80) (set avcc3CRq 24)
-(if (and avcc3CRp #x40) (set avcc3CRq 25)
-(if (and avcc3CRp #x20) (set avcc3CRq 26)
-(if (and avcc3CRp #x10) (set avcc3CRq 27)
-(if (and avcc3CRp #x8) (set avcc3CRq 28)
-(if (and avcc3CRp #x4) (set avcc3CRq 29)
-(if (and avcc3CRp #x2) (set avcc3CRq 30)
-(if (and avcc3CRp #x1) (set avcc3CRq 31)
-(set avcc3CRq 32)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
- ())
-(dncpi cabs_avc_c3 "cabs" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cabs"))
- "cabs $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x3) (f-avc-c3sub4u16 #x5) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (abs (ext SI (subword SI (sub avcc3CRq avcc3CRp) 1))))
-)
- ())
-(dncpi cad1s_avc_c3 "cad1s" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cad1s"))
- "cad1s $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x1) (f-avc-c3sub4u16 #x5) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI tmp0)) (c-call "check_option_cp" pc)
-(set tmp0 (ext SI (subword SI (add avcc3CRq avcc3CRp) 1)))
-(set avcc3CRq (subword SI (sra tmp0 1) 1))
-)
- ())
-(dncpi csb1s_avc_c3 "csb1s" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csb1s"))
- "csb1s $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x2) (f-avc-c3sub4u16 #x5) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI tmp0)) (c-call "check_option_cp" pc)
-(set tmp0 (ext SI (subword SI (sub avcc3CRq avcc3CRp) 1)))
-(set avcc3CRq (subword SI (sra tmp0 1) 1))
-)
- ())
-(dncpi cmin_avc_c3 "cmin" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmin"))
- "cmin $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x8) (f-avc-c3sub4u16 #x5) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (lt (ext SI avcc3CRq) (ext SI avcc3CRp)) (set avcc3CRq avcc3CRq)
-(set avcc3CRq avcc3CRp)
-)
-)
- ())
-(dncpi cmax_avc_c3 "cmax" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmax"))
- "cmax $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x9) (f-avc-c3sub4u16 #x5) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (gt (ext SI avcc3CRq) (ext SI avcc3CRp)) (set avcc3CRq avcc3CRq)
-(set avcc3CRq avcc3CRp)
-)
-)
- ())
-(dncpi cminu_avc_c3 "cminu" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cminu"))
- "cminu $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #xa) (f-avc-c3sub4u16 #x5) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (ltu (zext SI avcc3CRq) (zext SI avcc3CRp)) (set avcc3CRq avcc3CRq)
-(set avcc3CRq avcc3CRp)
-)
-)
- ())
-(dncpi cmaxu_avc_c3 "cmaxu" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmaxu"))
- "cmaxu $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #xb) (f-avc-c3sub4u16 #x5) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (gtu (zext SI avcc3CRq) (zext SI avcc3CRp)) (set avcc3CRq avcc3CRq)
-(set avcc3CRq avcc3CRp)
-)
-)
- ())
-(dncpi cclipi_avc_c3 "cclipi" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cclipi"))
- "cclipi $avcc3CRq,$avcc3Imm5u24"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3Imm5u24 (f-avc-c3sub3u29 #x4) (f-avc-c3sub4u16 #x5) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI tmp1)(DI tmp0)) (c-call "check_option_cp" pc)
-(if (eq (zext SI avcc3Imm5u24) (ext SI 0)) (set avcc3CRq 0)
-(sequence() (set tmp0 (sll 1 (sub avcc3Imm5u24 1)))
-(set tmp1 (sub (subword SI tmp0 1) 1))
-(if (gt (ext SI avcc3CRq) (ext SI (subword SI tmp1 1))) (set avcc3CRq (subword SI tmp1 1))
-(if (lt (ext SI avcc3CRq) (ext SI (neg (subword SI tmp0 1)))) (set avcc3CRq (neg (subword SI tmp0 1)))
-(set avcc3CRq avcc3CRq)
-)
-)
-)
-)
-)
- ())
-(dncpi cclipiu_avc_c3 "cclipiu" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cclipiu"))
- "cclipiu $avcc3CRq,$avcc3Imm5u24"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3Imm5u24 (f-avc-c3sub3u29 #x5) (f-avc-c3sub4u16 #x5) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI tmp1)(DI tmp0)) (c-call "check_option_cp" pc)
-(if (eq (zext SI avcc3Imm5u24) (ext SI 0)) (set avcc3CRq 0)
-(sequence() (set tmp0 (sub (sll 1 avcc3Imm5u24) 1))
-(if (gt (ext SI avcc3CRq) (ext SI (subword SI tmp0 1))) (set avcc3CRq (subword SI tmp0 1))
-(if (lt (ext SI avcc3CRq) (ext SI 0)) (set avcc3CRq 0)
-(set avcc3CRq avcc3CRq)
-)
-)
-)
-)
-)
- ())
-(dncpi cor_avc_c3 "cor" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cor"))
- "cor $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x4) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (or avcc3CRq avcc3CRp))
-)
- ())
-(dncpi cand_avc_c3 "cand" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cand"))
- "cand $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x5) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (and avcc3CRq avcc3CRp))
-)
- ())
-(dncpi cxor_avc_c3 "cxor" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cxor"))
- "cxor $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x6) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (xor avcc3CRq avcc3CRp))
-)
- ())
-(dncpi cnor_avc_c3 "cnor" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cnor"))
- "cnor $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x7) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (inv (or avcc3CRq avcc3CRp)))
-)
- ())
-(dncpi csra_avc_c3 "csra" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csra"))
- "csra $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #xc) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (sra avcc3CRq (and QI (srl avcc3CRp 0) #x1f)))
-)
- ())
-(dncpi csrl_avc_c3 "csrl" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csrl"))
- "csrl $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #xd) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (srl avcc3CRq (and QI (srl avcc3CRp 0) #x1f)))
-)
- ())
-(dncpi csll_avc_c3 "csll" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csll"))
- "csll $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #xe) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (sll avcc3CRq (and QI (srl avcc3CRp 0) #x1f)))
-)
- ())
-(dncpi csrai_avc_c3 "csrai" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csrai"))
- "csrai $avcc3CRq,$avcc3Imm5u24"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3Imm5u24 (f-avc-c3sub3u29 #x2) (f-avc-c3sub4u16 #x1) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (sra avcc3CRq avcc3Imm5u24))
-)
- ())
-(dncpi csrli_avc_c3 "csrli" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "csrli"))
- "csrli $avcc3CRq,$avcc3Imm5u24"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3Imm5u24 (f-avc-c3sub3u29 #x3) (f-avc-c3sub4u16 #x1) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (srl avcc3CRq avcc3Imm5u24))
-)
- ())
-(dncpi cslli_avc_c3 "cslli" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cslli"))
- "cslli $avcc3CRq,$avcc3Imm5u24"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3Imm5u24 (f-avc-c3sub3u29 #x6) (f-avc-c3sub4u16 #x1) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (sll avcc3CRq avcc3Imm5u24))
-)
- ())
-(dncpi cfsft_avc_c3 "cfsft" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cfsft"))
- "cfsft $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #xf) (f-avc-c3sub4u16 #x0) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (subword SI (sll (or (sll (zext DI (zext SI avcc3CRq)) 32) (zext DI avcc3CRp)) (and QI (srl avccopCCR0 0) #x3f)) 0))
-)
- ())
-(dncpi cfsfta0_avc_c3 "cfsfta0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cfsfta0"))
- "cfsfta0 $avcc3CRq"
-(+ MAJ_15 (f-sub4 7) avcc3CRq (f-avc-c3sub4u28 #x7) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u16 #x1) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (subword SI (sll (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (and QI (srl avccopCCR0 0) #x3f)) 0))
-)
- ())
-(dncpi cfsfta1_avc_c3 "cfsfta1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cfsfta1"))
- "cfsfta1 $avcc3CRq"
-(+ MAJ_15 (f-sub4 7) avcc3CRq (f-avc-c3sub4u28 #xf) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u16 #x1) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcc3CRq (subword SI (sll (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (and QI (srl avccopCCR0 0) #x3f)) 0))
-)
- ())
-(dncpi cmula0_avc_c3 "cmula0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmula0"))
- "cmula0 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x0) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat0)) (c-call "check_option_cp" pc)
-(set concat0 (mul (ext DI avcc3CRq) (ext DI avcc3CRp)))
-(set avccopCCR2 (subword SI concat0 0))
-(set avccopCCR3 (subword SI concat0 1))
-)
- ())
-(dncpi cmulua0_avc_c3 "cmulua0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmulua0"))
- "cmulua0 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x1) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat1)) (c-call "check_option_cp" pc)
-(set concat1 (mul (zext DI avcc3CRq) (zext DI avcc3CRp)))
-(set avccopCCR2 (subword SI concat1 0))
-(set avccopCCR3 (subword SI concat1 1))
-)
- ())
-(dncpi cnmula0_avc_c3 "cnmula0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cnmula0"))
- "cnmula0 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x2) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat2)) (c-call "check_option_cp" pc)
-(set concat2 (neg (mul (ext DI avcc3CRq) (ext DI avcc3CRp))))
-(set avccopCCR2 (subword SI concat2 0))
-(set avccopCCR3 (subword SI concat2 1))
-)
- ())
-(dncpi cmada0_avc_c3 "cmada0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmada0"))
- "cmada0 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x4) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat3)) (c-call "check_option_cp" pc)
-(set concat3 (add (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (ext DI avcc3CRq) (ext DI avcc3CRp))))
-(set avccopCCR2 (subword SI concat3 0))
-(set avccopCCR3 (subword SI concat3 1))
-)
- ())
-(dncpi cmadua0_avc_c3 "cmadua0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmadua0"))
- "cmadua0 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x5) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat4)) (c-call "check_option_cp" pc)
-(set concat4 (add (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (zext DI avcc3CRq) (zext DI avcc3CRp))))
-(set avccopCCR2 (subword SI concat4 0))
-(set avccopCCR3 (subword SI concat4 1))
-)
- ())
-(dncpi cmsba0_avc_c3 "cmsba0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmsba0"))
- "cmsba0 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x6) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat5)) (c-call "check_option_cp" pc)
-(set concat5 (sub (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (ext DI avcc3CRq) (ext DI avcc3CRp))))
-(set avccopCCR2 (subword SI concat5 0))
-(set avccopCCR3 (subword SI concat5 1))
-)
- ())
-(dncpi cmsbua0_avc_c3 "cmsbua0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmsbua0"))
- "cmsbua0 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x7) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat6)) (c-call "check_option_cp" pc)
-(set concat6 (sub (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (zext DI avcc3CRq) (zext DI avcc3CRp))))
-(set avccopCCR2 (subword SI concat6 0))
-(set avccopCCR3 (subword SI concat6 1))
-)
- ())
-(dncpi cmula1_avc_c3 "cmula1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmula1"))
- "cmula1 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x8) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat7)) (c-call "check_option_cp" pc)
-(set concat7 (mul (ext DI avcc3CRq) (ext DI avcc3CRp)))
-(set avccopCCR4 (subword SI concat7 0))
-(set avccopCCR5 (subword SI concat7 1))
-)
- ())
-(dncpi cmulua1_avc_c3 "cmulua1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmulua1"))
- "cmulua1 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #x9) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat8)) (c-call "check_option_cp" pc)
-(set concat8 (mul (zext DI avcc3CRq) (zext DI avcc3CRp)))
-(set avccopCCR4 (subword SI concat8 0))
-(set avccopCCR5 (subword SI concat8 1))
-)
- ())
-(dncpi cnmula1_avc_c3 "cnmula1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cnmula1"))
- "cnmula1 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #xa) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat9)) (c-call "check_option_cp" pc)
-(set concat9 (neg (mul (ext DI avcc3CRq) (ext DI avcc3CRp))))
-(set avccopCCR4 (subword SI concat9 0))
-(set avccopCCR5 (subword SI concat9 1))
-)
- ())
-(dncpi cmada1_avc_c3 "cmada1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmada1"))
- "cmada1 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #xc) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat10)) (c-call "check_option_cp" pc)
-(set concat10 (add (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (ext DI avcc3CRq) (ext DI avcc3CRp))))
-(set avccopCCR4 (subword SI concat10 0))
-(set avccopCCR5 (subword SI concat10 1))
-)
- ())
-(dncpi cmadua1_avc_c3 "cmadua1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmadua1"))
- "cmadua1 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #xd) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat11)) (c-call "check_option_cp" pc)
-(set concat11 (add (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (zext DI avcc3CRq) (zext DI avcc3CRp))))
-(set avccopCCR4 (subword SI concat11 0))
-(set avccopCCR5 (subword SI concat11 1))
-)
- ())
-(dncpi cmsba1_avc_c3 "cmsba1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmsba1"))
- "cmsba1 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #xe) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat12)) (c-call "check_option_cp" pc)
-(set concat12 (sub (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (ext DI avcc3CRq) (ext DI avcc3CRp))))
-(set avccopCCR4 (subword SI concat12 0))
-(set avccopCCR5 (subword SI concat12 1))
-)
- ())
-(dncpi cmsbua1_avc_c3 "cmsbua1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "cmsbua1"))
- "cmsbua1 $avcc3CRq,$avcc3CRp"
-(+ MAJ_15 (f-sub4 7) avcc3CRq avcc3CRp (f-avc-c3sub4u28 #xf) (f-avc-c3sub4u16 #x4) (f-avc-c3sub4u8 #x0) (f-avc-c3sub4u4 #x0))
-(sequence((DI concat13)) (c-call "check_option_cp" pc)
-(set concat13 (sub (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (zext DI avcc3CRq) (zext DI avcc3CRp))))
-(set avccopCCR4 (subword SI concat13 0))
-(set avccopCCR5 (subword SI concat13 1))
-)
- ())
-(dncpi xmula0_avc_c3 "xmula0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmula0"))
- "xmula0 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #x0) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat14)) (c-call "check_option_cp" pc)
-(set concat14 (mul (ext DI avcc3Rn) (ext DI avcc3Rm)))
-(set avccopCCR2 (subword SI concat14 0))
-(set avccopCCR3 (subword SI concat14 1))
-)
- ())
-(dncpi xmulua0_avc_c3 "xmulua0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmulua0"))
- "xmulua0 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #x1) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat15)) (c-call "check_option_cp" pc)
-(set concat15 (mul (zext DI avcc3Rn) (zext DI avcc3Rm)))
-(set avccopCCR2 (subword SI concat15 0))
-(set avccopCCR3 (subword SI concat15 1))
-)
- ())
-(dncpi xnmula0_avc_c3 "xnmula0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xnmula0"))
- "xnmula0 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #x2) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat16)) (c-call "check_option_cp" pc)
-(set concat16 (neg (mul (ext DI avcc3Rn) (ext DI avcc3Rm))))
-(set avccopCCR2 (subword SI concat16 0))
-(set avccopCCR3 (subword SI concat16 1))
-)
- ())
-(dncpi xmada0_avc_c3 "xmada0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmada0"))
- "xmada0 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #x4) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat17)) (c-call "check_option_cp" pc)
-(set concat17 (add (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (ext DI avcc3Rn) (ext DI avcc3Rm))))
-(set avccopCCR2 (subword SI concat17 0))
-(set avccopCCR3 (subword SI concat17 1))
-)
- ())
-(dncpi xmadua0_avc_c3 "xmadua0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmadua0"))
- "xmadua0 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #x5) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat18)) (c-call "check_option_cp" pc)
-(set concat18 (add (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (zext DI avcc3Rn) (zext DI avcc3Rm))))
-(set avccopCCR2 (subword SI concat18 0))
-(set avccopCCR3 (subword SI concat18 1))
-)
- ())
-(dncpi xmsba0_avc_c3 "xmsba0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmsba0"))
- "xmsba0 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #x6) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat19)) (c-call "check_option_cp" pc)
-(set concat19 (sub (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (ext DI avcc3Rn) (ext DI avcc3Rm))))
-(set avccopCCR2 (subword SI concat19 0))
-(set avccopCCR3 (subword SI concat19 1))
-)
- ())
-(dncpi xmsbua0_avc_c3 "xmsbua0" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmsbua0"))
- "xmsbua0 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #x7) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat20)) (c-call "check_option_cp" pc)
-(set concat20 (sub (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (zext DI avcc3Rn) (zext DI avcc3Rm))))
-(set avccopCCR2 (subword SI concat20 0))
-(set avccopCCR3 (subword SI concat20 1))
-)
- ())
-(dncpi xmula1_avc_c3 "xmula1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmula1"))
- "xmula1 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #x8) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat21)) (c-call "check_option_cp" pc)
-(set concat21 (mul (ext DI avcc3Rn) (ext DI avcc3Rm)))
-(set avccopCCR4 (subword SI concat21 0))
-(set avccopCCR5 (subword SI concat21 1))
-)
- ())
-(dncpi xmulua1_avc_c3 "xmulua1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmulua1"))
- "xmulua1 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #x9) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat22)) (c-call "check_option_cp" pc)
-(set concat22 (mul (zext DI avcc3Rn) (zext DI avcc3Rm)))
-(set avccopCCR4 (subword SI concat22 0))
-(set avccopCCR5 (subword SI concat22 1))
-)
- ())
-(dncpi xnmula1_avc_c3 "xnmula1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xnmula1"))
- "xnmula1 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #xa) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat23)) (c-call "check_option_cp" pc)
-(set concat23 (neg (mul (ext DI avcc3Rn) (ext DI avcc3Rm))))
-(set avccopCCR4 (subword SI concat23 0))
-(set avccopCCR5 (subword SI concat23 1))
-)
- ())
-(dncpi xmada1_avc_c3 "xmada1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmada1"))
- "xmada1 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #xc) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat24)) (c-call "check_option_cp" pc)
-(set concat24 (add (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (ext DI avcc3Rn) (ext DI avcc3Rm))))
-(set avccopCCR4 (subword SI concat24 0))
-(set avccopCCR5 (subword SI concat24 1))
-)
- ())
-(dncpi xmadua1_avc_c3 "xmadua1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmadua1"))
- "xmadua1 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #xd) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat25)) (c-call "check_option_cp" pc)
-(set concat25 (add (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (zext DI avcc3Rn) (zext DI avcc3Rm))))
-(set avccopCCR4 (subword SI concat25 0))
-(set avccopCCR5 (subword SI concat25 1))
-)
- ())
-(dncpi xmsba1_avc_c3 "xmsba1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmsba1"))
- "xmsba1 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #xe) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat26)) (c-call "check_option_cp" pc)
-(set concat26 (sub (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (ext DI avcc3Rn) (ext DI avcc3Rm))))
-(set avccopCCR4 (subword SI concat26 0))
-(set avccopCCR5 (subword SI concat26 1))
-)
- ())
-(dncpi xmsbua1_avc_c3 "xmsbua1" (OPTIONAL_CP_INSN (SLOT C3) (INTRINSIC "xmsbua1"))
- "xmsbua1 $avcc3Rn,$avcc3Rm"
-(+ MAJ_15 (f-sub4 7) avcc3Rn avcc3Rm (f-avc-c3sub4u28 #xf) (f-avc-c3sub4u24 #x0) (f-avc-c3sub4u20 #x0) (f-avc-c3sub4u16 #xc))
-(sequence((DI concat27)) (c-call "check_option_cp" pc)
-(set concat27 (sub (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (zext DI avcc3Rn) (zext DI avcc3Rm))))
-(set avccopCCR4 (subword SI concat27 0))
-(set avccopCCR5 (subword SI concat27 1))
-)
- ())
-(dn16i cnop_avc_v1 "cnop" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cnop"))
- "cnop"
-(+ (f-avc-v1sub4u12 #x0) (f-avc-v1sub4u8 #x0) (f-avc-v1sub4u4 #x0) (f-avc-v1sub4u0 #x0))
-(c-call "check_option_cp" pc)
- ())
-(dnmi cpnop16_avc_v1 "cpnop16"
-(avc-16-isa NO-DIS)
-"cpnop16"
-(emit cnop_avc_v1)
-)
-(dn16i cmov_avc_v1 "cmov" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmov"))
- "cmov $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x3) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq avcv1CRp)
-)
- ())
-(dn16i cmovi_avc_v1 "cmovi" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmovi"))
- "cmovi $avcv1CRq,$avcv1Imm8s8"
-(+ avcv1CRq avcv1Imm8s8 (f-avc-v1sub4u0 #x2))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (ext SI avcv1Imm8s8))
-)
- ())
-(dn16i cadd3_avc_v1 "cadd3" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cadd3"))
- "cadd3 $avcv1CRo,$avcv1CRq,$avcv1CRp"
-(+ avcv1CRo avcv1CRq avcv1CRp (f-avc-v1sub4u0 #x3))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRo (add avcv1CRq avcv1CRp))
-)
- ())
-(dn16i caddi_avc_v1 "caddi" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "caddi"))
- "caddi $avcv1CRq,$avcv1Imm6s8"
-(+ avcv1CRq avcv1Imm6s8 (f-avc-v1sub2u14 #x0) (f-avc-v1sub4u0 #x1))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (add avcv1CRq (ext SI avcv1Imm6s8)))
-)
- ())
-(dn16i csub_avc_v1 "csub" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csub"))
- "csub $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x2) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (sub avcv1CRq avcv1CRp))
-)
- ())
-(dn16i cneg_avc_v1 "cneg" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cneg"))
- "cneg $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x1) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (neg avcv1CRp))
-)
- ())
-(dn16i cextb_avc_v1 "cextb" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cextb"))
- "cextb $avcv1CRq"
-(+ avcv1CRq (f-avc-v1sub4u12 #x9) (f-avc-v1sub4u8 #x0) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (ext SI (and QI (srl avcv1CRq 0) #xff)))
-)
- ())
-(dn16i cexth_avc_v1 "cexth" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cexth"))
- "cexth $avcv1CRq"
-(+ avcv1CRq (f-avc-v1sub4u12 #x9) (f-avc-v1sub4u8 #x2) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (ext SI (and HI (srl avcv1CRq 0) #xffff)))
-)
- ())
-(dn16i cextub_avc_v1 "cextub" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cextub"))
- "cextub $avcv1CRq"
-(+ avcv1CRq (f-avc-v1sub4u12 #x9) (f-avc-v1sub4u8 #x8) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (zext SI (and QI (srl avcv1CRq 0) #xff)))
-)
- ())
-(dn16i cextuh_avc_v1 "cextuh" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cextuh"))
- "cextuh $avcv1CRq"
-(+ avcv1CRq (f-avc-v1sub4u12 #x9) (f-avc-v1sub4u8 #xa) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (zext SI (and HI (srl avcv1CRq 0) #xffff)))
-)
- ())
-(dn16i cscltz_avc_v1 "cscltz" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cscltz"))
- "cscltz $avcv1CRq"
-(+ avcv1CRq (f-avc-v1sub4u12 #xa) (f-avc-v1sub4u8 #xa) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(if (lt (ext SI avcv1CRq) (ext SI 0)) (set avccopCCR1 (or (sll (srl avccopCCR1 1) 1) (srl (sll (zext SI 1) 31) 31)))
-(set avccopCCR1 (or (sll (srl avccopCCR1 1) 1) (srl (sll (zext SI 0) 31) 31)))
-)
-)
- ())
-(dn16i cldz_avc_v1 "cldz" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cldz"))
- "cldz $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x0) (f-avc-v1sub4u0 #x5))
-(sequence() (c-call "check_option_cp" pc)
-(if (and avcv1CRp #x80000000) (set avcv1CRq 0)
-(if (and avcv1CRp #x40000000) (set avcv1CRq 1)
-(if (and avcv1CRp #x20000000) (set avcv1CRq 2)
-(if (and avcv1CRp #x10000000) (set avcv1CRq 3)
-(if (and avcv1CRp #x8000000) (set avcv1CRq 4)
-(if (and avcv1CRp #x4000000) (set avcv1CRq 5)
-(if (and avcv1CRp #x2000000) (set avcv1CRq 6)
-(if (and avcv1CRp #x1000000) (set avcv1CRq 7)
-(if (and avcv1CRp #x800000) (set avcv1CRq 8)
-(if (and avcv1CRp #x400000) (set avcv1CRq 9)
-(if (and avcv1CRp #x200000) (set avcv1CRq 10)
-(if (and avcv1CRp #x100000) (set avcv1CRq 11)
-(if (and avcv1CRp #x80000) (set avcv1CRq 12)
-(if (and avcv1CRp #x40000) (set avcv1CRq 13)
-(if (and avcv1CRp #x20000) (set avcv1CRq 14)
-(if (and avcv1CRp #x10000) (set avcv1CRq 15)
-(if (and avcv1CRp #x8000) (set avcv1CRq 16)
-(if (and avcv1CRp #x4000) (set avcv1CRq 17)
-(if (and avcv1CRp #x2000) (set avcv1CRq 18)
-(if (and avcv1CRp #x1000) (set avcv1CRq 19)
-(if (and avcv1CRp #x800) (set avcv1CRq 20)
-(if (and avcv1CRp #x400) (set avcv1CRq 21)
-(if (and avcv1CRp #x200) (set avcv1CRq 22)
-(if (and avcv1CRp #x100) (set avcv1CRq 23)
-(if (and avcv1CRp #x80) (set avcv1CRq 24)
-(if (and avcv1CRp #x40) (set avcv1CRq 25)
-(if (and avcv1CRp #x20) (set avcv1CRq 26)
-(if (and avcv1CRp #x10) (set avcv1CRq 27)
-(if (and avcv1CRp #x8) (set avcv1CRq 28)
-(if (and avcv1CRp #x4) (set avcv1CRq 29)
-(if (and avcv1CRp #x2) (set avcv1CRq 30)
-(if (and avcv1CRp #x1) (set avcv1CRq 31)
-(set avcv1CRq 32)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
-)
- ())
-(dn16i cabs_avc_v1 "cabs" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cabs"))
- "cabs $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x3) (f-avc-v1sub4u0 #x5))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (abs (ext SI (subword SI (sub avcv1CRq avcv1CRp) 1))))
-)
- ())
-(dn16i cad1s_avc_v1 "cad1s" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cad1s"))
- "cad1s $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x1) (f-avc-v1sub4u0 #x5))
-(sequence((DI tmp0)) (c-call "check_option_cp" pc)
-(set tmp0 (ext SI (subword SI (add avcv1CRq avcv1CRp) 1)))
-(set avcv1CRq (subword SI (sra tmp0 1) 1))
-)
- ())
-(dn16i csb1s_avc_v1 "csb1s" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csb1s"))
- "csb1s $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x2) (f-avc-v1sub4u0 #x5))
-(sequence((DI tmp0)) (c-call "check_option_cp" pc)
-(set tmp0 (ext SI (subword SI (sub avcv1CRq avcv1CRp) 1)))
-(set avcv1CRq (subword SI (sra tmp0 1) 1))
-)
- ())
-(dn16i cmin_avc_v1 "cmin" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmin"))
- "cmin $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x8) (f-avc-v1sub4u0 #x5))
-(sequence() (c-call "check_option_cp" pc)
-(if (lt (ext SI avcv1CRq) (ext SI avcv1CRp)) (set avcv1CRq avcv1CRq)
-(set avcv1CRq avcv1CRp)
-)
-)
- ())
-(dn16i cmax_avc_v1 "cmax" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmax"))
- "cmax $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x9) (f-avc-v1sub4u0 #x5))
-(sequence() (c-call "check_option_cp" pc)
-(if (gt (ext SI avcv1CRq) (ext SI avcv1CRp)) (set avcv1CRq avcv1CRq)
-(set avcv1CRq avcv1CRp)
-)
-)
- ())
-(dn16i cminu_avc_v1 "cminu" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cminu"))
- "cminu $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #xa) (f-avc-v1sub4u0 #x5))
-(sequence() (c-call "check_option_cp" pc)
-(if (ltu (zext SI avcv1CRq) (zext SI avcv1CRp)) (set avcv1CRq avcv1CRq)
-(set avcv1CRq avcv1CRp)
-)
-)
- ())
-(dn16i cmaxu_avc_v1 "cmaxu" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmaxu"))
- "cmaxu $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #xb) (f-avc-v1sub4u0 #x5))
-(sequence() (c-call "check_option_cp" pc)
-(if (gtu (zext SI avcv1CRq) (zext SI avcv1CRp)) (set avcv1CRq avcv1CRq)
-(set avcv1CRq avcv1CRp)
-)
-)
- ())
-(dn16i cclipi_avc_v1 "cclipi" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cclipi"))
- "cclipi $avcv1CRq,$avcv1Imm5u8"
-(+ avcv1CRq avcv1Imm5u8 (f-avc-v1sub3u13 #x4) (f-avc-v1sub4u0 #x5))
-(sequence((DI tmp1)(DI tmp0)) (c-call "check_option_cp" pc)
-(if (eq (zext SI avcv1Imm5u8) (ext SI 0)) (set avcv1CRq 0)
-(sequence() (set tmp0 (sll 1 (sub avcv1Imm5u8 1)))
-(set tmp1 (sub (subword SI tmp0 1) 1))
-(if (gt (ext SI avcv1CRq) (ext SI (subword SI tmp1 1))) (set avcv1CRq (subword SI tmp1 1))
-(if (lt (ext SI avcv1CRq) (ext SI (neg (subword SI tmp0 1)))) (set avcv1CRq (neg (subword SI tmp0 1)))
-(set avcv1CRq avcv1CRq)
-)
-)
-)
-)
-)
- ())
-(dn16i cclipiu_avc_v1 "cclipiu" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cclipiu"))
- "cclipiu $avcv1CRq,$avcv1Imm5u8"
-(+ avcv1CRq avcv1Imm5u8 (f-avc-v1sub3u13 #x5) (f-avc-v1sub4u0 #x5))
-(sequence((DI tmp0)) (c-call "check_option_cp" pc)
-(if (eq (zext SI avcv1Imm5u8) (ext SI 0)) (set avcv1CRq 0)
-(sequence() (set tmp0 (sub (sll 1 avcv1Imm5u8) 1))
-(if (gt (ext SI avcv1CRq) (ext SI (subword SI tmp0 1))) (set avcv1CRq (subword SI tmp0 1))
-(if (lt (ext SI avcv1CRq) (ext SI 0)) (set avcv1CRq 0)
-(set avcv1CRq avcv1CRq)
-)
-)
-)
-)
-)
- ())
-(dn16i cor_avc_v1 "cor" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cor"))
- "cor $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x4) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (or avcv1CRq avcv1CRp))
-)
- ())
-(dn16i cand_avc_v1 "cand" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cand"))
- "cand $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x5) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (and avcv1CRq avcv1CRp))
-)
- ())
-(dn16i cxor_avc_v1 "cxor" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cxor"))
- "cxor $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x6) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (xor avcv1CRq avcv1CRp))
-)
- ())
-(dn16i cnor_avc_v1 "cnor" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cnor"))
- "cnor $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x7) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (inv (or avcv1CRq avcv1CRp)))
-)
- ())
-(dn16i csra_avc_v1 "csra" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csra"))
- "csra $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #xc) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (sra avcv1CRq (and QI (srl avcv1CRp 0) #x1f)))
-)
- ())
-(dn16i csrl_avc_v1 "csrl" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csrl"))
- "csrl $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #xd) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (srl avcv1CRq (and QI (srl avcv1CRp 0) #x1f)))
-)
- ())
-(dn16i csll_avc_v1 "csll" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csll"))
- "csll $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #xe) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (sll avcv1CRq (and QI (srl avcv1CRp 0) #x1f)))
-)
- ())
-(dn16i csrai_avc_v1 "csrai" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csrai"))
- "csrai $avcv1CRq,$avcv1Imm5u8"
-(+ avcv1CRq avcv1Imm5u8 (f-avc-v1sub3u13 #x2) (f-avc-v1sub4u0 #x1))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (sra avcv1CRq avcv1Imm5u8))
-)
- ())
-(dn16i csrli_avc_v1 "csrli" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "csrli"))
- "csrli $avcv1CRq,$avcv1Imm5u8"
-(+ avcv1CRq avcv1Imm5u8 (f-avc-v1sub3u13 #x3) (f-avc-v1sub4u0 #x1))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (srl avcv1CRq avcv1Imm5u8))
-)
- ())
-(dn16i cslli_avc_v1 "cslli" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cslli"))
- "cslli $avcv1CRq,$avcv1Imm5u8"
-(+ avcv1CRq avcv1Imm5u8 (f-avc-v1sub3u13 #x6) (f-avc-v1sub4u0 #x1))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (sll avcv1CRq avcv1Imm5u8))
-)
- ())
-(dn16i cfsft_avc_v1 "cfsft" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cfsft"))
- "cfsft $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #xf) (f-avc-v1sub4u0 #x0))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (subword SI (sll (or (sll (zext DI (zext SI avcv1CRq)) 32) (zext DI avcv1CRp)) (and QI (srl avccopCCR0 0) #x3f)) 0))
-)
- ())
-(dn16i cfsfta0_avc_v1 "cfsfta0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cfsfta0"))
- "cfsfta0 $avcv1CRq"
-(+ avcv1CRq (f-avc-v1sub4u12 #x7) (f-avc-v1sub4u8 #x0) (f-avc-v1sub4u0 #x1))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (subword SI (sll (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (and QI (srl avccopCCR0 0) #x3f)) 0))
-)
- ())
-(dn16i cfsfta1_avc_v1 "cfsfta1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cfsfta1"))
- "cfsfta1 $avcv1CRq"
-(+ avcv1CRq (f-avc-v1sub4u12 #xf) (f-avc-v1sub4u8 #x0) (f-avc-v1sub4u0 #x1))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv1CRq (subword SI (sll (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (and QI (srl avccopCCR0 0) #x3f)) 0))
-)
- ())
-(dn16i cmula0_avc_v1 "cmula0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmula0"))
- "cmula0 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x0) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat28)) (c-call "check_option_cp" pc)
-(set concat28 (mul (ext DI avcv1CRq) (ext DI avcv1CRp)))
-(set avccopCCR2 (subword SI concat28 0))
-(set avccopCCR3 (subword SI concat28 1))
-)
- ())
-(dn16i cmulua0_avc_v1 "cmulua0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmulua0"))
- "cmulua0 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x1) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat29)) (c-call "check_option_cp" pc)
-(set concat29 (mul (zext DI avcv1CRq) (zext DI avcv1CRp)))
-(set avccopCCR2 (subword SI concat29 0))
-(set avccopCCR3 (subword SI concat29 1))
-)
- ())
-(dn16i cnmula0_avc_v1 "cnmula0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cnmula0"))
- "cnmula0 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x2) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat30)) (c-call "check_option_cp" pc)
-(set concat30 (neg (mul (ext DI avcv1CRq) (ext DI avcv1CRp))))
-(set avccopCCR2 (subword SI concat30 0))
-(set avccopCCR3 (subword SI concat30 1))
-)
- ())
-(dn16i cmada0_avc_v1 "cmada0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmada0"))
- "cmada0 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x4) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat31)) (c-call "check_option_cp" pc)
-(set concat31 (add (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (ext DI avcv1CRq) (ext DI avcv1CRp))))
-(set avccopCCR2 (subword SI concat31 0))
-(set avccopCCR3 (subword SI concat31 1))
-)
- ())
-(dn16i cmadua0_avc_v1 "cmadua0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmadua0"))
- "cmadua0 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x5) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat32)) (c-call "check_option_cp" pc)
-(set concat32 (add (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (zext DI avcv1CRq) (zext DI avcv1CRp))))
-(set avccopCCR2 (subword SI concat32 0))
-(set avccopCCR3 (subword SI concat32 1))
-)
- ())
-(dn16i cmsba0_avc_v1 "cmsba0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmsba0"))
- "cmsba0 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x6) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat33)) (c-call "check_option_cp" pc)
-(set concat33 (sub (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (ext DI avcv1CRq) (ext DI avcv1CRp))))
-(set avccopCCR2 (subword SI concat33 0))
-(set avccopCCR3 (subword SI concat33 1))
-)
- ())
-(dn16i cmsbua0_avc_v1 "cmsbua0" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmsbua0"))
- "cmsbua0 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x7) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat34)) (c-call "check_option_cp" pc)
-(set concat34 (sub (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (zext DI avcv1CRq) (zext DI avcv1CRp))))
-(set avccopCCR2 (subword SI concat34 0))
-(set avccopCCR3 (subword SI concat34 1))
-)
- ())
-(dn16i cmula1_avc_v1 "cmula1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmula1"))
- "cmula1 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x8) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat35)) (c-call "check_option_cp" pc)
-(set concat35 (mul (ext DI avcv1CRq) (ext DI avcv1CRp)))
-(set avccopCCR4 (subword SI concat35 0))
-(set avccopCCR5 (subword SI concat35 1))
-)
- ())
-(dn16i cmulua1_avc_v1 "cmulua1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmulua1"))
- "cmulua1 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #x9) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat36)) (c-call "check_option_cp" pc)
-(set concat36 (mul (zext DI avcv1CRq) (zext DI avcv1CRp)))
-(set avccopCCR4 (subword SI concat36 0))
-(set avccopCCR5 (subword SI concat36 1))
-)
- ())
-(dn16i cnmula1_avc_v1 "cnmula1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cnmula1"))
- "cnmula1 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #xa) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat37)) (c-call "check_option_cp" pc)
-(set concat37 (neg (mul (ext DI avcv1CRq) (ext DI avcv1CRp))))
-(set avccopCCR4 (subword SI concat37 0))
-(set avccopCCR5 (subword SI concat37 1))
-)
- ())
-(dn16i cmada1_avc_v1 "cmada1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmada1"))
- "cmada1 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #xc) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat38)) (c-call "check_option_cp" pc)
-(set concat38 (add (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (ext DI avcv1CRq) (ext DI avcv1CRp))))
-(set avccopCCR4 (subword SI concat38 0))
-(set avccopCCR5 (subword SI concat38 1))
-)
- ())
-(dn16i cmadua1_avc_v1 "cmadua1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmadua1"))
- "cmadua1 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #xd) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat39)) (c-call "check_option_cp" pc)
-(set concat39 (add (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (zext DI avcv1CRq) (zext DI avcv1CRp))))
-(set avccopCCR4 (subword SI concat39 0))
-(set avccopCCR5 (subword SI concat39 1))
-)
- ())
-(dn16i cmsba1_avc_v1 "cmsba1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmsba1"))
- "cmsba1 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #xe) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat40)) (c-call "check_option_cp" pc)
-(set concat40 (sub (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (ext DI avcv1CRq) (ext DI avcv1CRp))))
-(set avccopCCR4 (subword SI concat40 0))
-(set avccopCCR5 (subword SI concat40 1))
-)
- ())
-(dn16i cmsbua1_avc_v1 "cmsbua1" (VLIW64_NO_MATCHING_NOP (SLOT V1) (INTRINSIC "cmsbua1"))
- "cmsbua1 $avcv1CRq,$avcv1CRp"
-(+ avcv1CRq avcv1CRp (f-avc-v1sub4u12 #xf) (f-avc-v1sub4u0 #x4))
-(sequence((DI concat41)) (c-call "check_option_cp" pc)
-(set concat41 (sub (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (zext DI avcv1CRq) (zext DI avcv1CRp))))
-(set avccopCCR4 (subword SI concat41 0))
-(set avccopCCR5 (subword SI concat41 1))
-)
- ())
-(dn32i cmov1_avc_v3 "cmov1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "cmov1"))
- "cmov $avcv3CRn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3CRn avcv3Rm (f-avc-v3sub4u28 #x0) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv3CRn avcv3Rm)
-)
- ())
-(dn32i cmov2_avc_v3 "cmov2" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "cmov2"))
- "cmov $avcv3Rm,$avcv3CRn"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rm avcv3CRn (f-avc-v3sub4u28 #x1) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv3Rm avcv3CRn)
-)
- ())
-(dn32i cmovi_avc_v3 "cmovi" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "cmovi"))
- "cmovi $avcv3CRq,$avcv3Imm16s4x24e32"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3CRq avcv3Imm16s4x24e32 (f-avc-v3sub4u16 #xe))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv3CRq (ext SI avcv3Imm16s4x24e32))
-)
- ())
-(dn32i cmovc1_avc_v3 "cmovc1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "cmovc1"))
- "cmovc $avcv3CCRn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3CCRn avcv3Rm (f-avc-v3sub4u28 #x2) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv3CCRn avcv3Rm)
-)
- ())
-(dn32i cmovc2_avc_v3 "cmovc2" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "cmovc2"))
- "cmovc $avcv3Rm,$avcv3CCRn"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rm avcv3CCRn (f-avc-v3sub4u28 #x3) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xf))
-(sequence() (c-call "check_option_cp" pc)
-(set avcv3Rm avcv3CCRn)
-)
- ())
-(dn32i xmula0_avc_v3 "xmula0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmula0"))
- "xmula0 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #x0) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat42)) (c-call "check_option_cp" pc)
-(set concat42 (mul (ext DI avcv3Rn) (ext DI avcv3Rm)))
-(set avccopCCR2 (subword SI concat42 0))
-(set avccopCCR3 (subword SI concat42 1))
-)
- ())
-(dn32i xmulua0_avc_v3 "xmulua0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmulua0"))
- "xmulua0 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #x1) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat43)) (c-call "check_option_cp" pc)
-(set concat43 (mul (zext DI avcv3Rn) (zext DI avcv3Rm)))
-(set avccopCCR2 (subword SI concat43 0))
-(set avccopCCR3 (subword SI concat43 1))
-)
- ())
-(dn32i xnmula0_avc_v3 "xnmula0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xnmula0"))
- "xnmula0 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #x2) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat44)) (c-call "check_option_cp" pc)
-(set concat44 (neg (mul (ext DI avcv3Rn) (ext DI avcv3Rm))))
-(set avccopCCR2 (subword SI concat44 0))
-(set avccopCCR3 (subword SI concat44 1))
-)
- ())
-(dn32i xmada0_avc_v3 "xmada0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmada0"))
- "xmada0 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #x4) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat45)) (c-call "check_option_cp" pc)
-(set concat45 (add (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (ext DI avcv3Rn) (ext DI avcv3Rm))))
-(set avccopCCR2 (subword SI concat45 0))
-(set avccopCCR3 (subword SI concat45 1))
-)
- ())
-(dn32i xmadua0_avc_v3 "xmadua0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmadua0"))
- "xmadua0 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #x5) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat46)) (c-call "check_option_cp" pc)
-(set concat46 (add (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (zext DI avcv3Rn) (zext DI avcv3Rm))))
-(set avccopCCR2 (subword SI concat46 0))
-(set avccopCCR3 (subword SI concat46 1))
-)
- ())
-(dn32i xmsba0_avc_v3 "xmsba0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmsba0"))
- "xmsba0 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #x6) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat47)) (c-call "check_option_cp" pc)
-(set concat47 (sub (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (ext DI avcv3Rn) (ext DI avcv3Rm))))
-(set avccopCCR2 (subword SI concat47 0))
-(set avccopCCR3 (subword SI concat47 1))
-)
- ())
-(dn32i xmsbua0_avc_v3 "xmsbua0" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmsbua0"))
- "xmsbua0 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #x7) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat48)) (c-call "check_option_cp" pc)
-(set concat48 (sub (or (sll (zext DI (zext SI avccopCCR2)) 32) (zext DI avccopCCR3)) (mul (zext DI avcv3Rn) (zext DI avcv3Rm))))
-(set avccopCCR2 (subword SI concat48 0))
-(set avccopCCR3 (subword SI concat48 1))
-)
- ())
-(dn32i xmula1_avc_v3 "xmula1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmula1"))
- "xmula1 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #x8) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat49)) (c-call "check_option_cp" pc)
-(set concat49 (mul (ext DI avcv3Rn) (ext DI avcv3Rm)))
-(set avccopCCR4 (subword SI concat49 0))
-(set avccopCCR5 (subword SI concat49 1))
-)
- ())
-(dn32i xmulua1_avc_v3 "xmulua1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmulua1"))
- "xmulua1 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #x9) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat50)) (c-call "check_option_cp" pc)
-(set concat50 (mul (zext DI avcv3Rn) (zext DI avcv3Rm)))
-(set avccopCCR4 (subword SI concat50 0))
-(set avccopCCR5 (subword SI concat50 1))
-)
- ())
-(dn32i xnmula1_avc_v3 "xnmula1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xnmula1"))
- "xnmula1 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #xa) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat51)) (c-call "check_option_cp" pc)
-(set concat51 (neg (mul (ext DI avcv3Rn) (ext DI avcv3Rm))))
-(set avccopCCR4 (subword SI concat51 0))
-(set avccopCCR5 (subword SI concat51 1))
-)
- ())
-(dn32i xmada1_avc_v3 "xmada1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmada1"))
- "xmada1 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #xc) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat52)) (c-call "check_option_cp" pc)
-(set concat52 (add (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (ext DI avcv3Rn) (ext DI avcv3Rm))))
-(set avccopCCR4 (subword SI concat52 0))
-(set avccopCCR5 (subword SI concat52 1))
-)
- ())
-(dn32i xmadua1_avc_v3 "xmadua1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmadua1"))
- "xmadua1 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #xd) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat53)) (c-call "check_option_cp" pc)
-(set concat53 (add (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (zext DI avcv3Rn) (zext DI avcv3Rm))))
-(set avccopCCR4 (subword SI concat53 0))
-(set avccopCCR5 (subword SI concat53 1))
-)
- ())
-(dn32i xmsba1_avc_v3 "xmsba1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmsba1"))
- "xmsba1 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #xe) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat54)) (c-call "check_option_cp" pc)
-(set concat54 (sub (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (ext DI avcv3Rn) (ext DI avcv3Rm))))
-(set avccopCCR4 (subword SI concat54 0))
-(set avccopCCR5 (subword SI concat54 1))
-)
- ())
-(dn32i xmsbua1_avc_v3 "xmsbua1" (VLIW64_NO_MATCHING_NOP (SLOT V3) (INTRINSIC "xmsbua1"))
- "xmsbua1 $avcv3Rn,$avcv3Rm"
-(+ (f-avc-v3sub4u0 #xf) (f-avc-v3sub4u12 #x7) avcv3Rn avcv3Rm (f-avc-v3sub4u28 #xf) (f-avc-v3sub4u24 #x0) (f-avc-v3sub4u20 #x0) (f-avc-v3sub4u16 #xc))
-(sequence((DI concat55)) (c-call "check_option_cp" pc)
-(set concat55 (sub (or (sll (zext DI (zext SI avccopCCR4)) 32) (zext DI avccopCCR5)) (mul (zext DI avcv3Rn) (zext DI avcv3Rm))))
-(set avccopCCR4 (subword SI concat55 0))
-(set avccopCCR5 (subword SI concat55 1))
-)
- ())
diff -rupN binutils-2.19.1-original/cgen/cpu/mep-core.cpu binutils-2.19.1/cgen/cpu/mep-core.cpu
--- binutils-2.19.1-original/cgen/cpu/mep-core.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/mep-core.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,3038 +0,0 @@
-
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-(include "simplify.inc")
-
-(define-pmacro isa-enum ()
-  (isas mep 
-; begin-isa-enum
-	ext_core1
-	ext_core2 ext_cop2_16 ext_cop2_32 ext_cop2_48 ext_cop2_64
-; end-isa-enum
-  )
-)
-
-(define-arch
-  (name mep)
-  (comment "Toshiba MeP Media Engine")
-  (insn-lsb0? #f) ;; work around cgen limitation
-  (machs mep h1)
-  isa-enum
-)
-
-(define-isa
-  (name mep)
-  (comment "MeP core instruction set")
-  (default-insn-word-bitsize 32)
-  (default-insn-bitsize 32)
-  (base-insn-bitsize 32)
-)
-
-; begin-isas
-(define-isa
-  (name ext_core1)
-  (comment "MeP core extension instruction set")
-  (default-insn-word-bitsize 32)
-  (default-insn-bitsize 32)
-  (base-insn-bitsize 32)
-)
-
-(define-isa
-  (name ext_core2)
-  (comment "MeP core extension instruction set")
-  (default-insn-word-bitsize 32)
-  (default-insn-bitsize 32)
-  (base-insn-bitsize 32)
-)
-
-(define-isa
-  (name ext_cop2_16)
-  (comment "MeP coprocessor instruction set")
-  (default-insn-word-bitsize 32)
-  (default-insn-bitsize 32)
-  (base-insn-bitsize 32)
-)
-
-(define-isa
-  (name ext_cop2_32)
-  (comment "MeP coprocessor instruction set")
-  (default-insn-word-bitsize 32)
-  (default-insn-bitsize 32)
-  (base-insn-bitsize 32)
-)
-
-(define-isa
-  (name ext_cop2_48)
-  (comment "MeP coprocessor instruction set")
-  (default-insn-word-bitsize 32)
-  (default-insn-bitsize 32)
-  (base-insn-bitsize 32)
-)
-
-(define-isa
-  (name ext_cop2_64)
-  (comment "MeP coprocessor instruction set")
-  (default-insn-word-bitsize 32)
-  (default-insn-bitsize 32)
-  (base-insn-bitsize 32)
-)
-
-(define-pmacro all-mep-isas () (ISA mep,ext_core1,ext_core2,ext_cop2_16,ext_cop2_32,ext_cop2_48,ext_cop2_64))
-
-(define-pmacro all-mep-core-isas () (ISA mep,ext_core1,ext_core2))
-
-(define-pmacro all-core-isa-list () mep,ext_core1,ext_core2)
-; end-isas
-
-(define-cpu
-  (name mepf)
-  (comment "MeP family")
-  (endian either)
-  (insn-chunk-bitsize 16)
-  (word-bitsize 32)
-)
-
-(define-mach
-  (name mep)
-  (comment "MeP media engine")
-  (cpu mepf)
-  isa-enum
-)
-
-(define-mach
-  (name h1)
-  (comment "H1 media engine")
-  (cpu mepf)
-  isa-enum
-)
-
-(define-model
-  (name mep)
-  (comment "MeP media engine processor")
-  (mach mep) ; mach gets changed by MeP-Integrator
-
-  (unit u-exec "execution unit" ()
-	1 1 ; issue done
-	() () () ())
-
-  ; Branch unit
-  (unit u-branch "Branch Unit" ()
-	0 0 ; issue done
-	() ; state
-	() ; inputs
-	((pc)) ; outputs
-	() ; profile action (default)
-	)
-
-  ; Multiply unit
-  (unit u-multiply "Multiply Unit" ()
-	0 0 ; issue done
-	() ; state
-	() ; inputs
-	() ; outputs
-	() ; profile action (default)
-	)
-
-  ; Divide unit
-  (unit u-divide "Divide Unit" ()
-	0 0 ; issue done
-	() ; state
-	() ; inputs
-	() ; outputs
-	() ; profile action (default)
-	)
-
-  ; Stcb unit
-  (unit u-stcb "stcb Unit" ()
-	0 0 ; issue done
-	() ; state
-	() ; inputs
-	() ; outputs
-	() ; profile action (default)
-	)
-
-  ; Ldcb unit
-  (unit u-ldcb "ldcb Unit" ()
-	0 0 ; issue done
-	() ; state
-	() ; inputs
-	() ; outputs
-	() ; profile action (default)
-	)
-
-  ; Load gpr unit
-  (unit u-load-gpr "Load into GPR Unit" ()
-	0 0 ; issue done
-	() ; state
-	() ; inputs
-	((loadreg INT -1)) ; outputs
-	() ; profile action (default)
-	)
-
-  (unit u-ldcb-gpr "Ldcb into GPR Unit" ()
-	0 0 ; issue done
-	() ; state
-	() ; inputs
-	((loadreg INT -1)) ; outputs
-	() ; profile action (default)
-	)
-
-  ; Multiply into GPR unit
-  (unit u-mul-gpr "Multiply into GPR Unit" ()
-	0 0 ; issue done
-	() ; state
-	() ; inputs
-	((resultreg INT -1)) ; outputs
-	() ; profile action (default)
-	)
-
-  ; Use gpr unit -- stalls if GPR not ready
-  (unit u-use-gpr "Use GPR Unit" ()
-	0 0 ; issue done
-	() ; state
-	((usereg INT -1)) ; inputs
-	() ; outputs
-	() ; profile action (default)
-	)
-
-  ; Use ctrl-reg unit -- stalls if CTRL-REG not ready
-  (unit u-use-ctrl-reg "Use CTRL-REG Unit" ()
-	0 0 ; issue done
-	() ; state
-	((usereg INT -1)) ; inputs
-	() ; outputs
-	() ; profile action (default)
-	)
-
-  ; Store ctrl-reg unit -- stalls if CTRL-REG not ready
-  (unit u-store-ctrl-reg "Store CTRL-REG Unit" ()
-	0 0 ; issue done
-	() ; state
-	() ; inputs
-	((storereg INT -1)) ; outputs
-	() ; profile action (default)
-	)
-)
-
-; Hardware elements.
-
-(dnh h-pc "program counter" (PC PROFILE all-mep-isas) (pc) () () ())
-
-(define-hardware
-  (name h-gpr)
-  (comment "General purpose registers")
-  (attrs all-mep-isas CACHE-ADDR PROFILE)
-  (type register SI (16))
-  (indices keyword "$"
-	   (("0" 0) ("1" 1) ("2" 2) ("3" 3) ("4" 4) ("5" 5)
-	    ("6" 6) ("7" 7) ("8" 8) ("9" 9) ("10" 10) ("11" 11)
-	    ; "$8" is the preferred name for register 8, but "$tp", "$gp"
-	    ; and "$sp" are preferred for their respective registers.
-	    (fp  8) (tp 13) (gp 14) (sp 15)
-	    ("12" 12) ("13" 13) ("14" 14) ("15" 15)))
-)
-
-(define-hardware
-  (name h-csr)
-  (comment "Control/special registers")
-  (attrs all-mep-isas PROFILE)
-  (type register SI (32))
-  (indices keyword "$"
-	   ((pc 0)   (lp 1)   (sar 2)   (rpb  4) (rpe 5)   (rpc 6)
-	    (hi 7)   (lo 8)   (mb0 12)  (me0 13) (mb1 14)  (me1 15)
-	    (psw 16) (id 17)  (tmp 18)  (epc 19) (exc 20)  (cfg 21)
-	    (npc 23) (dbg 24) (depc 25) (opt 26) (rcfg 27) (ccfg 28)
-; begin-extra-csr-registers
-; end-extra-csr-registers
-  ))
-  (get (index) (c-call SI "cgen_get_csr_value" index))
-  (set (index newval) (c-call VOID "cgen_set_csr_value" index newval))
-)
-
-(define-pmacro (-reg-pair n) ((.sym n) n))
-(define-hardware
-  (name h-cr64)
-  (comment "64-bit coprocessor registers")
-  (attrs all-mep-isas)
-  ; This assumes that the data path of the co-pro is 64 bits.
-  (type register DI (32))
-  (indices keyword "$c" (.map -reg-pair (.iota 32)))
-)
-
-(define-hardware
-  (name h-cr)
-  (comment "32-bit coprocessor registers")
-  (attrs all-mep-isas VIRTUAL)
-  (type register SI (32))
-  (indices keyword "$c" (.map -reg-pair (.iota 32)))
-  (set (index newval) (c-call VOID "h_cr64_set" index (ext DI newval)))
-  (get (index) (trunc SI (c-call DI "h_cr64_get" index)))
-)
-
-;; Given a coprocessor control register number N, expand to a
-;; name/index pair: ($ccrN N)
-(define-pmacro (-ccr-reg-pair n) ((.sym "$ccr" n) n))
-
-(define-hardware
-  (name h-ccr)
-  (comment "Coprocessor control registers")
-  (attrs all-mep-isas)
-  (type register SI (64))
-  (indices keyword "" (.map -ccr-reg-pair (.iota 64)))
-  (set (index newval) (c-call VOID "cgen_set_ccr_value" index newval))
-)
-
-
-; Instruction fields.  Bit numbering reversed.
-
-; Conventions:
-;
-; N = number of bits in value
-; A = alignment (2 or 4, omit for 1)
-; B = leftmost (i.e. closest to zero) bit position
-;
-; -- Generic Fields (f-*) --
-; N		number of bits in *value* (1-24)
-; [us]		signed vs unsigned
-; B		position of left-most bit (4-16)
-; aA		opt. alignment (2=drop 1 lsb, 4=drop 2 lsbs, etc)
-; n		opt. for noncontiguous fields
-; f-foo-{hi,lo}	msb/lsb parts of field f-foo
-;
-; -- Operands --
-; pcrelNaA	PC-relative branch target (signed)
-; pcabsNaA	Absolute branch target (unsigned)
-;
-; [us]dispNaA	[un]signed displacement
-; [us]immN	[un]signed immediate value
-; addrNaA	absolute address (unsigned)
-;
-; Additional prefixes may be used for special cases.
-
-(dnf f-major   "major opcode"            (all-mep-core-isas)    0  4)
-
-(dnf f-rn      "register n"              (all-mep-core-isas)    4  4)
-(dnf f-rn3     "register 0-7"            (all-mep-core-isas)    5  3)
-(dnf f-rm      "register m"              (all-mep-core-isas)    8  4)
-(dnf f-rl      "register l"              (all-mep-core-isas)   12  4)
-(dnf f-sub2    "sub opcode (2 bits)"     (all-mep-core-isas)   14  2)
-(dnf f-sub3    "sub opcode (3 bits)"     (all-mep-core-isas)   13  3)
-(dnf f-sub4    "sub opcode (4 bits)"     (all-mep-core-isas)   12  4)
-(dnf f-ext     "extended field"          (all-mep-core-isas)   16  8)
-(dnf f-crn     "copro register n"        (all-mep-core-isas)    4  4)
-
-(df f-csrn-hi "cr hi 1u15" (all-mep-core-isas) 15 1 UINT #f #f)
-(df f-csrn-lo "cr lo 4u8"  (all-mep-core-isas)  8 4 UINT #f #f)
-(define-multi-ifield
-  (name f-csrn)
-  (comment "control reg")
-  (attrs all-mep-core-isas)
-  (mode UINT)
-  (subfields f-csrn-hi f-csrn-lo)
-  (insert (sequence ()
-		    (set (ifield f-csrn-lo) (and (ifield f-csrn) #xf))
-		    (set (ifield f-csrn-hi) (srl (ifield f-csrn) 4))))
-  (extract (set (ifield f-csrn)
-		(or (sll (ifield f-csrn-hi) 4) (ifield f-csrn-lo))))
-  )
-
-(df f-crnx-hi "crx hi 1u28" (all-mep-core-isas) 28 1 UINT #f #f)
-(df f-crnx-lo "crx lo 4u4"  (all-mep-core-isas)  4 4 UINT #f #f)
-(define-multi-ifield
-  (name f-crnx)
-  (comment "copro register n (0-31)")
-  (attrs all-mep-core-isas)
-  (mode UINT)
-  (subfields f-crnx-hi f-crnx-lo)
-  (insert (sequence ()
-		    (set (ifield f-crnx-lo) (and (ifield f-crnx) #xf))
-		    (set (ifield f-crnx-hi) (srl (ifield f-crnx) 4))))
-  (extract (set (ifield f-crnx)
-		(or (sll (ifield f-crnx-hi) 4) (ifield f-crnx-lo))))
-  )
-
-; Miscellaneous fields.
-
-(define-pmacro (dnfb n)
-  (dnf (.sym f- n) (.str "bit " n) (all-mep-isas) n 1))
-
-; Define small fields used throughout the instruction set description.
-; Each field (eg. `f-N') is at single bit field at position N.
-
-(dnfb  0)
-(dnfb  1)
-(dnfb  2)
-(dnfb  3)
-(dnfb  4)
-(dnfb  5)
-(dnfb  6)
-(dnfb  7)
-(dnfb  8)
-(dnfb  9)
-(dnfb  10)
-(dnfb  11)
-(dnfb  12)
-(dnfb  13)
-(dnfb  14)
-(dnfb  15)
-(dnfb  16)
-(dnfb  17)
-(dnfb  18)
-(dnfb  19)
-(dnfb  20)
-(dnfb  21)
-(dnfb  22)
-(dnfb  23)
-(dnfb  24)
-(dnfb  25)
-(dnfb  26)
-(dnfb  27)
-(dnfb  28)
-(dnfb  29)
-(dnfb  30)
-(dnfb  31)
-
-; Branch/Jump target addresses
-
-(df f-8s8a2 "pc-rel addr (8 bits)"    (all-mep-core-isas PCREL-ADDR)  8  7 INT
-    ((value pc) (sra SI (sub SI value    pc) 1))
-    ((value pc) (add SI (sll SI value 1) pc)))
-
-(df f-12s4a2 "pc-rel addr (12 bits)"  (all-mep-core-isas PCREL-ADDR)  4 11 INT
-    ((value pc) (sra SI (sub SI value    pc) 1))
-    ((value pc) (add SI (sll SI value 1) pc)))
-
-(df f-17s16a2 "pc-rel addr (17 bits)" (all-mep-core-isas PCREL-ADDR) 16 16 INT
-    ((value pc) (sra SI (sub SI value    pc) 1))
-    ((value pc) (add SI (sll SI value 1) pc)))
-
-(df f-24s5a2n-hi "24s5a2n hi 16s16" (all-mep-core-isas PCREL-ADDR) 16 16  INT #f #f)
-(df f-24s5a2n-lo "24s5a2n lo 7s5a2" (all-mep-core-isas PCREL-ADDR)  5  7 UINT #f #f)
-(define-multi-ifield
-  (name f-24s5a2n)
-  (comment "pc-rel addr (24 bits align 2)")
-  (attrs all-mep-core-isas PCREL-ADDR)
-  (mode INT)
-  (subfields f-24s5a2n-hi f-24s5a2n-lo)
-  (insert (sequence ()
-		    (set (ifield f-24s5a2n)
-			 (sub (ifield f-24s5a2n) pc))
-		    (set (ifield f-24s5a2n-lo)
-			 (srl (and (ifield f-24s5a2n) #xfe) 1))
-		    (set (ifield f-24s5a2n-hi)
-			 (sra INT (ifield f-24s5a2n) 8))))
-  (extract (set (ifield f-24s5a2n)
-		(add SI (or (sll (ifield f-24s5a2n-hi) 8)
-			    (sll (ifield f-24s5a2n-lo) 1))
-		     pc)))
-  )
-
-(df f-24u5a2n-hi "24u5a2n hi 16u16" (all-mep-core-isas) 16 16 UINT #f #f)
-(df f-24u5a2n-lo "24u5a2n lo 7u5a2" (all-mep-core-isas)  5  7 UINT #f #f)
-(define-multi-ifield
-  (name f-24u5a2n)
-  (comment "abs jump target (24 bits, alignment 2)")
-  (attrs all-mep-core-isas ABS-ADDR)
-  (mode UINT)
-  (subfields f-24u5a2n-hi f-24u5a2n-lo)
-  (insert (sequence ()
-		    (set (ifield f-24u5a2n-lo)
-			 (srl (and (ifield f-24u5a2n) #xff) 1))
-		    (set (ifield f-24u5a2n-hi)
-			 (srl (ifield f-24u5a2n) 8))
-		    ))
-  (extract (set (ifield f-24u5a2n)
-		(or (sll (ifield f-24u5a2n-hi) 8)
-		    (sll (ifield f-24u5a2n-lo) 1))))
-  )
-
-; Displacement fields.
-
-(df f-2u6     "SAR offset (2 bits)"    (all-mep-core-isas)  6  2 UINT #f #f)
-(df f-7u9     "tp-rel b (7 bits)"      (all-mep-core-isas)  9  7 UINT #f #f)
-(df f-7u9a2   "tp-rel h (7 bits)"      (all-mep-core-isas)  9  6 UINT
-    ((value pc) (srl SI value 1))
-    ((value pc) (sll SI value 1)))
-(df f-7u9a4   "tp/sp-rel w (7 bits)"   (all-mep-core-isas)  9  5 UINT
-    ((value pc) (srl SI value 2))
-    ((value pc) (sll SI value 2)))
-(df f-16s16   "general 16-bit s-val"   (all-mep-core-isas) 16 16  INT #f #f)
-
-; Immediate fields.
-
-(df f-2u10   "swi level (2 bits)"      (all-mep-core-isas) 10  2 UINT #f #f)
-(df f-3u5    "bit offset (3 bits)"     (all-mep-core-isas)  5  3 UINT #f #f)
-(df f-4u8    "bCC const (4 bits)"      (all-mep-core-isas)  8  4 UINT #f #f)
-(df f-5u8    "slt & shifts (5 bits)"   (all-mep-core-isas)  8  5 UINT #f #f)
-(df f-5u24   "clip immediate (5 bits)" (all-mep-core-isas) 24  5 UINT #f #f)
-(df f-6s8    "add immediate (6 bits)"  (all-mep-core-isas)  8  6  INT #f #f)
-(df f-8s8    "add imm (8 bits)"        (all-mep-core-isas)  8  8  INT #f #f)
-(df f-16u16  "general 16-bit u-val"    (all-mep-core-isas) 16 16 UINT #f #f)
-(df f-12u16  "cmov fixed 1"            (all-mep-core-isas) 16 12 UINT #f #f)
-(df f-3u29   "cmov fixed 2"            (all-mep-core-isas) 29  3 UINT #f #f)
-
-
-; These are all for the coprocessor opcodes
-
-(df f-8s24   "copro b-offset (8 bits)" (all-mep-core-isas) 24 8 INT #f #f)
-(df f-8s24a2 "copro h-offset (8 bits)" (all-mep-core-isas) 24 7 INT
-    ((value pc) (sra SI value 1))
-    ((value pc) (sll SI value 1)))
-(df f-8s24a4 "copro w-offset (8 bits)" (all-mep-core-isas) 24 6 INT
-    ((value pc) (sra SI value 2))
-    ((value pc) (sll SI value 2)))
-(df f-8s24a8 "copro m-offset (8 bits)" (all-mep-core-isas) 24 5 INT
-    ((value pc) (sra SI value 3))
-    ((value pc) (sll SI value 3)))
-
-; Non-contiguous fields.
-
-(df f-24u8a4n-hi "24u8a4n hi 16u16" (all-mep-core-isas) 16 16 UINT #f #f)
-(df f-24u8a4n-lo "24u8a4n lo 8u8a4" (all-mep-core-isas)  8  6 UINT #f #f)
-(define-multi-ifield
-  (name f-24u8a4n)
-  (comment "absolute 24-bit address")
-  (attrs all-mep-core-isas)
-  (mode UINT)
-  (subfields f-24u8a4n-hi f-24u8a4n-lo)
-  (insert (sequence ()
-		    (set (ifield f-24u8a4n-hi) (srl (ifield f-24u8a4n) 8))
-		    (set (ifield f-24u8a4n-lo) (srl (and (ifield f-24u8a4n) #xfc) 2))))
-  (extract (set (ifield f-24u8a4n)
-		(or (sll (ifield f-24u8a4n-hi) 8)
-		    (sll (ifield f-24u8a4n-lo) 2))))
-  )
-
-(df f-24u8n-hi "24u8n hi 16u16" (all-mep-core-isas) 16 16 UINT #f #f)
-(df f-24u8n-lo "24u8n lo  8u8"  (all-mep-core-isas)  8  8 UINT #f #f)
-(define-multi-ifield
-  (name f-24u8n)
-  (comment "24-bit constant")
-  (attrs all-mep-core-isas)
-  (mode UINT)
-  (subfields f-24u8n-hi f-24u8n-lo)
-  (insert (sequence ()
-		    (set (ifield f-24u8n-hi) (srl (ifield f-24u8n) 8))
-		    (set (ifield f-24u8n-lo) (and (ifield f-24u8n) #xff))))
-  (extract (set (ifield f-24u8n)
-		(or (sll (ifield f-24u8n-hi) 8)
-		    (ifield f-24u8n-lo))))
-  )
-
-(df f-24u4n-hi "24u4n hi  8u4"  (all-mep-core-isas)  4  8 UINT #f #f)
-(df f-24u4n-lo "24u4n lo 16u16" (all-mep-core-isas) 16 16 UINT #f #f)
-(define-multi-ifield
-  (name f-24u4n)
-  (comment "coprocessor code")
-  (attrs all-mep-core-isas)
-  (mode UINT)
-  (subfields f-24u4n-hi f-24u4n-lo)
-  (insert (sequence ()
-		    (set (ifield f-24u4n-hi) (srl (ifield f-24u4n) 16))
-		    (set (ifield f-24u4n-lo) (and (ifield f-24u4n) #xffff))))
-  (extract (set (ifield f-24u4n)
-		(or (sll (ifield f-24u4n-hi) 16)
-		    (ifield f-24u4n-lo))))
-  )
-
-(define-multi-ifield
-  (name f-callnum)
-  (comment "system call number field")
-  (attrs all-mep-core-isas)
-  (mode UINT)
-  (subfields f-5 f-6 f-7 f-11)
-  (insert (sequence ()
-		    (set (ifield f-5)  (and (srl (ifield f-callnum) 3) 1))
-		    (set (ifield f-6)  (and (srl (ifield f-callnum) 2) 1))
-		    (set (ifield f-7)  (and (srl (ifield f-callnum) 1) 1))
-		    (set (ifield f-11) (and (ifield f-callnum) 1))))
-  (extract (set (ifield f-callnum)
-		(or (sll (ifield f-5) 3)
-		    (or (sll (ifield f-6) 2)
-			(or (sll (ifield f-7) 1)
-			    (ifield f-11))))))
-  )
-
-(df f-ccrn-hi "ccrn hi  2u28" (all-mep-core-isas) 28 2 UINT #f #f)
-(df f-ccrn-lo "ccrn lo  4u4"  (all-mep-core-isas)  4 4 UINT #f #f)
-(define-multi-ifield
-  (name f-ccrn)
-  (comment "Coprocessor register number field")
-  (attrs all-mep-core-isas)
-  (mode UINT)
-  (subfields f-ccrn-hi f-ccrn-lo)
-  (insert (sequence ()
-		    (set (ifield f-ccrn-hi)  (and (srl (ifield f-ccrn) 4) #x3))
-		    (set (ifield f-ccrn-lo)  (and (ifield f-ccrn) #xf))))
-  (extract (set (ifield f-ccrn)
-		(or (sll (ifield f-ccrn-hi) 4)
-		    (ifield f-ccrn-lo))))
-  )
-
-; Operands.
-
-;; Only LABEL, REGNUM, FMAX_FLOAT and FMAX_INT are now relevant for correct
-;; operation.  The others are mostly kept for backwards compatibility,
-;; although they do affect the dummy prototypes in
-;; gcc/config/mep/intrinsics.h.
-(define-attr
-  (type enum)
-  (for operand)
-  (name CDATA)
-  (comment "datatype to use for C intrinsics mapping")
-  (values LABEL REGNUM FMAX_FLOAT FMAX_INT
-	  POINTER LONG ULONG SHORT USHORT CHAR UCHAR CP_DATA_BUS_INT)
-  (default LONG))
-
-(define-attr
-  (type integer)
-  (for operand)
-  (name ALIGN)
-  (comment "alignment of immediate operands")
-  (default 1))
-
-(define-attr
-  (for operand)
-  (type boolean)
-  (name RELOC_IMPLIES_OVERFLOW)
-  (comment "Operand should not be considered as a candidate for relocs"))
-
-(define-attr
-  (for hardware)
-  (type boolean)
-  (name IS_FLOAT)
-  (comment "Register contains a floating point value"))
-
-(define-pmacro (dpop name commment attrib hwr field func)
-  (define-full-operand name comment attrib
-    hwr DFLT field ((parse func)) () ()))
-(define-pmacro (dprp name commment attrib hwr field pafunc prfunc)
-  (define-full-operand name comment attrib
-    hwr DFLT field ((parse pafunc) (print prfunc)) () ()))
-
-(dnop r0        "register 0"              (all-mep-core-isas) h-gpr   0)
-(dnop rn        "register Rn"             (all-mep-core-isas) h-gpr   f-rn)
-(dnop rm        "register Rm"             (all-mep-core-isas) h-gpr   f-rm)
-(dnop rl        "register Rl"             (all-mep-core-isas) h-gpr   f-rl)
-(dnop rn3       "register 0-7"            (all-mep-core-isas) h-gpr   f-rn3)
-
-;; Variants of RM/RN with different CDATA attributes.  See comment above
-;; CDATA for more details.
-
-(dnop rma       "register Rm holding pointer"          (all-mep-core-isas (CDATA POINTER)) h-gpr   f-rm)
-
-(dnop rnc       "register Rn holding char"             (all-mep-core-isas (CDATA LONG))    h-gpr   f-rn)
-(dnop rnuc      "register Rn holding unsigned char"    (all-mep-core-isas (CDATA LONG))    h-gpr   f-rn)
-(dnop rns       "register Rn holding short"            (all-mep-core-isas (CDATA LONG))    h-gpr   f-rn)
-(dnop rnus      "register Rn holding unsigned short"   (all-mep-core-isas (CDATA LONG))    h-gpr   f-rn)
-(dnop rnl       "register Rn holding long"             (all-mep-core-isas (CDATA LONG))    h-gpr   f-rn)
-(dnop rnul      "register Rn holding unsigned  long"   (all-mep-core-isas (CDATA ULONG))   h-gpr   f-rn)
-
-(dnop rn3c       "register 0-7 holding unsigned char"    (all-mep-core-isas (CDATA LONG))  h-gpr   f-rn3)
-(dnop rn3uc      "register 0-7 holding byte"             (all-mep-core-isas (CDATA LONG))  h-gpr   f-rn3)
-(dnop rn3s       "register 0-7 holding unsigned short"   (all-mep-core-isas (CDATA LONG))  h-gpr   f-rn3)
-(dnop rn3us      "register 0-7 holding short"            (all-mep-core-isas (CDATA LONG))  h-gpr   f-rn3)
-(dnop rn3l       "register 0-7 holding unsigned long"    (all-mep-core-isas (CDATA LONG))  h-gpr   f-rn3)
-(dnop rn3ul      "register 0-7 holding long"             (all-mep-core-isas (CDATA ULONG)) h-gpr   f-rn3)
-
-
-(dnop lp        "link pointer"            (all-mep-core-isas) h-csr   1)
-(dnop sar       "shift amount register"   (all-mep-core-isas) h-csr   2)
-(dnop hi        "high result"             (all-mep-core-isas) h-csr   7)
-(dnop lo        "low result"              (all-mep-core-isas) h-csr   8)
-(dnop mb0       "modulo begin register 0" (all-mep-core-isas) h-csr  12)
-(dnop me0       "modulo end register 0"   (all-mep-core-isas) h-csr  13)
-(dnop mb1       "modulo begin register 1" (all-mep-core-isas) h-csr  14)
-(dnop me1       "modulo end register 1"   (all-mep-core-isas) h-csr  15)
-(dnop psw       "program status word"     (all-mep-core-isas) h-csr  16)
-(dnop epc	"exception prog counter"  (all-mep-core-isas) h-csr  19)
-(dnop exc       "exception cause"         (all-mep-core-isas) h-csr  20)
-(dnop npc       "nmi program counter"     (all-mep-core-isas) h-csr  23)
-(dnop dbg       "debug register"          (all-mep-core-isas) h-csr  24)
-(dnop depc      "debug exception pc"      (all-mep-core-isas) h-csr  25)
-(dnop opt       "option register"         (all-mep-core-isas) h-csr  26)
-(dnop r1        "register 1"              (all-mep-core-isas) h-gpr   1)
-(dnop tp        "tiny data area pointer"  (all-mep-core-isas) h-gpr  13)
-(dnop sp        "stack pointer"           (all-mep-core-isas) h-gpr  15)
-(dprp tpr       "TP register"             (all-mep-core-isas) h-gpr  13       "tpreg" "tpreg")
-(dprp spr       "SP register"             (all-mep-core-isas) h-gpr  15       "spreg" "spreg")
-
-(define-full-operand
-  csrn "control/special register" (all-mep-core-isas (CDATA REGNUM)) h-csr
-  DFLT f-csrn ((parse "csrn")) () ()
-)
-
-(dnop csrn-idx  "control/special reg idx" (all-mep-core-isas) h-uint  f-csrn)
-(dnop crn64     "copro Rn (64-bit)"       (all-mep-core-isas (CDATA CP_DATA_BUS_INT)) h-cr64  f-crn)
-(dnop crn       "copro Rn (32-bit)"       (all-mep-core-isas (CDATA CP_DATA_BUS_INT)) h-cr    f-crn)
-(dnop crnx64    "copro Rn (0-31, 64-bit)" (all-mep-core-isas (CDATA CP_DATA_BUS_INT)) h-cr64  f-crnx)
-(dnop crnx      "copro Rn (0-31, 32-bit)" (all-mep-core-isas (CDATA CP_DATA_BUS_INT)) h-cr    f-crnx)
-(dnop ccrn      "copro control reg CCRn"  (all-mep-core-isas (CDATA REGNUM)) h-ccr   f-ccrn)
-(dnop cccc      "copro flags"             (all-mep-core-isas) h-uint  f-rm)
-
-(dprp pcrel8a2  "pc-rel addr (8 bits)"    (all-mep-core-isas (CDATA LABEL) RELAX) h-sint  f-8s8a2   "mep_align" "address")
-(dprp pcrel12a2 "pc-rel addr (12 bits)"   (all-mep-core-isas (CDATA LABEL) RELAX) h-sint  f-12s4a2  "mep_align" "address")
-(dprp pcrel17a2 "pc-rel addr (17 bits)"   (all-mep-core-isas (CDATA LABEL) RELAX) h-sint  f-17s16a2 "mep_align" "address")
-(dprp pcrel24a2 "pc-rel addr (24 bits)"   (all-mep-core-isas (CDATA LABEL))       h-sint  f-24s5a2n "mep_align" "address")
-(dprp pcabs24a2 "pc-abs addr (24 bits)"   (all-mep-core-isas (CDATA LABEL))       h-uint  f-24u5a2n "mep_alignu" "address")
-
-(dpop sdisp16   "displacement (16 bits)"  (all-mep-core-isas) h-sint  f-16s16    "signed16")
-(dpop simm16    "signed imm (16 bits)"    (all-mep-core-isas) h-sint  f-16s16    "signed16")
-(dpop uimm16    "unsigned imm (16 bits)"  (all-mep-core-isas) h-uint  f-16u16    "unsigned16")
-(dnop code16    "uci/dsp code (16 bits)"  (all-mep-core-isas) h-uint  f-16u16)
-
-(dnop udisp2    "SSARB addend (2 bits)"   (all-mep-core-isas) h-sint  f-2u6)
-(dnop uimm2     "interrupt (2 bits)"      (all-mep-core-isas) h-uint  f-2u10)
-
-(dnop simm6     "add const (6 bits)"      (all-mep-core-isas) h-sint  f-6s8)
-(dnop simm8     "mov const (8 bits)"      (all-mep-core-isas RELOC_IMPLIES_OVERFLOW) 
-                                             h-sint  f-8s8)
-
-(dpop addr24a4  "sw/lw addr (24 bits)"    (all-mep-core-isas (ALIGN 4)) h-uint  f-24u8a4n  "mep_alignu")
-(dnop code24    "coprocessor code"        (all-mep-core-isas) h-uint  f-24u4n)
-
-(dnop callnum   "system call number"      (all-mep-core-isas) h-uint  f-callnum)
-(dnop uimm3     "bit immediate (3 bits)"  (all-mep-core-isas) h-uint  f-3u5)
-(dnop uimm4     "bCC const (4 bits)"      (all-mep-core-isas) h-uint  f-4u8)
-(dnop uimm5     "bit/shift val (5 bits)"  (all-mep-core-isas) h-uint  f-5u8)
-
-(dpop udisp7    "tp-rel b (7 bits)"       (all-mep-core-isas)           h-uint  f-7u9      "unsigned7")
-(dpop udisp7a2  "tp-rel h (7 bits)"       (all-mep-core-isas (ALIGN 2)) h-uint  f-7u9a2    "unsigned7")
-(dpop udisp7a4  "tp/sp-rel w (7 bits)"    (all-mep-core-isas (ALIGN 4)) h-uint  f-7u9a4    "unsigned7")
-(dpop uimm7a4   "sp w-addend (7 bits)"    (all-mep-core-isas (ALIGN 4)) h-uint  f-7u9a4    "mep_alignu")
-
-(dnop uimm24    "immediate (24 bits)"     (all-mep-core-isas) h-uint  f-24u8n)
-
-(dnop cimm4     "cache immed'te (4 bits)" (all-mep-core-isas) h-uint  f-rn)
-(dnop cimm5     "clip immediate (5 bits)" (all-mep-core-isas) h-uint  f-5u24)
-(dnop cdisp8    "copro addend (8 bits)"   (all-mep-core-isas) h-sint  f-8s24)
-(dpop cdisp8a2  "copro addend (8 bits)"   (all-mep-core-isas (ALIGN 2)) h-sint  f-8s24a2   "mep_align")
-(dpop cdisp8a4  "copro addend (8 bits)"   (all-mep-core-isas (ALIGN 4)) h-sint  f-8s24a4   "mep_align")
-(dpop cdisp8a8  "copro addend (8 bits)"   (all-mep-core-isas (ALIGN 8)) h-sint  f-8s24a8   "mep_align")
-
-; Special operand representing the various ways that the literal zero can be
-; specified.
-(define-full-operand
-  zero "Zero operand" (all-mep-core-isas) h-sint DFLT f-nil
-  ((parse "zero")) () ()
-)
-
-; Attributes.
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_BIT_INSN)
-  (comment "optional bit manipulation instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_MUL_INSN)
-  (comment "optional 32-bit multiply instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_DIV_INSN)
-  (comment "optional 32-bit divide instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_DEBUG_INSN)
-  (comment "optional debug instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_LDZ_INSN)
-  (comment "optional leading zeroes instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_ABS_INSN)
-  (comment "optional absolute difference instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_AVE_INSN)
-  (comment "optional average instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_MINMAX_INSN)
-  (comment "optional min/max instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_CLIP_INSN)
-  (comment "optional clipping instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_SAT_INSN)
-  (comment "optional saturation instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_UCI_INSN)
-  (comment "optional UCI instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_DSP_INSN)
-  (comment "optional DSP instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_CP_INSN)
-  (comment "optional coprocessor-related instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_CP64_INSN)
-  (comment "optional coprocessor-related 64 data bit instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name OPTIONAL_VLIW64)
-  (comment "optional vliw64 mode (vliw32 is default)"))
-
-(define-attr
-  (for insn)
-  (type enum)
-  (name STALL)
-  (attrs META)
-  (values NONE SHIFTI INT2 LOAD STORE LDC STC LDCB STCB SSARB FSFT RET
-	  ADVCK MUL MULR DIV)
-  (default NONE)
-  (comment "gcc stall attribute"))
-
-(define-attr
-  (for insn)
-  (type string)
-  (name INTRINSIC)
-  (attrs META)
-  (comment "gcc intrinsic name"))
-
-(define-attr
-  (for insn)
-  (type enum)
-  (name SLOT)
-  (attrs META)
-  (values NONE C3 V1 V3)
-  (default NONE)
-  (comment "coprocessor slot type"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name MAY_TRAP)
-  (comment "instruction may generate an exception"))
-
-; Attributes for scheduling restrictions in vliw mode
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name VLIW_ALONE)
-  (comment "instruction can be scheduled alone in vliw mode"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name VLIW_NO_CORE_NOP)
-  (comment "there is no corresponding nop core instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name VLIW_NO_COP_NOP)
-  (comment "there is no corresponding nop coprocessor instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name VLIW64_NO_MATCHING_NOP)
-  (comment "there is no corresponding nop coprocessor instruction"))
-(define-attr
-  (for insn)
-  (type boolean)
-  (name VLIW32_NO_MATCHING_NOP)
-  (comment "there is no corresponding nop coprocessor instruction"))
-
-(define-attr
-  (for insn)
-  (type boolean)
-  (name VOLATILE)
-  (comment "Insn is volatile."))
-
-(define-attr
-  (for insn)
-  (type integer)
-  (name LATENCY)
-  (comment "The latency of this insn, used for scheduling as an intrinsic in gcc")
-  (default 0))
-
-; The MeP config tool will edit this.
-(define-attr
-  (type enum)
-  (for insn)
-  (name CONFIG)
-  (values NONE ; config-attr-start
-	simple
-	fmax
-	  ) ; config-attr-end
-)
-
-
-; Enumerations.
-
-(define-normal-insn-enum major "major opcodes" (all-mep-core-isas) MAJ_
-  f-major
-  (.map .str (.iota 16))
-)
-
-
-(define-pmacro (dni-isa xname xcomment xattrs xsyntax xformat xsemantics xtiming isa)
-  (define-insn          
-    (name xname)        
-    (comment xcomment)
-    (.splice attrs (.unsplice xattrs) (ISA isa))
-    (syntax xsyntax)
-    (format xformat)
-    (semantics xsemantics)
-    (.splice timing (.unsplice xtiming))
-    )
-) 
-  
-(define-pmacro (dnmi-isa xname xcomment xattrs xsyntax xemit isa)
-  (dnmi xname xcomment (.splice (.unsplice xattrs) (ISA isa)) xsyntax xemit)
-)
-
-; For making profiling calls and dynamic configuration
-(define-pmacro (cg-profile caller callee)
-  (c-call "cg_profile" caller callee)
-)
-; For dynamic configuration only
-(define-pmacro (cg-profile-jump caller callee)
-  (c-call "cg_profile_jump" caller callee)
-)
-
-; For defining Core Instructions
-(define-pmacro (dnci xname xcomment xattrs xsyntax xformat xsemantics xtiming)
-  (dni-isa xname xcomment xattrs xsyntax xformat xsemantics xtiming all-core-isa-list)
-)
-(define-pmacro (dncmi xname xcomment xattrs xsyntax xemit)
-  (dnmi-isa xname xcomment xattrs xsyntax xemit all-core-isa-list)
-)
-
-; For defining Coprocessor Instructions
-;(define-pmacro (dncpi xname xcomment xattrs xsyntax xformat xsemantics xtiming)  (dni-isa xname xcomment xattrs xsyntax xformat xsemantics xtiming cop)
-;)
-
-;; flag setting macro
-(define-pmacro (set-bit xop xbitnum xval) 
-  (set xop (or 
-	    (and xop (inv (sll 1 xbitnum)))
-	    (and (sll 1 xbitnum) (sll xval xbitnum)))))
-
-;; some flags we commonly use in vliw reasoning / mode-switching etc.
-(define-pmacro (get-opt.vliw64) (and (srl opt 6) 1))
-(define-pmacro (get-opt.vliw32) (and (srl opt 5) 1))
-(define-pmacro (get-rm.lsb) (and rm 1))
-(define-pmacro (get-psw.om) (and (srl psw 12) 1))
-(define-pmacro (get-psw.nmi) (and (srl psw 9) 1))
-(define-pmacro (get-psw.iep) (and (srl psw 1) 1))
-(define-pmacro (get-psw.ump) (and (srl psw 3) 1))
-(define-pmacro (get-epc.etom) (and epc 1))
-(define-pmacro (get-npc.ntom) (and npc 1))
-(define-pmacro (get-lp.ltom) (and lp 1))
-
-(define-pmacro (set-psw.om zval) (set-bit (raw-reg h-csr 16) 12 zval))
-(define-pmacro (set-psw.nmi zval) (set-bit (raw-reg h-csr 16) 9 zval))
-(define-pmacro (set-psw.umc zval) (set-bit (raw-reg h-csr 16) 2 zval))
-(define-pmacro (set-psw.iec zval) (set-bit (raw-reg h-csr 16) 0 zval))
-(define-pmacro (set-rpe.elr zval) (set-bit (raw-reg h-csr 5) 0 zval))
-
-
-;; the "3 way switch" depending on our current operating mode and vliw status flags
-(define-pmacro (core-vliw-switch core-rtl vliw32-rtl vliw64-rtl) 
-  (cond
-   ((andif (get-psw.om) (get-opt.vliw64)) vliw64-rtl)
-   ((andif (get-psw.om) (get-opt.vliw32)) vliw32-rtl)
-   (else core-rtl)))
-
-;; the varying-pcrel idiom
-(define-pmacro (set-vliw-modified-pcrel-offset xtarg xa xb xc)
-  (core-vliw-switch (set xtarg (add pc xa))
-		    (set xtarg (add pc xb))
-		    (set xtarg (add pc xc))))
-
-;; the increasing-alignment idiom in branch displacements
-(define-pmacro (set-vliw-alignment-modified xtarg zaddr)
-  (core-vliw-switch (set xtarg (and zaddr (inv 1)))
-		    (set xtarg (and zaddr (inv 3)))
-		    (set xtarg (and zaddr (inv 7)))))
-
-;; the increasing-alignment idiom in option-only form
-(define-pmacro (set-vliw-aliignment-modified-by-option xtarg zaddr)
-  (if (get-opt.vliw32)
-      (set xtarg (and zaddr (inv 3)))
-      (set xtarg (and zaddr (inv 7)))))
-
-
-
-; Instructions.
-
-; A pmacro for use in semantic bodies of unimplemented insns.
-(define-pmacro (unimp mnemonic) (nop))
-
-; Core specific instructions
-; (include "mep-h1.cpu") ; -- exposed by MeP-Integrator
-
-; Load/store instructions.
-
-(dnci sb "store byte (register indirect)" ((STALL STORE))
-     "sb $rnc,($rma)"
-     (+ MAJ_0 rnc rma (f-sub4 8))
-     (sequence ()
-	       (c-call VOID "check_write_to_text" rma)
-	       (set (mem UQI rma) (and rnc #xff)))
-     ((mep (unit u-use-gpr (in usereg rnc))
-	   (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci sh "store half-word (register indirect)" ((STALL STORE))
-     "sh $rns,($rma)"
-     (+ MAJ_0 rns rma (f-sub4 9))
-     (sequence ()
-	       (c-call VOID "check_write_to_text" (and rma (inv 1)))
-	       (set (mem UHI (and rma (inv 1))) (and rns #xffff)))
-     ((mep (unit u-use-gpr (in usereg rns))
-	   (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci sw "store word (register indirect)" ((STALL STORE))
-     "sw $rnl,($rma)"
-     (+ MAJ_0 rnl rma (f-sub4 10))
-     (sequence ()
-	       (c-call VOID "check_write_to_text" (and rma (inv 3)))
-	       (set (mem USI (and rma (inv 3))) rnl))
-     ((mep (unit u-use-gpr (in usereg rnl))
-	   (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lb "load byte (register indirect)" ((STALL LOAD) (LATENCY 2))
-     "lb $rnc,($rma)"
-     (+ MAJ_0 rnc rma (f-sub4 12))
-     (set rnc (ext SI (mem QI rma)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rnc)))))
-
-(dnci lh "load half-word (register indirect)" ((STALL LOAD) (LATENCY 2))
-     "lh $rns,($rma)"
-     (+ MAJ_0 rns rma (f-sub4 13))
-     (set rns (ext SI (mem HI (and rma (inv 1)))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rns)))))
-
-(dnci lw "load word (register indirect)" ((STALL LOAD) (LATENCY 2))
-     "lw $rnl,($rma)"
-     (+ MAJ_0 rnl rma (f-sub4 14))
-     (set rnl (mem SI (and rma (inv 3))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rnl)))))
-
-(dnci lbu "load unsigned byte (register indirect)" ((STALL LOAD) (LATENCY 2))
-     "lbu $rnuc,($rma)"
-     (+ MAJ_0 rnuc rma (f-sub4 11))
-     (set rnuc (zext SI (mem UQI rma)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rnuc)))))
-
-(dnci lhu "load unsigned half-word (register indirect)" ((STALL LOAD) (LATENCY 2))
-     "lhu $rnus,($rma)"
-     (+ MAJ_0 rnus rma (f-sub4 15))
-     (set rnus (zext SI (mem UHI (and rma (inv 1)))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rnus)))))
-
-(dnci sw-sp "store word (sp relative)" ((STALL STORE))
-     "sw $rnl,$udisp7a4($spr)"
-     (+ MAJ_4 rnl (f-8 0) udisp7a4 (f-sub2 2))
-     (sequence ()
-	       (c-call VOID "check_write_to_text" (and (add udisp7a4 sp) (inv 3)))
-	       (set (mem SI (and (add udisp7a4 sp) (inv 3))) rnl))
-     ((mep (unit u-use-gpr (in usereg rnl))
-	   (unit u-use-gpr (in usereg sp))
-	   (unit u-exec))))
-
-
-(dnci lw-sp "load word (sp relative)" ((STALL LOAD) (LATENCY 2))
-     "lw $rnl,$udisp7a4($spr)"
-     (+ MAJ_4 rnl (f-8 0) udisp7a4 (f-sub2 3))
-     (set rnl (mem SI (and (add udisp7a4 sp) (inv 3))))
-     ((mep (unit u-use-gpr (in usereg sp))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rnl)))))
-
-(dnci sb-tp "store byte (tp relative)" ((STALL STORE))
-     "sb $rn3c,$udisp7($tpr)"
-     (+ MAJ_8 (f-4 0) rn3c (f-8 0) udisp7)
-     (sequence ()
-	       (c-call VOID "check_write_to_text" (add (zext SI udisp7) tp))
-	       (set (mem QI (add (zext SI udisp7) tp)) (and rn3c #xff)))
-     ((mep (unit u-use-gpr (in usereg rn3c))
-	   (unit u-use-gpr (in usereg tp))
-	   (unit u-exec))))
-
-(dnci sh-tp "store half-word (tp relative)" ((STALL STORE))
-     "sh $rn3s,$udisp7a2($tpr)"
-     (+ MAJ_8 (f-4 0) rn3s (f-8 1) udisp7a2 (f-15 0))
-     (sequence ()
-	       (c-call VOID "check_write_to_text" (and (add (zext SI udisp7a2) tp) (inv 1)))
-	       (set (mem HI (and (add (zext SI udisp7a2) tp) (inv 1))) (and rn3s #xffff)))
-     ((mep (unit u-use-gpr (in usereg rn3s))
-	   (unit u-use-gpr (in usereg tp))
-	   (unit u-exec))))
-
-(dnci sw-tp "store word (tp relative)" ((STALL STORE))
-     "sw $rn3l,$udisp7a4($tpr)"
-     (+ MAJ_4 (f-4 0) rn3l (f-8 1) udisp7a4 (f-sub2 2))
-     (sequence ()
-	       (c-call VOID "check_write_to_text" (and (add (zext SI udisp7a4) tp) (inv 3)))
-	       (set (mem SI (and (add (zext SI udisp7a4) tp) (inv 3))) rn3l))
-     ((mep (unit u-use-gpr (in usereg rn3l))
-	   (unit u-use-gpr (in usereg tp))
-	   (unit u-exec))))
-
-(dnci lb-tp "load byte (tp relative)" ((STALL LOAD) (LATENCY 2))
-     "lb $rn3c,$udisp7($tpr)"
-     (+ MAJ_8 (f-4 1) rn3c (f-8 0) udisp7)
-     (set rn3c (ext SI (mem QI (add (zext SI udisp7) tp))))
-     ((mep (unit u-use-gpr (in usereg tp))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rn3c)))))
-
-(dnci lh-tp "load half-word (tp relative)" ((STALL LOAD) (LATENCY 2))
-     "lh $rn3s,$udisp7a2($tpr)"
-     (+ MAJ_8 (f-4 1) rn3s (f-8 1) udisp7a2 (f-15 0))
-     (set rn3s (ext SI (mem HI (and (add (zext SI udisp7a2) tp) (inv 1)))))
-     ((mep (unit u-use-gpr (in usereg tp))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rn3s)))))
-
-(dnci lw-tp "load word (tp relative)" ((STALL LOAD) (LATENCY 2))
-     "lw $rn3l,$udisp7a4($tpr)"
-     (+ MAJ_4 (f-4 0) rn3l (f-8 1) udisp7a4 (f-sub2 3))
-     (set rn3l (mem SI (and (add (zext SI udisp7a4) tp) (inv 3))))
-     ((mep (unit u-use-gpr (in usereg tp))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rn3l)))))
-
-(dnci lbu-tp "load unsigned byte (tp relative)" ((STALL LOAD) (LATENCY 2))
-     "lbu $rn3uc,$udisp7($tpr)"
-     (+ MAJ_4 (f-4 1) rn3uc (f-8 1) udisp7)
-     (set rn3uc (zext SI (mem QI (add (zext SI udisp7) tp))))
-     ((mep (unit u-use-gpr (in usereg tp))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rn3uc)))))
-
-(dnci lhu-tp "load unsigned half-word (tp relative)" ((STALL LOAD) (LATENCY 2))
-     "lhu $rn3us,$udisp7a2($tpr)"
-     (+ MAJ_8 (f-4 1) rn3us (f-8 1) udisp7a2 (f-15 1))
-     (set rn3us (zext SI (mem HI (and (add (zext SI udisp7a2) tp) (inv 1)))))
-     ((mep (unit u-use-gpr (in usereg tp))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rn3us)))))
-
-(dnci sb16 "store byte (16 bit displacement)" ((STALL STORE))
-     "sb $rnc,$sdisp16($rma)"
-     (+ MAJ_12 rnc rma (f-sub4 8) sdisp16)
-     (sequence ()
-	       (c-call VOID "check_write_to_text" (add rma (ext SI sdisp16)))
-	       (set (mem QI (add rma (ext SI sdisp16))) (and rnc #xff)))
-     ((mep (unit u-use-gpr (in usereg rnc))
-	   (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci sh16 "store half-word (16 bit displacement)" ((STALL STORE))
-     "sh $rns,$sdisp16($rma)"
-     (+ MAJ_12 rns rma (f-sub4 9) sdisp16)
-     (sequence ()
-	       (c-call VOID "check_write_to_text" (and (add rma (ext SI sdisp16)) (inv 1)))
-	       (set (mem HI (and (add rma (ext SI sdisp16)) (inv 1))) (and rns #xffff)))
-     ((mep (unit u-use-gpr (in usereg rns))
-	   (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci sw16 "store word (16 bit displacement)" ((STALL STORE))
-     "sw $rnl,$sdisp16($rma)"
-     (+ MAJ_12 rnl rma (f-sub4 10) sdisp16)
-     (sequence ()
-	       (c-call "check_write_to_text" (and (add rma (ext SI sdisp16)) (inv 3)))
-	       (set (mem SI (and (add rma (ext SI sdisp16)) (inv 3))) rnl))
-     ((mep (unit u-use-gpr (in usereg rnl))
-	   (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lb16 "load byte (16 bit displacement)" ((STALL LOAD) (LATENCY 2))
-     "lb $rnc,$sdisp16($rma)"
-     (+ MAJ_12 rnc rma (f-sub4 12) sdisp16)
-     (set rnc (ext SI (mem QI (add rma (ext SI sdisp16)))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rnc)))))
-
-(dnci lh16 "load half-word (16 bit displacement)" ((STALL LOAD) (LATENCY 2))
-     "lh $rns,$sdisp16($rma)"
-     (+ MAJ_12 rns rma (f-sub4 13) sdisp16)
-     (set rns (ext SI (mem HI (and (add rma (ext SI sdisp16)) (inv 1)))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rns)))))
-
-(dnci lw16 "load word (16 bit displacement)" ((STALL LOAD) (LATENCY 2))
-     "lw $rnl,$sdisp16($rma)"
-     (+ MAJ_12 rnl rma (f-sub4 14) sdisp16)
-     (set rnl (mem SI (and (add rma (ext SI sdisp16)) (inv 3))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rnl)))))
-
-(dnci lbu16 "load unsigned byte (16 bit displacement)" ((STALL LOAD) (LATENCY 2))
-     "lbu $rnuc,$sdisp16($rma)"
-     (+ MAJ_12 rnuc rma (f-sub4 11) sdisp16)
-     (set rnuc (zext SI (mem QI (add rma (ext SI sdisp16)))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rnuc)))))
-
-(dnci lhu16 "load unsigned half-word (16 bit displacement)" ((STALL LOAD) (LATENCY 2))
-     "lhu $rnus,$sdisp16($rma)"
-     (+ MAJ_12 rnus rma (f-sub4 15) sdisp16)
-     (set rnus (zext SI (mem HI (and (add rma (ext SI sdisp16)) (inv 1)))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec)
-	   (unit u-load-gpr (out loadreg rnus)))))
-
-(dnci sw24 "store word (24 bit absolute addressing)" ((STALL STORE))
-     "sw $rnl,($addr24a4)"
-     (+ MAJ_14 rnl addr24a4 (f-sub2 2))
-     (sequence ()
-	       (c-call VOID "check_write_to_text" (zext SI addr24a4))
-	       (set (mem SI (zext SI addr24a4)) rnl))
-     ((mep (unit u-use-gpr (in usereg rnl))
-	   (unit u-exec))))
-
-(dnci lw24 "load word (24 bit absolute addressing)" ((STALL LOAD) (LATENCY 2))
-     "lw $rnl,($addr24a4)"
-     (+ MAJ_14 rnl addr24a4 (f-sub2 3))
-     (set rnl (mem SI (zext SI addr24a4)))
-     ((mep (unit u-exec)
-	   (unit u-load-gpr (out loadreg rnl)))))
-
-
-; Extension instructions.
-
-(dnci extb "sign extend byte" ()
-     "extb $rn"
-     (+ MAJ_1 rn (f-rm 0) (f-sub4 13))
-     (set rn (ext SI (and QI rn #xff)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci exth "sign extend half-word" ()
-     "exth $rn"
-     (+ MAJ_1 rn (f-rm 2) (f-sub4 13))
-     (set rn (ext SI (and HI rn #xffff)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci extub "zero extend byte" ()
-     "extub $rn"
-     (+ MAJ_1 rn (f-rm 8) (f-sub4 13))
-     (set rn (zext SI (and rn #xff)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci extuh "zero extend half-word" ()
-     "extuh $rn"
-     (+ MAJ_1 rn (f-rm 10) (f-sub4 13))
-     (set rn (zext SI (and rn #xffff)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-
-; Shift amount manipulation instructions.
-
-(dnci ssarb "set sar to bytes" ((STALL SSARB))
-     "ssarb $udisp2($rm)"
-     (+ MAJ_1 (f-4 0) (f-5 0) udisp2 rm (f-sub4 12))
-     (if (c-call BI "big_endian_p")
-         (set sar (zext SI (mul (and (add udisp2 rm) 3) 8)))
-         (set sar (sub 32 (zext SI (mul (and (add udisp2 rm) 3) 8)))))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-
-; Move instructions.
-
-(dnci mov "move" ()
-     "mov $rn,$rm"
-     (+ MAJ_0 rn rm (f-sub4 0))
-     (set rn rm)
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci movi8 "move 8-bit immediate" ()
-     "mov $rn,$simm8"
-     (+ MAJ_5 rn simm8)
-     (set rn (ext SI simm8))
-     ())
-
-(dnci movi16 "move 16-bit immediate" ()
-     "mov $rn,$simm16"
-     (+ MAJ_12 rn (f-rm 0) (f-sub4 1) simm16)
-     (set rn (ext SI simm16))
-     ())
-
-(dnci movu24 "move 24-bit unsigned immediate" ()
-     "movu $rn3,$uimm24"
-     (+ MAJ_13 (f-4 0) rn3 uimm24)
-     (set rn3 (zext SI uimm24))
-     ())
-
-(dnci movu16 "move 16-bit unsigned immediate" ()
-     "movu $rn,$uimm16"
-     (+ MAJ_12 rn (f-rm 1) (f-sub4 1) uimm16)
-     (set rn (zext SI uimm16))
-     ())
-
-(dnci movh "move high 16-bit immediate" ()
-     "movh $rn,$uimm16"
-     (+ MAJ_12 rn (f-rm 2) (f-sub4 1) uimm16)
-     (set rn (sll uimm16 16))
-     ())
-
-
-; Arithmetic instructions.
-
-(dnci add3 "add three registers" ()
-     "add3 $rl,$rn,$rm"
-     (+ MAJ_9 rn rm rl)
-     (set rl (add rn rm))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci add "add" ()
-     "add $rn,$simm6"
-     (+ MAJ_6 rn simm6 (f-sub2 0))
-     (set rn (add rn (ext SI simm6)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci add3i "add two registers and immediate" ()
-     "add3 $rn,$spr,$uimm7a4"
-     (+ MAJ_4 rn (f-8 0) uimm7a4 (f-sub2 0))
-     (set rn (add sp (zext SI uimm7a4)))
-     ((mep (unit u-use-gpr (in usereg sp))
-	   (unit u-exec))))
-
-(dnci advck3 "add overflow check" ((STALL ADVCK))
-     "advck3 \\$0,$rn,$rm"
-     (+ MAJ_0 rn rm (f-sub4 7))
-     (if (add-oflag rn rm 0)
-	 (set r0 1)
-	 (set r0 0))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci sub "subtract" ()
-     "sub $rn,$rm"
-     (+ MAJ_0 rn rm (f-sub4 4))
-     (set rn (sub rn rm))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm)))))
-
-(dnci sbvck3 "subtraction overflow check" ((STALL ADVCK))
-     "sbvck3 \\$0,$rn,$rm"
-     (+ MAJ_0 rn rm (f-sub4 5))
-     (if (sub-oflag rn rm 0)
-	 (set r0 1)
-	 (set r0 0))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci neg "negate" ()
-     "neg $rn,$rm"
-     (+ MAJ_0 rn rm (f-sub4 1))
-     (set rn (neg rm))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci slt3 "set if less than" ()
-     "slt3 \\$0,$rn,$rm"
-     (+ MAJ_0 rn rm (f-sub4 2))
-     (if (lt rn rm)
-	 (set r0 1)
-	 (set r0 0))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci sltu3 "set less than unsigned" ()
-     "sltu3 \\$0,$rn,$rm"
-     (+ MAJ_0 rn rm (f-sub4 3))
-     (if (ltu rn rm)
-	 (set r0 1)
-	 (set r0 0))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci slt3i "set if less than immediate" ()
-     "slt3 \\$0,$rn,$uimm5"
-     (+ MAJ_6 rn uimm5 (f-sub3 1))
-     (if (lt rn (zext SI uimm5))
-	 (set r0 1)
-	 (set r0 0))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci sltu3i "set if less than unsigned immediate" ()
-     "sltu3 \\$0,$rn,$uimm5"
-     (+ MAJ_6 rn uimm5 (f-sub3 5))
-     (if (ltu rn (zext SI uimm5))
-	 (set r0 1)
-	 (set r0 0))
-     ())
-
-(dnci sl1ad3 "shift left one and add" ((STALL INT2))
-     "sl1ad3 \\$0,$rn,$rm"
-     (+ MAJ_2 rn rm (f-sub4 6))
-     (set r0 (add (sll rn 1) rm))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci sl2ad3 "shift left two and add" ((STALL INT2))
-     "sl2ad3 \\$0,$rn,$rm"
-     (+ MAJ_2 rn rm (f-sub4 7))
-     (set r0 (add (sll rn 2) rm))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci add3x "three operand add (extended)" ()
-     "add3 $rn,$rm,$simm16"
-     (+ MAJ_12 rn rm (f-sub4 0) simm16)
-     (set rn (add rm (ext SI simm16)))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci slt3x "set if less than (extended)" ()
-     "slt3 $rn,$rm,$simm16"
-     (+ MAJ_12 rn rm (f-sub4 2) simm16)
-     (if (lt rm (ext SI simm16))
-	 (set rn 1)
-	 (set rn 0))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci sltu3x "set if less than unsigned (extended)" ()
-     "sltu3 $rn,$rm,$uimm16"
-     (+ MAJ_12 rn rm (f-sub4 3) uimm16)
-     (if (ltu rm (zext SI uimm16))
-	 (set rn 1)
-	 (set rn 0))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-
-; Logical instructions.
-
-(dnci or "bitwise or" ()
-     "or $rn,$rm"
-     (+ MAJ_1 rn rm (f-sub4 0))
-     (set rn (or rn rm))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci and "bitwise and" ()
-     "and $rn,$rm"
-     (+ MAJ_1 rn rm (f-sub4 1))
-     (set rn (and rn rm))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci xor "bitwise exclusive or" ()
-     "xor $rn,$rm"
-     (+ MAJ_1 rn rm (f-sub4 2))
-     (set rn (xor rn rm))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci nor "bitwise negated or" ()
-     "nor $rn,$rm"
-     (+ MAJ_1 rn rm (f-sub4 3))
-     (set rn (inv (or rn rm)))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci or3 "or three operand" ()
-     "or3 $rn,$rm,$uimm16"
-     (+ MAJ_12 rn rm (f-sub4 4) uimm16)
-     (set rn (or rm (zext SI uimm16)))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci and3 "and three operand" ()
-     "and3 $rn,$rm,$uimm16"
-     (+ MAJ_12 rn rm (f-sub4 5) uimm16)
-     (set rn (and rm (zext SI uimm16)))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci xor3 "exclusive or three operand" ()
-     "xor3 $rn,$rm,$uimm16"
-     (+ MAJ_12 rn rm (f-sub4 6) uimm16)
-     (set rn (xor rm (zext SI uimm16)))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-
-; Shift instructions.
-
-(dnci sra "shift right arithmetic" ((STALL INT2))
-     "sra $rn,$rm"
-     (+ MAJ_2 rn rm (f-sub4 13))
-     (set rn (sra rn (and rm #x1f)))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci srl "shift right logical" ((STALL INT2))
-     "srl $rn,$rm"
-     (+ MAJ_2 rn rm (f-sub4 12))
-     (set rn (srl rn (and rm #x1f)))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci sll "shift left logical" ((STALL INT2))
-     "sll $rn,$rm"
-     (+ MAJ_2 rn rm (f-sub4 14))
-     (set rn (sll rn (and rm #x1f)))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-(dnci srai "shift right arithmetic (immediate)" ((STALL SHIFTI))
-     "sra $rn,$uimm5"
-     (+ MAJ_6 rn uimm5 (f-sub3 3))
-     (set rn (sra rn uimm5))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci srli "shift right logical (immediate)" ((STALL SHIFTI))
-     "srl $rn,$uimm5"
-     (+ MAJ_6 rn uimm5 (f-sub3 2))
-     (set rn (srl rn uimm5))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci slli "shift left logical (immediate)" ((STALL SHIFTI))
-     "sll $rn,$uimm5"
-     (+ MAJ_6 rn uimm5 (f-sub3 6))
-     (set rn (sll rn uimm5))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci sll3 "three-register shift left logical" ((STALL INT2))
-     "sll3 \\$0,$rn,$uimm5"
-     (+ MAJ_6 rn uimm5 (f-sub3 7))
-     (set r0 (sll rn uimm5))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci fsft "field shift" ((STALL FSFT))
-     "fsft $rn,$rm"
-     (+ MAJ_2 rn rm (f-sub4 15))
-     (sequence ((DI temp) (QI shamt))
-	       (set shamt (and sar #x3f))
-	       (set temp (sll (or (sll (zext DI rn) 32) (zext DI rm)) shamt))
-	       (set rn (subword SI (srl temp 32) 1)))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-
-; Branch/jump instructions.
-
-(dnci bra "branch" (RELAXABLE)
-     "bra $pcrel12a2"
-     (+ MAJ_11 pcrel12a2 (f-15 0))
-     (set-vliw-alignment-modified pc pcrel12a2)
-     ((mep (unit u-branch)
-	   (unit u-exec))))
-
-(dnci beqz "branch if equal zero" (RELAXABLE)
-     "beqz $rn,$pcrel8a2"
-     (+ MAJ_10 rn pcrel8a2 (f-15 0))
-     (if (eq rn 0)
-	 (set-vliw-alignment-modified pc pcrel8a2))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec)
-	   (unit u-branch))))
-
-(dnci bnez "branch if not equal zero" (RELAXABLE)
-     "bnez $rn,$pcrel8a2"
-     (+ MAJ_10 rn pcrel8a2 (f-15 1))
-     (if (ne rn 0)
-	 (set-vliw-alignment-modified pc pcrel8a2))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec)
-	   (unit u-branch))))
-
-(dnci beqi "branch equal immediate" (RELAXABLE)
-     "beqi $rn,$uimm4,$pcrel17a2"
-     (+ MAJ_14 rn uimm4 (f-sub4 0) pcrel17a2)
-     (if (eq rn (zext SI uimm4))
-	 (set-vliw-alignment-modified pc pcrel17a2))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec)
-	   (unit u-branch))))
-
-(dnci bnei "branch not equal immediate" (RELAXABLE)
-     "bnei $rn,$uimm4,$pcrel17a2"
-     (+ MAJ_14 rn uimm4 (f-sub4 4) pcrel17a2)
-     (if (ne rn (zext SI uimm4))
-	 (set-vliw-alignment-modified pc pcrel17a2))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec)
-	   (unit u-branch))))
-
-(dnci blti "branch less than immediate" (RELAXABLE)
-     "blti $rn,$uimm4,$pcrel17a2"
-     (+ MAJ_14 rn uimm4 (f-sub4 12) pcrel17a2)
-     (if (lt rn (zext SI uimm4))
-	 (set-vliw-alignment-modified pc pcrel17a2))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec)
-	   (unit u-branch))))
-
-(dnci bgei "branch greater than immediate" (RELAXABLE)
-     "bgei $rn,$uimm4,$pcrel17a2"
-     (+ MAJ_14 rn uimm4 (f-sub4 8) pcrel17a2)
-     (if (ge rn (zext SI uimm4))
-	 (set-vliw-alignment-modified pc pcrel17a2))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec)
-	   (unit u-branch))))
-
-(dnci beq "branch equal" ()
-     "beq $rn,$rm,$pcrel17a2"
-     (+ MAJ_14 rn rm (f-sub4 1) pcrel17a2)
-     (if (eq rn rm)
-	 (set-vliw-alignment-modified pc pcrel17a2))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-branch))))
-
-(dnci bne "branch not equal" ()
-     "bne $rn,$rm,$pcrel17a2"
-     (+ MAJ_14 rn rm (f-sub4 5) pcrel17a2)
-     (if (ne rn rm)
-	 (set-vliw-alignment-modified pc pcrel17a2))
-     ((mep (unit u-use-gpr (in usereg rn))
-           (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-branch))))
-
-(dnci bsr12 "branch to subroutine (12 bit displacement)" (RELAXABLE)
-     "bsr $pcrel12a2"
-     (+ MAJ_11 pcrel12a2 (f-15 1))
-     (sequence ()
-	       (cg-profile pc pcrel12a2)
-	       (set-vliw-modified-pcrel-offset lp 2 4 8)
-	       (set-vliw-alignment-modified pc pcrel12a2))
-     ((mep (unit u-exec)
-	   (unit u-branch))))
-
-(dnci bsr24 "branch to subroutine (24 bit displacement)" ()
-     "bsr $pcrel24a2"
-     (+ MAJ_13 (f-4 1) (f-sub4 9) pcrel24a2)
-     (sequence ()
-	       (cg-profile pc pcrel24a2)
-	       (set-vliw-modified-pcrel-offset lp 4 4 8)
-	       (set-vliw-alignment-modified pc pcrel24a2))
-     ((mep (unit u-exec)
-	   (unit u-branch))))
-
-(dnci jmp "jump" ()
-     "jmp $rm"
-     (+ MAJ_1 (f-rn 0) rm (f-sub4 14))
-     (sequence ()
-	       (if (eq (get-psw.om) 0)
-		   ;; core mode
-		   (if (get-rm.lsb)
-		       (sequence ()
-				 (set-psw.om 1) ;; enter VLIW mode
-				 (set-vliw-aliignment-modified-by-option pc rm))
-		       (set pc (and rm (inv 1))))
-		   ;; VLIW mode
-		   (if (get-rm.lsb)
-		       (sequence ()
-				 (set-psw.om 0) ;; enter core mode
-				 (set pc (and rm (inv 1))))
-		       (set-vliw-aliignment-modified-by-option pc rm)))
-	       (cg-profile-jump pc rm))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-branch))))
-
-(dnci jmp24 "jump (24 bit target)" ()
-     "jmp $pcabs24a2"
-     (+ MAJ_13 (f-4 1) (f-sub4 8) pcabs24a2)
-     (sequence ()
-	       (set-vliw-alignment-modified pc (or (and pc #xf0000000) pcabs24a2))
-	       (cg-profile-jump pc pcabs24a2))
-     ((mep (unit u-exec)
-	   (unit u-branch))))
-
-(dnci jsr "jump to subroutine" ()
-     "jsr $rm"
-     (+ MAJ_1 (f-rn 0) rm (f-sub4 15))
-     (sequence ()
-	       (cg-profile pc rm)
-	       (set-vliw-modified-pcrel-offset lp 2 4 8)
-	       (set-vliw-alignment-modified pc rm))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-branch))))
-
-(dnci ret "return from subroutine" ((STALL RET))
-     "ret"
-     (+ MAJ_7 (f-rn 0) (f-rm 0) (f-sub4 2))
-     (sequence ()
-	       (if (eq (get-psw.om) 0)
-		   ;; core mode
-		   (if (get-lp.ltom) ;; link-pointer "toggle mode" bit
-		       (sequence ()
-				 (set-psw.om 1) ;; enter VLIW mode
-				 (set-vliw-aliignment-modified-by-option pc lp))
-		       (set pc (and lp (inv 1))))
-		   ;; VLIW mode
-		   (if (get-lp.ltom) ;; link-pointer "toggle mode" bit
-		       (sequence ()
-				 (set-psw.om 0) ;; enter VLIW mode
-				 (set pc (and lp (inv 1))))
-		       (set-vliw-aliignment-modified-by-option pc lp)))
-	       (c-call VOID "notify_ret" pc))
-     ((mep (unit u-exec)
-	   (unit u-branch))))
-
-
-; Repeat instructions.
-
-(dnci repeat "repeat specified repeat block" ()
-     "repeat $rn,$pcrel17a2"
-     (+ MAJ_14 rn (f-rm 0) (f-sub4 9) pcrel17a2)
-     (sequence ()
-	       (set-vliw-modified-pcrel-offset (reg h-csr 4) 4 4 8)
-	       (set-vliw-alignment-modified (reg h-csr 5) pcrel17a2)
-	       (set (reg h-csr 6) rn))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci erepeat "endless repeat" ()
-     "erepeat $pcrel17a2"
-     (+ MAJ_14 (f-rn 0) (f-rm 1) (f-sub4 9) pcrel17a2)
-     (sequence ()
-	       (set-vliw-modified-pcrel-offset (reg h-csr 4) 4 4 8)
-	       (set-vliw-alignment-modified (reg h-csr 5) pcrel17a2)
-	       (set-rpe.elr 1)
-	       ; rpc may be undefined for erepeat
-	       ; use 1 to trigger repeat logic in the sim's main loop
-	       (set (reg h-csr 6) 1))
-     ())
-
-
-; Control instructions.
-
-;; special store variants
-
-(dnci stc_lp "store to control register lp" ((STALL STC))
-      "stc $rn,\\$lp" 
-      (+ MAJ_7 rn (f-csrn-lo 1) (f-csrn-hi 0) (f-12 1) (f-13 0) (f-14 0))  
-      (set lp rn)     
-      ((mep (unit u-use-gpr (in usereg rn))
-	    (unit u-store-ctrl-reg (out storereg lp))
-	    (unit u-exec))))
-
-(dnci stc_hi "store to control register hi" ((STALL STC))
-      "stc $rn,\\$hi" 
-      (+ MAJ_7 rn (f-csrn-lo 7) (f-csrn-hi 0) (f-12 1) (f-13 0) (f-14 0))  
-      (set hi rn)     
-      ((mep (unit u-use-gpr (in usereg rn))
-	    (unit u-store-ctrl-reg (out storereg hi))
-	    (unit u-exec))))
-
-(dnci stc_lo "store to control register lo" ((STALL STC))
-      "stc $rn,\\$lo" 
-      (+ MAJ_7 rn (f-csrn-lo 8) (f-csrn-hi 0) (f-12 1) (f-13 0) (f-14 0))  
-      (set lo rn)    
-      ((mep (unit u-use-gpr (in usereg rn))
-	    (unit u-store-ctrl-reg (out storereg lo))
-	    (unit u-exec))))
-
-;; general store
-
-(dnci stc "store to control register" (VOLATILE (STALL STC))
-     "stc $rn,$csrn"
-     (+ MAJ_7 rn csrn (f-12 1) (f-13 0) (f-14 0))
-     (set csrn rn)
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-store-ctrl-reg (out storereg csrn))
-	   (unit u-exec))))
-
-;; special load variants 
-
-(dnci ldc_lp "load from control register lp" ((STALL LDC))
-      "ldc $rn,\\$lp"    
-      (+ MAJ_7 rn (f-csrn-lo 1) (f-csrn-hi 0) (f-12 1) (f-13 0) (f-14 1))     
-      (set rn lp)     
-      ((mep (unit u-use-ctrl-reg (in usereg lp))
-	    (unit u-exec)
-	    (unit u-load-gpr (out loadreg rn)))))
-       
-
-(dnci ldc_hi "load from control register hi" ((STALL LDC))
-      "ldc $rn,\\$hi"    
-      (+ MAJ_7 rn (f-csrn-lo 7) (f-csrn-hi 0) (f-12 1) (f-13 0) (f-14 1))
-      (set rn hi)
-      ((mep (unit u-use-ctrl-reg (in usereg hi))
-	    (unit u-exec)
-	    (unit u-load-gpr (out loadreg rn)))))
-
-(dnci ldc_lo "load from control register lo" ((STALL LDC))
-      "ldc $rn,\\$lo"
-      (+ MAJ_7 rn (f-csrn-lo 8) (f-csrn-hi 0) (f-12 1) (f-13 0) (f-14 1))     
-      (set rn lo)
-      ((mep (unit u-use-ctrl-reg (in usereg lo))
-	    (unit u-exec)
-	    (unit u-load-gpr (out loadreg rn)))))
-
-;; general load
-
-(dnci ldc "load from control register" (VOLATILE (STALL LDC) (LATENCY 2))
-     "ldc $rn,$csrn"
-     (+ MAJ_7 rn csrn (f-12 1) (f-13 0) (f-14 1))
-     (if (eq (ifield f-csrn) 0) 
-	 ;; loading from the pc
-	 (set-vliw-modified-pcrel-offset rn 2 4 8)
-	 ;; loading from something else
-	 (set rn csrn))
-      ((mep (unit u-use-ctrl-reg (in usereg csrn))
-	    (unit u-exec)
-	    (unit u-load-gpr (out loadreg rn)))))
-
-(dnci di "disable interrupt" (VOLATILE)
-     "di"
-     (+ MAJ_7 (f-rn 0) (f-rm 0) (f-sub4 0))
-     ; clear psw.iec
-     (set psw (sll (srl psw 1) 1)) 
-     ())
-
-(dnci ei "enable interrupt" (VOLATILE)
-     "ei"
-     (+ MAJ_7 (f-rn 0) (f-rm 1) (f-sub4 0))
-     ; set psw.iec
-     (set psw (or psw 1))
-     ())
-
-(dnci reti "return from interrupt" ((STALL RET))
-     "reti"
-     (+ MAJ_7 (f-rn 0) (f-rm 1) (f-sub4 2))
-     (if (eq (get-psw.om) 0)
-	 ;; core operation mode
-	 (if (get-psw.nmi)
-	     ;; return from NMI
-	     (if (get-npc.ntom)
-		 ;; return in VLIW operation mode
-		 (sequence ()
-			   (set-psw.om 1)
-			   (set-vliw-aliignment-modified-by-option pc npc)
-			   (set-psw.nmi 0))
-		 ;; return in core mode
-		 (sequence ()
-			   (set pc (and npc (inv 1)))
-			   (set-psw.nmi 0)))
-	     ;; return from non-NMI
-	     (if (get-epc.etom)
-		 ;; return in VLIW mode
-		 (sequence () 
-			   (set-psw.om 1)
-			   (set-vliw-aliignment-modified-by-option pc epc)
-			   (set-psw.umc (get-psw.ump))
-			   (set-psw.iec (get-psw.iep)))
-		 ;; return in core mode
-		 (sequence ()
-			   (set pc (and epc (inv 1)))
-			   (set-psw.umc (get-psw.ump))
-			   (set-psw.iec (get-psw.iep)))))
-	 ;; VLIW operation mode
-	 ;; xxx undefined
-	 (nop))
-     ((mep (unit u-exec)
-	   (unit u-branch))))
-
-(dnci halt "halt pipeline" (VOLATILE)
-     "halt"
-     (+ MAJ_7 (f-rn 0) (f-rm 2) (f-sub4 2))
-     ; set psw.halt
-     (set (raw-reg h-csr 16) (or psw (sll 1 11)))
-     ())
-
-(dnci sleep "sleep pipeline" (VOLATILE)
-     "sleep"
-     (+ MAJ_7 (f-rn 0) (f-rm 6) (f-sub4 2))
-     (c-call VOID "do_sleep")
-     ())
-
-(dnci swi "software interrupt" (MAY_TRAP VOLATILE)
-     "swi $uimm2"
-     (+ MAJ_7 (f-rn 0) (f-8 0) (f-9 0) uimm2 (f-sub4 6))
-     (cond
-      ((eq uimm2 0) (set exc (or exc (sll 1 4))))
-      ((eq uimm2 1) (set exc (or exc (sll 1 5))))
-      ((eq uimm2 2) (set exc (or exc (sll 1 6))))
-      ((eq uimm2 3) (set exc (or exc (sll 1 7)))))
-     ())
-
-(dnci break "break exception" (MAY_TRAP VOLATILE)
-     "break"
-     (+ MAJ_7 (f-rn 0) (f-rm 3) (f-sub4 2))
-     (set pc (c-call USI "break_exception" pc))
-     ((mep (unit u-exec)
-	   (unit u-branch))))
-
-(dnci syncm "synchronise with memory" (VOLATILE)
-     "syncm"
-     (+ MAJ_7 (f-rn 0) (f-rm 1) (f-sub4 1))
-     (unimp "syncm")
-     ())
-
-(dnci stcb "store in control bus space" (VOLATILE (STALL STCB))
-     "stcb $rn,$uimm16"
-     (+ MAJ_15 rn (f-rm 0) (f-sub4 4) uimm16)
-     (c-call VOID "do_stcb" rn uimm16)
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec)
-	   (unit u-stcb))))
-
-(dnci ldcb "load from control bus space" (VOLATILE (STALL LDCB) (LATENCY 3))
-     "ldcb $rn,$uimm16"
-     (+ MAJ_15 rn (f-rm 1) (f-sub4 4) uimm16)
-     (set rn (c-call SI "do_ldcb" uimm16))
-      ((mep (unit u-ldcb)
-	    (unit u-exec)
-	    (unit u-ldcb-gpr (out loadreg rn)))))
-
-
-; Bit manipulation instructions.
-; The following instructions become the reserved instruction when the
-; bit manipulation option is off.
-
-(dnci bsetm "set bit in memory" (OPTIONAL_BIT_INSN)
-     "bsetm ($rma),$uimm3"
-     (+ MAJ_2 (f-4 0) uimm3 rma (f-sub4 0))
-     (sequence ()
-	       (c-call "check_option_bit" pc)
-	       (set (mem UQI rma) (or (mem UQI rma) (sll 1 uimm3))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci bclrm "clear bit in memory" (OPTIONAL_BIT_INSN)
-     "bclrm ($rma),$uimm3"
-     (+ MAJ_2 (f-4 0) uimm3 rma (f-sub4 1))
-     (sequence ()
-	       (c-call "check_option_bit" pc)
-	       (set (mem UQI rma) (and (mem UQI rma) (inv (sll 1 uimm3)))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci bnotm "toggle bit in memory" (OPTIONAL_BIT_INSN)
-     "bnotm ($rma),$uimm3"
-     (+ MAJ_2 (f-4 0) uimm3 rma (f-sub4 2))
-     (sequence ()
-	       (c-call "check_option_bit" pc)
-	       (set (mem UQI rma) (xor (mem UQI rma) (sll 1 uimm3))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci btstm "test bit in memory" (OPTIONAL_BIT_INSN)
-     "btstm \\$0,($rma),$uimm3"
-     (+ MAJ_2 (f-4 0) uimm3 rma (f-sub4 3))
-     (sequence ()
-	       (c-call "check_option_bit" pc)
-	       (set r0 (zext SI (and UQI (mem UQI rma) (sll 1 uimm3)))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci tas "test and set" (OPTIONAL_BIT_INSN)
-     "tas $rn,($rma)"
-     (+ MAJ_2 rn rma (f-sub4 4))
-     (sequence ((SI result))
-	       (c-call "check_option_bit" pc)
-	       (set result (zext SI (mem UQI rma)))
-	       (set (mem UQI rma) 1)
-	       (set rn result))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-
-; Data cache instruction.
-
-(dnci cache "cache operations" (VOLATILE)
-     "cache $cimm4,($rma)"
-     (+ MAJ_7 cimm4 rma (f-sub4 4))
-     (c-call VOID "do_cache" cimm4 rma pc)
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-
-; Multiply instructions.
-; These instructions become the RI when the 32-bit multiply
-; instruction option is off.
-
-(dnci mul "multiply" (OPTIONAL_MUL_INSN (STALL MUL))
-     "mul $rn,$rm"
-     (+ MAJ_1 rn rm (f-sub4 4))
-     (sequence ((DI result))
-	       (c-call "check_option_mul" pc)
-	       (set result (mul (ext DI rn) (ext DI rm)))
-	       (set hi (subword SI result 0))
-	       (set lo (subword SI result 1)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-multiply))))
-
-(dnci mulu "multiply unsigned" (OPTIONAL_MUL_INSN (STALL MUL))
-     "mulu $rn,$rm"
-     (+ MAJ_1 rn rm (f-sub4 5))
-     (sequence ((DI result))
-	       (c-call "check_option_mul" pc)
-	       (set result (mul (zext UDI rn) (zext UDI rm)))
-	       (set hi (subword SI result 0))
-	       (set lo (subword SI result 1)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-multiply))))
-
-(dnci mulr "multiply, lo -> reg" (OPTIONAL_MUL_INSN (STALL MULR) (LATENCY 3))
-     "mulr $rn,$rm"
-     (+ MAJ_1 rn rm (f-sub4 6))
-     (sequence ((DI result))
-	       (c-call "check_option_mul" pc)
-	       (set result (mul (ext DI rn) (ext DI rm)))
-	       (set hi (subword SI result 0))
-	       (set lo (subword SI result 1))
-	       (set rn (subword SI result 1)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-multiply)
-	   (unit u-mul-gpr (out resultreg rn)))))
-
-(dnci mulru "multiply unsigned, lo -> reg" (OPTIONAL_MUL_INSN (STALL MULR) (LATENCY 3))
-     "mulru $rn,$rm"
-     (+ MAJ_1 rn rm (f-sub4 7))
-     (sequence ((DI result))
-	       (c-call "check_option_mul" pc)
-	       (set result (mul (zext UDI rn) (zext UDI rm)))
-	       (set hi (subword SI result 0))
-	       (set lo (subword SI result 1))
-	       (set rn (subword SI result 1)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-multiply)
-	   (unit u-mul-gpr (out resultreg rn)))))
-
-(dnci madd "multiply accumulate" (OPTIONAL_MUL_INSN (STALL MUL))
-     "madd $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 #x3004))
-     (sequence ((DI result))
-	       (c-call "check_option_mul" pc)
-	       (set result (or (sll (zext DI hi) 32) (zext DI lo)))
-	       (set result (add result (mul (ext DI rn) (ext DI rm))))
-	       (set hi (subword SI result 0))
-	       (set lo (subword SI result 1)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-multiply))))
-
-(dnci maddu "multiply accumulate unsigned" (OPTIONAL_MUL_INSN (STALL MUL))
-     "maddu $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 #x3005))
-     (sequence ((DI result))
-	       (c-call "check_option_mul" pc)
-	       (set result (or (sll (zext DI hi) 32) (zext DI lo)))
-	       (set result (add result (mul (zext UDI rn) (zext UDI rm))))
-	       (set hi (subword SI result 0))
-	       (set lo (subword SI result 1)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-multiply))))
-
-
-(dnci maddr "multiply accumulate, lo -> reg" (OPTIONAL_MUL_INSN (STALL MULR) (LATENCY 3))
-     "maddr $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 #x3006))
-     (sequence ((DI result))
-	       (c-call "check_option_mul" pc)
-	       (set result (or (sll (zext DI hi) 32) (zext DI lo)))
-	       (set result (add result (mul (ext DI rn) (ext DI rm))))
-	       (set hi (subword SI result 0))
-	       (set lo (subword SI result 1))
-	       (set rn (subword SI result 1)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-multiply)
-	   (unit u-mul-gpr (out resultreg rn)))))
-
-(dnci maddru "multiple accumulate unsigned, lo -> reg" (OPTIONAL_MUL_INSN (STALL MULR) (LATENCY 3))
-     "maddru $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 #x3007))
-     (sequence ((DI result))
-	       (c-call "check_option_mul" pc)
-	       (set result (or (sll (zext DI hi) 32) (zext DI lo)))
-	       (set result (add result (mul (zext UDI rn) (zext UDI rm))))
-	       (set hi (subword SI result 0))
-	       (set lo (subword SI result 1))
-	       (set rn (subword SI result 1)))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-multiply)
-	   (unit u-mul-gpr (out resultreg rn)))))
-
-
-; Divide instructions.
-; These instructions become the RI when the 32-bit divide instruction
-; option is off.
-
-(dnci div "divide" (OPTIONAL_DIV_INSN (STALL DIV) (LATENCY 34) MAY_TRAP)
-     "div $rn,$rm"
-     (+ MAJ_1 rn rm (f-sub4 8))
-     (sequence ()
-	       (c-call "check_option_div" pc)
-	       (if (eq rm 0)
-		   (set pc (c-call USI "zdiv_exception" pc))
-		   ; Special case described on p. 76.
-		   (if (and (eq rn #x80000000)
-			    (eq rm #xffffffff))
-		       (sequence ()
-				 (set lo #x80000000)
-				 (set hi 0))
-		       (sequence ()
-				 (set lo (div rn rm))
-				 (set hi (mod rn rm))))))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-divide)
-           (unit u-branch))))
-
-(dnci divu "divide unsigned" (OPTIONAL_DIV_INSN (STALL DIV) (LATENCY 34) MAY_TRAP)
-     "divu $rn,$rm"
-     (+ MAJ_1 rn rm (f-sub4 9))
-     (sequence ()
-	       (c-call "check_option_div" pc)
-	       (if (eq rm 0)
-		   (set pc (c-call USI "zdiv_exception" pc))
-		   (sequence ()
-			     (set lo (udiv rn rm))
-			     (set hi (umod rn rm)))))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-divide)
-           (unit u-branch))))
-
-
-; Debug functions.
-; These instructions become the RI when the debug function option is
-; off.
-
-(dnci dret "return from debug exception" (OPTIONAL_DEBUG_INSN)
-     "dret"
-     (+ MAJ_7 (f-rn 0) (f-rm 1) (f-sub4 3))
-     (sequence ()
-	       (c-call "check_option_debug" pc)
-	       ; set DBG.DM.
-	       (set dbg (and dbg (inv (sll SI 1 15))))
-	       (set pc depc))
-     ((mep (unit u-exec)
-	   (unit u-branch))))
-
-(dnci dbreak "generate debug exception" (OPTIONAL_DEBUG_INSN MAY_TRAP VOLATILE)
-     "dbreak"
-     (+ MAJ_7 (f-rn 0) (f-rm 3) (f-sub4 3))
-     (sequence ()
-	       (c-call "check_option_debug" pc)
-	       ; set DBG.DPB.
-	       (set dbg (or dbg 1)))
-     ())
-
-
-; Leading zero instruction.
-
-(dnci ldz "leading zeroes" (OPTIONAL_LDZ_INSN (STALL INT2))
-     "ldz $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 0))
-     (sequence ()
-	       (c-call "check_option_ldz" pc)
-	       (set rn (c-call SI "do_ldz" rm)))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec))))
-
-
-; Absolute difference instruction.
-
-(dnci abs "absolute difference" (OPTIONAL_ABS_INSN (STALL INT2))
-     "abs $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 3))
-     (sequence ()
-	       (c-call "check_option_abs" pc)
-	       (set rn (abs (sub rn rm))))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-
-; Average instruction.
-
-(dnci ave "average" (OPTIONAL_AVE_INSN (STALL INT2))
-     "ave $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 2))
-     (sequence ()
-	       (c-call "check_option_ave" pc)
-	       (set rn (sra (add (add rn rm) 1) 1)))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-
-; MIN/MAX instructions.
-
-(dnci min "minimum" (OPTIONAL_MINMAX_INSN (STALL INT2))
-     "min $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 4))
-     (sequence ()
-	       (c-call "check_option_minmax" pc)
-	       (if (gt rn rm)
-		   (set rn rm)))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci max "maximum" (OPTIONAL_MINMAX_INSN (STALL INT2))
-     "max $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 5))
-     (sequence ()
-	       (c-call "check_option_minmax" pc)
-	       (if (lt rn rm)
-		   (set rn rm)))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci minu "minimum unsigned" (OPTIONAL_MINMAX_INSN (STALL INT2))
-     "minu $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 6))
-     (sequence ()
-	       (c-call "check_option_minmax" pc)
-	       (if (gtu rn rm)
-		   (set rn rm)))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci maxu "maximum unsigned" (OPTIONAL_MINMAX_INSN (STALL INT2))
-     "maxu $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 7))
-     (sequence ()
-	       (c-call "check_option_minmax" pc)
-	       (if (ltu rn rm)
-		   (set rn rm)))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-
-; Clipping instruction.
-
-(dnci clip "clip" (OPTIONAL_CLIP_INSN (STALL INT2))
-     "clip $rn,$cimm5"
-     (+ MAJ_15 rn (f-rm 0) (f-sub4 1) (f-ext #x10) cimm5 (f-29 0) (f-30 0) (f-31 0))
-     (sequence ((SI min) (SI max))
-	       (c-call "check_option_clip" pc)
-	       (set max (sub (sll 1 (sub cimm5 1)) 1))
-	       (set min (neg (sll 1 (sub cimm5 1))))
-	       (cond
-		((eq cimm5 0) (set rn 0))
-		((gt rn max) (set rn max))
-		((lt rn min) (set rn min))))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci clipu "clip unsigned" (OPTIONAL_CLIP_INSN (STALL INT2))
-     "clipu $rn,$cimm5"
-     (+ MAJ_15 rn (f-rm 0) (f-sub4 1) (f-ext #x10) cimm5 (f-29 0) (f-30 0) (f-31 1))
-     (sequence ((SI max))
-	       (c-call "check_option_clip" pc)
-	       (set max (sub (sll 1 cimm5) 1))
-	       (cond
-		((eq cimm5 0) (set rn 0))
-		((gt rn max) (set rn max))
-		((lt rn 0) (set rn 0))))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-
-; Saturation instructions.
-
-(dnci sadd "saturating addition" (OPTIONAL_SAT_INSN (STALL INT2))
-     "sadd $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 8))
-     (sequence ()
-	       (c-call "check_option_sat" pc)
-	       (if (add-oflag rn rm 0)
-		   (if (nflag rn)
-		       ; underflow
-		       (set rn (neg (sll 1 31)))
-		       ; overflow
-		       (set rn (sub (sll 1 31) 1)))
-		   (set rn (add rn rm))))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci ssub "saturating subtraction" (OPTIONAL_SAT_INSN (STALL INT2))
-     "ssub $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 10))
-     (sequence ()
-	       (c-call "check_option_sat" pc)
-	       (if (sub-oflag rn rm 0)
-		   (if (nflag rn)
-		       ; underflow
-		       (set rn (neg (sll 1 31)))
-		       ; overflow
-		       (set rn (sub (sll 1 31) 1)))
-		   (set rn (sub rn rm))))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci saddu "saturating unsigned addition" (OPTIONAL_SAT_INSN (STALL INT2))
-     "saddu $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 9))
-     (sequence ()
-	       (c-call "check_option_sat" pc)
-	       (if (add-cflag rn rm 0)
-		   (set rn (inv 0))
-		   (set rn (add rn rm))))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-(dnci ssubu "saturating unsigned subtraction" (OPTIONAL_SAT_INSN (STALL INT2))
-     "ssubu $rn,$rm"
-     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 11))
-     (sequence ()
-	       (c-call "check_option_sat" pc)
-	       (if (sub-cflag rn rm 0)
-		   (set rn 0)
-		   (set rn (sub rn rm))))
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-use-gpr (in usereg rn))
-	   (unit u-exec))))
-
-
-; UCI and DSP options are defined in an external file.
-; See `mep-sample-ucidsp.cpu' for a sample.
-
-
-; Coprocessor instructions.
-
-(dnci swcp "store word coprocessor" (OPTIONAL_CP_INSN (STALL STORE))
-     "swcp $crn,($rma)"
-     (+ MAJ_3 crn rma (f-sub4 8))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call VOID "check_write_to_text" (and rma (inv SI 3)))
-	       (set (mem SI (and rma (inv SI 3))) crn))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lwcp "load word coprocessor" (OPTIONAL_CP_INSN (STALL LOAD))
-     "lwcp $crn,($rma)"
-     (+ MAJ_3 crn rma (f-sub4 9))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set crn (mem SI (and rma (inv SI 3)))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci smcp "smcp" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL STORE))
-     "smcp $crn64,($rma)"
-     (+ MAJ_3 crn64 rma (f-sub4 10))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call "check_option_cp64" pc)
-	       (c-call VOID "check_write_to_text" rma)
-	       (c-call "do_smcp" rma crn64 pc))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lmcp "lmcp" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL LOAD))
-     "lmcp $crn64,($rma)"
-     (+ MAJ_3 crn64 rma (f-sub4 11))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call "check_option_cp64" pc)
-	       (set crn64 (c-call DI "do_lmcp" rma pc)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci swcpi "swcp (post-increment)" (OPTIONAL_CP_INSN (STALL STORE))
-     "swcpi $crn,($rma+)"
-     (+ MAJ_3 crn rma (f-sub4 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call VOID "check_write_to_text" (and rma (inv SI 3)))
-	       (set (mem SI (and rma (inv SI 3))) crn)
-	       (set rma (add rma 4)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lwcpi "lwcp (post-increment)" (OPTIONAL_CP_INSN (STALL LOAD))
-     "lwcpi $crn,($rma+)"
-     (+ MAJ_3 crn rma (f-sub4 1))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set crn (mem SI (and rma (inv SI 3))))
-	       (set rma (add rma 4)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci smcpi "smcp (post-increment)" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL STORE))
-     "smcpi $crn64,($rma+)"
-     (+ MAJ_3 crn64 rma (f-sub4 2))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call "check_option_cp64" pc)
-	       (c-call VOID "check_write_to_text" rma)
-	       (c-call "do_smcpi" (index-of rma) crn64 pc)
-	       (set rma rma)) ; reference as output for intrinsic generation
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lmcpi "lmcp (post-increment)" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL LOAD))
-     "lmcpi $crn64,($rma+)"
-     (+ MAJ_3 crn64 rma (f-sub4 3))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call "check_option_cp64" pc)
-	       (set crn64 (c-call DI "do_lmcpi" (index-of rma) pc))
-	       (set rma rma)) ; reference as output for intrinsic generation
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci swcp16 "swcp (16-bit displacement)" (OPTIONAL_CP_INSN (STALL STORE))
-     "swcp $crn,$sdisp16($rma)"
-     (+ MAJ_15 crn rma (f-sub4 12) sdisp16)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set (mem SI (and (add rma sdisp16) (inv SI 3))) crn))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lwcp16 "lwcp (16-bit displacement)" (OPTIONAL_CP_INSN (STALL LOAD))
-     "lwcp $crn,$sdisp16($rma)"
-     (+ MAJ_15 crn rma (f-sub4 13) sdisp16)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set crn (mem SI (and (add rma sdisp16) (inv SI 3)))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci smcp16 "smcp (16-bit displacement)" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL STORE))
-     "smcp $crn64,$sdisp16($rma)"
-     (+ MAJ_15 crn64 rma (f-sub4 14) sdisp16)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call "check_option_cp64" pc)
-	       (c-call "do_smcp16" rma sdisp16 crn64 pc))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lmcp16 "lmcp (16-bit displacement)" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL LOAD))
-     "lmcp $crn64,$sdisp16($rma)"
-     (+ MAJ_15 crn64 rma (f-sub4 15) sdisp16)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call "check_option_cp64" pc)
-	       (set crn64 (c-call DI "do_lmcp16" rma sdisp16 pc)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci sbcpa "store byte coprocessor" (OPTIONAL_CP_INSN (STALL STORE))
-     "sbcpa $crn,($rma+),$cdisp8"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext 0) cdisp8)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call VOID "check_write_to_text" rma)
-	       (set (mem QI rma) (and crn #xff))
-	       (set rma (add rma (ext SI cdisp8))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lbcpa "load byte coprocessor" (OPTIONAL_CP_INSN (STALL LOAD))
-     "lbcpa $crn,($rma+),$cdisp8"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x40) cdisp8)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set crn (ext SI (mem QI rma)))
-	       (set rma (add rma (ext SI cdisp8))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci shcpa "store half-word coprocessor" (OPTIONAL_CP_INSN (STALL STORE))
-     "shcpa $crn,($rma+),$cdisp8a2"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x10) cdisp8a2 (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call VOID "check_write_to_text" (and rma (inv SI 1)))
-	       (set (mem HI (and rma (inv SI 1))) (and crn #xffff))
-	       (set rma (add rma (ext SI cdisp8a2))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lhcpa "load half-word coprocessor" (OPTIONAL_CP_INSN (STALL LOAD))
-     "lhcpa $crn,($rma+),$cdisp8a2"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x50) cdisp8a2 (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set crn (ext SI (mem HI (and rma (inv SI 1)))))
-	       (set rma (add rma (ext SI cdisp8a2))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci swcpa "store word coprocessor" (OPTIONAL_CP_INSN (STALL STORE))
-     "swcpa $crn,($rma+),$cdisp8a4"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x20) cdisp8a4 (f-30 0) (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call VOID "check_write_to_text" (and rma (inv SI 3)))
-	       (set (mem SI (and rma (inv SI 3))) crn)
-	       (set rma (add rma (ext SI cdisp8a4))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lwcpa "load word coprocessor" (OPTIONAL_CP_INSN (STALL LOAD))
-     "lwcpa $crn,($rma+),$cdisp8a4"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x60) cdisp8a4 (f-30 0) (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set crn (mem SI (and rma (inv SI 3))))
-	       (set rma (add rma (ext SI cdisp8a4))))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci smcpa "smcpa" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL STORE))
-     "smcpa $crn64,($rma+),$cdisp8a8"
-     (+ MAJ_15 crn64 rma (f-sub4 5) (f-ext #x30) cdisp8a8 (f-29 0) (f-30 0) (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call "check_option_cp64" pc)
-	       (c-call VOID "check_write_to_text" rma)
-	       (c-call "do_smcpa" (index-of rma) cdisp8a8 crn64 pc)
-	       (set rma rma)) ; reference as output for intrinsic generation
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lmcpa "lmcpa" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL LOAD))
-     "lmcpa $crn64,($rma+),$cdisp8a8"
-     (+ MAJ_15 crn64 rma (f-sub4 5) (f-ext #x70) cdisp8a8 (f-29 0) (f-30 0) (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call "check_option_cp64" pc)
-	       (set crn64 (c-call DI "do_lmcpa" (index-of rma) cdisp8a8 pc))
-	       (set rma rma)) ; reference as output for intrinsic generation
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-
-; pmacros needed for coprocessor modulo addressing.
-
-; Taken from supplement ``The operation of the modulo addressing'' in
-; Toshiba documentation rev 2.2, p. 34.
-
-(define-pmacro (compute-mask0)
-  (sequence SI ((SI temp))
-    (set temp (or mb0 me0))
-    (srl (const SI -1) (c-call SI "do_ldz" temp))))
-
-(define-pmacro (mod0 immed)
-  (sequence SI ((SI modulo-mask))
-	    (set modulo-mask (compute-mask0))
-	    (if SI (eq (and rma modulo-mask) me0)
-		(or (and rma (inv modulo-mask)) mb0)
-		(add rma (ext SI immed)))))
-
-(define-pmacro (compute-mask1)
-  (sequence SI ((SI temp))
-    (set temp (or mb1 me1))
-    (srl (const SI -1) (c-call SI "do_ldz" temp))))
-
-(define-pmacro (mod1 immed)
-  (sequence SI ((SI modulo-mask))
-	    (set modulo-mask (compute-mask1))
-	    (if SI (eq (and rma modulo-mask) me1)
-		(or (and rma (inv modulo-mask)) mb1)
-		(add rma (ext SI immed)))))
-
-(dnci sbcpm0 "sbcpm0" (OPTIONAL_CP_INSN)
-     "sbcpm0 $crn,($rma+),$cdisp8"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x08) cdisp8)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call VOID "check_write_to_text" rma)
-	       (set (mem QI rma) (and crn #xff))
-	       (set rma (mod0 cdisp8)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lbcpm0 "lbcpm0" (OPTIONAL_CP_INSN)
-     "lbcpm0 $crn,($rma+),$cdisp8"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x48) cdisp8)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set crn (ext SI (mem QI rma)))
-	       (set rma (mod0 cdisp8)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci shcpm0 "shcpm0" (OPTIONAL_CP_INSN)
-     "shcpm0 $crn,($rma+),$cdisp8a2"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x18) cdisp8a2 (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call VOID "check_write_to_text" (and rma (inv SI 1)))
-	       (set (mem HI (and rma (inv SI 1))) (and crn #xffff))
-	       (set rma (mod0 cdisp8a2)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lhcpm0 "lhcpm0" (OPTIONAL_CP_INSN)
-     "lhcpm0 $crn,($rma+),$cdisp8a2"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x58) cdisp8a2 (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set crn (ext SI (mem HI (and rma (inv SI 1)))))
-	       (set rma (mod0 cdisp8a2)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci swcpm0 "swcpm0" (OPTIONAL_CP_INSN)
-     "swcpm0 $crn,($rma+),$cdisp8a4"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x28) cdisp8a4 (f-30 0) (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call VOID "check_write_to_text" (and rma (inv SI 3)))
-	       (set (mem SI (and rma (inv SI 3))) crn)
-	       (set rma (mod0 cdisp8a4)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lwcpm0 "lwcpm0" (OPTIONAL_CP_INSN)
-     "lwcpm0 $crn,($rma+),$cdisp8a4"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x68) cdisp8a4 (f-30 0) (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set crn (mem SI (and rma (inv SI 3))))
-	       (set rma (mod0 cdisp8a4)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci smcpm0 "smcpm0" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN)
-     "smcpm0 $crn64,($rma+),$cdisp8a8"
-     (+ MAJ_15 crn64 rma (f-sub4 5) (f-ext #x38) cdisp8a8 (f-29 0) (f-30 0) (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call "check_option_cp64" pc)
-	       (c-call VOID "check_write_to_text" rma)
-	       (c-call "do_smcp" rma crn64 pc)
-	       (set rma (mod0 cdisp8a8)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lmcpm0 "lmcpm0" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN)
-     "lmcpm0 $crn64,($rma+),$cdisp8a8"
-     (+ MAJ_15 crn64 rma (f-sub4 5) (f-ext #x78) cdisp8a8 (f-29 0) (f-30 0) (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call "check_option_cp64" pc)
-	       (set crn64 (c-call DI "do_lmcp" rma pc))
-	       (set rma (mod0 cdisp8a8)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci sbcpm1 "sbcpm1" (OPTIONAL_CP_INSN)
-     "sbcpm1 $crn,($rma+),$cdisp8"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x0c) cdisp8)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call VOID "check_write_to_text" rma)
-	       (set (mem QI rma) (and crn #xff))
-	       (set rma (mod1 cdisp8)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lbcpm1 "lbcpm1" (OPTIONAL_CP_INSN)
-     "lbcpm1 $crn,($rma+),$cdisp8"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x4c) cdisp8)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set crn (ext SI (mem QI rma)))
-	       (set rma (mod1 cdisp8)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci shcpm1 "shcpm1" (OPTIONAL_CP_INSN)
-     "shcpm1 $crn,($rma+),$cdisp8a2"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x1c) cdisp8a2 (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call VOID "check_write_to_text" (and rma (inv SI 1)))
-	       (set (mem HI (and rma (inv SI 1))) (and crn #xffff))
-	       (set rma (mod1 cdisp8a2)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lhcpm1 "lhcpm1" (OPTIONAL_CP_INSN)
-     "lhcpm1 $crn,($rma+),$cdisp8a2"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x5c) cdisp8a2 (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set crn (ext SI (mem HI (and rma (inv SI 1)))))
-	       (set rma (mod1 cdisp8a2)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci swcpm1 "swcpm1" (OPTIONAL_CP_INSN)
-     "swcpm1 $crn,($rma+),$cdisp8a4"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x2c) cdisp8a4 (f-30 0) (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call VOID "check_write_to_text" (and rma (inv SI 3)))
-	       (set (mem SI (and rma (inv SI 3))) crn)
-	       (set rma (mod1 cdisp8a4)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lwcpm1 "lwcpm1" (OPTIONAL_CP_INSN)
-     "lwcpm1 $crn,($rma+),$cdisp8a4"
-     (+ MAJ_15 crn rma (f-sub4 5) (f-ext #x6c) cdisp8a4 (f-30 0) (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (set crn (ext SI (mem SI (and rma (inv SI 3)))))
-	       (set rma (mod1 cdisp8a4)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci smcpm1 "smcpm1" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN)
-     "smcpm1 $crn64,($rma+),$cdisp8a8"
-     (+ MAJ_15 crn64 rma (f-sub4 5) (f-ext #x3c) cdisp8a8 (f-29 0) (f-30 0) (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call "check_option_cp64" pc)
-	       (c-call "do_smcp" rma crn64 pc)
-	       (c-call VOID "check_write_to_text" rma)
-	       (set rma (mod1 cdisp8a8)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnci lmcpm1 "lmcpm1" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN)
-     "lmcpm1 $crn64,($rma+),$cdisp8a8"
-     (+ MAJ_15 crn64 rma (f-sub4 5) (f-ext #x7c) cdisp8a8 (f-29 0) (f-30 0) (f-31 0))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (c-call "check_option_cp64" pc)
-	       (set crn64 (c-call DI "do_lmcp" rma pc))
-	       (set rma (mod1 cdisp8a8)))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
-
-(dnop cp_flag       "branch condition register"  (all-mep-isas) h-ccr   1)
-
-(dnci bcpeq "branch coprocessor equal" (OPTIONAL_CP_INSN RELAXABLE)
-     "bcpeq $cccc,$pcrel17a2"
-     (+ MAJ_13 (f-rn 8) cccc (f-sub4 4) pcrel17a2)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (if (eq (xor cccc cp_flag) 0)
-	       (set-vliw-alignment-modified pc pcrel17a2)))
-     ())
-
-(dnci bcpne "branch coprocessor not equal" (OPTIONAL_CP_INSN RELAXABLE)
-     "bcpne $cccc,$pcrel17a2"
-     (+ MAJ_13 (f-rn 8) cccc (f-sub4 5) pcrel17a2)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (if (ne (xor cccc cp_flag) 0)
-	       (set-vliw-alignment-modified pc pcrel17a2)))
-     ())
-
-(dnci bcpat "branch coprocessor and true" (OPTIONAL_CP_INSN RELAXABLE)
-     "bcpat $cccc,$pcrel17a2"
-     (+ MAJ_13 (f-rn 8) cccc (f-sub4 6) pcrel17a2)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (if (ne (and cccc cp_flag) 0)
-	       (set-vliw-alignment-modified pc pcrel17a2)))
-     ())
-
-(dnci bcpaf "branch coprocessor and false" (OPTIONAL_CP_INSN RELAXABLE)
-     "bcpaf $cccc,$pcrel17a2"
-     (+ MAJ_13 (f-rn 8) cccc (f-sub4 7) pcrel17a2)
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (if (eq (and cccc cp_flag) 0)
-	       (set-vliw-alignment-modified pc pcrel17a2)))
-     ())
-
-(dnci synccp "synchronise with coprocessor" (OPTIONAL_CP_INSN)
-     "synccp"
-     (+ MAJ_7 (f-rn 0) (f-rm 2) (f-sub4 1))
-     (sequence ()
-	       (c-call "check_option_cp" pc)
-	       (unimp "synccp"))
-     ())
-
-(dnci jsrv "jump to vliw subroutine " (OPTIONAL_CP_INSN)
-     "jsrv $rm"
-     (+ MAJ_1 (f-rn 8) rm (f-sub4 15))
-     (sequence ()
-	       (cg-profile pc rm)
-	       (c-call "check_option_cp" pc)
-	       (core-vliw-switch
-
-		;; in core operating mode
-		(sequence ()
-			  (set lp (or (add pc 2) 1))
-			  (set-vliw-aliignment-modified-by-option pc rm)
-			  (set-psw.om 1)) ;; to VLIW operation mode
-
-		;; in VLIW32 operating mode
-		(sequence ()
-			  (set lp (or (add pc 4) 1))
-			  (set pc (and rm (inv 1)))
-			  (set-psw.om 0)) ;; to core operation mode
-
-		;; in VLIW64 operating mode
-		(sequence ()
-			  (set lp (or (add pc 8) 1))
-			  (set pc (and rm (inv 1)))
-			  (set-psw.om 0)))) ;; to core operation mode
-     ((mep (unit u-use-gpr (in usereg rm))
-	   (unit u-exec)
-	   (unit u-branch))))
-
-(dnci bsrv "branch to vliw subroutine" (OPTIONAL_CP_INSN)
-     "bsrv $pcrel24a2"
-     (+ MAJ_13 (f-4 1) (f-sub4 11) pcrel24a2)
-     (sequence ()
-	       (cg-profile pc pcrel24a2)
-	       (c-call "check_option_cp" pc)
-	       (core-vliw-switch
-
-		;; in core operating mode
-		(sequence ()
-			  (set lp (or (add pc 4) 1))
-			  (set-vliw-aliignment-modified-by-option pc pcrel24a2)
-			  (set-psw.om 1)) ;; to VLIW operation mode
-
-		;; in VLIW32 operating mode
-		(sequence ()
-			  (set lp (or (add pc 4) 1))
-			  (set pc (and pcrel24a2 (inv 1)))
-			  (set-psw.om 0)) ;; to core operation mode
-
-		;; in VLIW64 operating mode
-		(sequence ()
-			  (set lp (or (add pc 8) 1))
-			  (set pc (and pcrel24a2 (inv 1)))
-			  (set-psw.om 0)))) ;; to core operation mode
-     ((mep (unit u-exec)
-	   (unit u-branch))))
-
-
-; An instruction for test instrumentation.
-; Using a reserved opcode.
-
-(dnci sim-syscall "simulator system call" ()
-     "--unused--"
-     (+ MAJ_7 (f-4 1) callnum (f-8 0) (f-9 0) (f-10 0) (f-sub4 0))
-     (c-call "do_syscall" pc callnum)
-     ())
-
-(define-pmacro (dnri n major minor)
-  (dnci (.sym ri- n) "reserved instruction" ()
-	"--reserved--"
-	(+ major rn rm (f-sub4 minor))
-	(set pc (c-call USI "ri_exception" pc))
-	((mep (unit u-exec)
-	      (unit u-branch)))))
-
-(dnri 0  MAJ_0   6)
-(dnri 1  MAJ_1  10)
-(dnri 2  MAJ_1  11)
-(dnri 3  MAJ_2   5)
-(dnri 4  MAJ_2   8)
-(dnri 5  MAJ_2   9)
-(dnri 6  MAJ_2  10)
-(dnri 7  MAJ_2  11)
-(dnri 8  MAJ_3   4)
-(dnri 9  MAJ_3   5)
-(dnri 10 MAJ_3   6)
-(dnri 11 MAJ_3   7)
-(dnri 12 MAJ_3  12)
-(dnri 13 MAJ_3  13)
-(dnri 14 MAJ_3  14)
-(dnri 15 MAJ_3  15)
-(dnri 17 MAJ_7   7)
-(dnri 20 MAJ_7  14)
-(dnri 21 MAJ_7  15)
-(dnri 22 MAJ_12  7)
-(dnri 23 MAJ_14 13)
-(dnri 24 MAJ_15  3)
-(dnri 25 MAJ_15  6)
-(dnri 26 MAJ_15  8)
-; begin non-mep-h1 reserved insns
-(dnri 16 MAJ_7   5)
-(dnri 18 MAJ_7  12)
-(dnri 19 MAJ_7  13)
-; end non-mep-h1 reserved insns
-
-
-; Macro instructions.
-
-(dnmi nop "nop"
-      ()
-      "nop"
-      (emit mov (rn 0) (rm 0)))
-
-; Emit the 16 bit form of these 32 bit insns when the displacement is zero.
-;
-(dncmi sb16-0 "store byte (explicit 16 bit displacement of zero)" (NO-DIS)
-     "sb $rnc,$zero($rma)"
-     (emit sb rnc rma))
-
-(dncmi sh16-0 "store half (explicit 16 bit displacement of zero)" (NO-DIS)
-     "sh $rns,$zero($rma)"
-     (emit sh rns rma))
-
-(dncmi sw16-0 "store word (explicit 16 bit displacement of zero)" (NO-DIS)
-     "sw $rnl,$zero($rma)"
-     (emit sw rnl rma))
-
-(dncmi lb16-0 "load byte (explicit 16 bit displacement of zero)" (NO-DIS)
-     "lb $rnc,$zero($rma)"
-     (emit lb rnc rma))
-
-(dncmi lh16-0 "load half (explicit 16 bit displacement of zero)" (NO-DIS)
-     "lh $rns,$zero($rma)"
-     (emit lh rns rma))
-
-(dncmi lw16-0 "load word (explicit 16 bit displacement of zero)" (NO-DIS)
-     "lw $rnl,$zero($rma)"
-     (emit lw rnl rma))
-
-(dncmi lbu16-0 "load unsigned byte (explicit 16 bit displacement of zero)" (NO-DIS)
-     "lbu $rnuc,$zero($rma)"
-     (emit lbu rnuc rma))
-
-(dncmi lhu16-0 "load unsigned half (explicit 16 bit displacement of zero)" (NO-DIS)
-     "lhu $rnus,$zero($rma)"
-     (emit lhu rnus rma))
-
-(dncmi swcp16-0 "swcp (explicit 16-bit displacement of zero)" (OPTIONAL_CP_INSN NO-DIS)
-     "swcp $crn,$zero($rma)"
-     (emit swcp crn rma))
-
-(dncmi lwcp16-0 "lwcp (explicit 16-bit displacement of zero)" (OPTIONAL_CP_INSN NO-DIS)
-     "lwcp $crn,$zero($rma)"
-     (emit lwcp crn rma))
-
-(dncmi smcp16-0 "smcp (explicit 16-bit displacement of zero)" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN NO-DIS)
-     "smcp $crn64,$zero($rma)"
-     (emit smcp crn64 rma))
-
-(dncmi lmcp16-0 "lmcp (explicit 16-bit displacement of zero)" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN NO-DIS)
-     "lmcp $crn64,$zero($rma)"
-     (emit lmcp crn64 rma))
diff -rupN binutils-2.19.1-original/cgen/cpu/mep.cpu binutils-2.19.1/cgen/cpu/mep.cpu
--- binutils-2.19.1-original/cgen/cpu/mep.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/mep.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,23 +0,0 @@
-(include "mep-default.cpu")
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
diff -rupN binutils-2.19.1-original/cgen/cpu/mep-default.cpu binutils-2.19.1/cgen/cpu/mep-default.cpu
--- binutils-2.19.1-original/cgen/cpu/mep-default.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/mep-default.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,28 +0,0 @@
-
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-; This file serves as a wrapper to bring in the core description plus
-; sample implementations of the UCI and DSP instructions.
-
-(include "mep-core.cpu")
-(include "mep-ext-cop.cpu")
diff -rupN binutils-2.19.1-original/cgen/cpu/mep-ext-cop.cpu binutils-2.19.1/cgen/cpu/mep-ext-cop.cpu
--- binutils-2.19.1-original/cgen/cpu/mep-ext-cop.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/mep-ext-cop.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,26 +0,0 @@
-
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-;; begin-user-isa-includes
-(include "mep-fmax.cpu")
-;; end-user-isa-includes
diff -rupN binutils-2.19.1-original/cgen/cpu/mep-fmax.cpu binutils-2.19.1/cgen/cpu/mep-fmax.cpu
--- binutils-2.19.1-original/cgen/cpu/mep-fmax.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/mep-fmax.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,341 +0,0 @@
-
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-;------------------------------------------------------------------------------
-; MeP-Integrator will redefine the isa pmacros below to allow the bit widths
-; specified below for each ME_MODULE using this coprocessor.
-; This coprocessor requires only the 32 bit insns in the core.
-;------------------------------------------------------------------------------
-; begin-isas
-(define-pmacro fmax-core-isa () (ISA ext_core2))
-(define-pmacro all-fmax-isas () (ISA ext_core2))
-; end-isas
-
-;******************************************************************************
-; ifields
-;------------------------------------------------------------------------------
-; opcodes
-(dnf f-fmax-0-4  "opcode" (all-fmax-isas)  0 4)
-(dnf f-fmax-4-4  "opcode" (all-fmax-isas)  4 4)
-(dnf f-fmax-8-4  "opcode" (all-fmax-isas)  8 4)
-(dnf f-fmax-12-4 "opcode" (all-fmax-isas) 12 4)
-(dnf f-fmax-16-4 "opcode" (all-fmax-isas) 16 4)
-(dnf f-fmax-20-4 "opcode" (all-fmax-isas) 20 4)
-(dnf f-fmax-24-4 "opcode" (all-fmax-isas) 24 4)
-(dnf f-fmax-28-1 "opcode" (all-fmax-isas) 28 1)
-(dnf f-fmax-29-1 "opcode" (all-fmax-isas) 29 1)
-(dnf f-fmax-30-1 "opcode" (all-fmax-isas) 30 1)
-(dnf f-fmax-31-1 "opcode" (all-fmax-isas) 31 1)
-
-;------------------------------------------------------------------------------
-; FR registers
-(define-multi-ifield
-  (name f-fmax-frd)
-  (comment "FRd register")
-  (attrs all-fmax-isas)
-  (mode UINT)
-  (subfields f-fmax-28-1 f-fmax-4-4)
-  (insert (sequence ()
-		    (set (ifield f-fmax-4-4) (and (ifield f-fmax-frd) #xf))
-		    (set (ifield f-fmax-28-1) (srl (ifield f-fmax-frd) 4))))
-  (extract (set (ifield f-fmax-frd)
-		(or (sll (ifield f-fmax-28-1) 4) (ifield f-fmax-4-4))))
-)
-(define-multi-ifield
-  (name f-fmax-frn)
-  (comment "FRn register")
-  (attrs all-fmax-isas)
-  (mode UINT)
-  (subfields f-fmax-29-1 f-fmax-20-4)
-  (insert (sequence ()
-		    (set (ifield f-fmax-20-4) (and (ifield f-fmax-frn) #xf))
-		    (set (ifield f-fmax-29-1) (srl (ifield f-fmax-frn) 4))))
-  (extract (set (ifield f-fmax-frn)
-		(or (sll (ifield f-fmax-29-1) 4) (ifield f-fmax-20-4))))
-)
-(define-multi-ifield
-  (name f-fmax-frm)
-  (comment "FRm register")
-  (attrs all-fmax-isas)
-  (mode UINT)
-  (subfields f-fmax-30-1 f-fmax-24-4)
-  (insert (sequence ()
-		    (set (ifield f-fmax-24-4) (and (ifield f-fmax-frm) #xf))
-		    (set (ifield f-fmax-30-1) (srl (ifield f-fmax-frm) 4))))
-  (extract (set (ifield f-fmax-frm)
-		(or (sll (ifield f-fmax-30-1) 4) (ifield f-fmax-24-4))))
-)
-
-;------------------------------------------------------------------------------
-; Core General registers
-(dnf f-fmax-rm  "opcode" (all-fmax-isas)  8 4)
-
-;------------------------------------------------------------------------------
-; Condition opcodes enum
-(define-normal-insn-enum fmax-cond "condition opcode enum" (all-fmax-isas) FMAX_ f-fmax-8-4
-  ("f"  "u"  "e"  "ue"  "l"  "ul"  "le"  "ule"
-   "fi" "ui" "ei" "uei" "li" "uli" "lei" "ulei")
-)
-
-;******************************************************************************
-; Hardware
-;------------------------------------------------------------------------------
-; FR registers
-
-; Given a coprocessor register number N, expand to a
-; name/index pair: ($frN N)
-(define-pmacro (-fmax-fr-reg-pair n) ((.sym "fr" n) n))
-(define-pmacro (-fmax-cr-reg-pair n) ((.sym "c" n) n))
-
-; NOTE: This exists solely for the purpose of providing the proper register names for this coprocessor.
-; GDB will use the hardware table generated from this declaration. The operands use h-cr
-; from mep-core.cpu so that SID's semantic trace will be consistent between
-; the core and the coprocessor but use parse/print handlers which reference the hardware table
-; generated from this declarations
-(define-hardware
-  (name h-cr-fmax)
-  (comment "Floating point registers")
-  (attrs all-fmax-isas VIRTUAL IS_FLOAT)
-  (type register SF (32))
-  (indices keyword "$"
-	   (.splice (.unsplice (.map -fmax-fr-reg-pair (.iota 32)))
-		    (.unsplice (.map -fmax-cr-reg-pair (.iota 32))))
-  )
-  (get (index) (c-call SF "fmax_fr_get_handler" index))
-  (set (index newval) (c-call VOID "fmax_fr_set_handler" index newval))
-)
-
-;------------------------------------------------------------------------------
-; Control registers
-; NOTE: This exists solely for the purpose of providing the proper register names for this coprocessor.
-; GDB will use the hardware table generated from this declaration. The operands use h-ccr
-; from mep-core.cpu so that SID's semantic trace will be consistent between
-; the core and the coprocessor but use parse/print handlers which reference the hardware table
-; generated from this declarations
-(define-hardware
-  (name h-ccr-fmax)
-  (comment "Coprocessor Identifier and Revision Register")
-  (attrs all-fmax-isas VIRTUAL)
-  (type register USI (16))
-  (indices keyword "$" (
-		       ("cirr"  0) ("fcr0"   0) ("ccr0"   0)
-		       ("cbcr"  1) ("fcr1"   1) ("ccr1"   1)
-		       ("cerr" 15) ("fcr15" 15) ("ccr15" 15)
-                      )
-  )
-  (set (index newval) (c-call VOID "h_ccr_set" index newval))
-  (get (index) (c-call SI "h_ccr_get" index))
-)
-
-;------------------------------------------------------------------------------
-; Misc
-(define-hardware
-  (name h-fmax-compare-i-p)
-  (comment "flag")
-  (attrs all-fmax-isas)
-  (type register USI)
-)
-
-;******************************************************************************
-; Operands
-;------------------------------------------------------------------------------
-; FR Registers
-(define-full-operand fmax-FRd "FRd" (all-fmax-isas (CDATA FMAX_FLOAT)) h-cr SF f-fmax-frd ((parse "fmax_cr") (print "fmax_cr")) () ())
-(define-full-operand fmax-FRn "FRn" (all-fmax-isas (CDATA FMAX_FLOAT)) h-cr SF f-fmax-frn ((parse "fmax_cr") (print "fmax_cr")) () ())
-(define-full-operand fmax-FRm "FRm" (all-fmax-isas (CDATA FMAX_FLOAT)) h-cr SF f-fmax-frm ((parse "fmax_cr") (print "fmax_cr")) () ())
-
-(define-full-operand fmax-FRd-int "FRd as an integer" (all-fmax-isas (CDATA FMAX_INT)) h-cr SI f-fmax-frd ((parse "fmax_cr") (print "fmax_cr")) () ())
-(define-full-operand fmax-FRn-int "FRn as an integer" (all-fmax-isas (CDATA FMAX_INT)) h-cr SI f-fmax-frn ((parse "fmax_cr") (print "fmax_cr")) () ())
-
-;------------------------------------------------------------------------------
-; Control registers
-(define-full-operand fmax-CCRn "CCRn" (all-fmax-isas (CDATA REGNUM)) h-ccr DFLT f-fmax-4-4 ((parse "fmax_ccr") (print "fmax_ccr")) () ())
-
-(dnop fmax-CIRR "CIRR" (all-fmax-isas SEM-ONLY) h-ccr 0)
-(dnop fmax-CBCR "CBCR" (all-fmax-isas SEM-ONLY) h-ccr 1)
-(dnop fmax-CERR "CERR" (all-fmax-isas SEM-ONLY) h-ccr 15)
-
-;------------------------------------------------------------------------------
-; Core General Registers
-(dnop fmax-Rm "Rm" (all-fmax-isas) h-gpr f-fmax-rm)
-
-;------------------------------------------------------------------------------
-; misc
-(dnop fmax-Compare-i-p "flag" (all-fmax-isas SEM-ONLY) h-fmax-compare-i-p f-nil)
-
-;******************************************************************************
-; Instructions
-;------------------------------------------------------------------------------
-; Binary Arithmetic
-(define-pmacro (fmax-binary-arith op opc sem)
-  (dni op
-       (.str op " FRd,FRn,FRm")
-       (all-fmax-isas MAY_TRAP)
-       (.str op " ${fmax-FRd},${fmax-FRn},${fmax-FRm}")
-       (+ (f-fmax-0-4 #xF) fmax-FRd (f-fmax-8-4 opc) (f-fmax-12-4 #x7) (f-fmax-16-4 0)
-	  fmax-FRn fmax-FRm (f-fmax-31-1 0))
-       sem
-       ()
-  )
-)
-
-(fmax-binary-arith fadds #x0 (set fmax-FRd (add fmax-FRn fmax-FRm)))
-(fmax-binary-arith fsubs #x1 (set fmax-FRd (sub fmax-FRn fmax-FRm)))
-(fmax-binary-arith fmuls #x2 (set fmax-FRd (mul fmax-FRn fmax-FRm)))
-(fmax-binary-arith fdivs #x3 (set fmax-FRd (div fmax-FRn fmax-FRm)))
-
-;------------------------------------------------------------------------------
-; Unary Arithmetic
-(define-pmacro (fmax-unary-arith op opc sem)
-  (dni op
-       (.str op " FRd,FRn")
-       (all-fmax-isas MAY_TRAP)
-       (.str op " ${fmax-FRd},${fmax-FRn}")
-       (+ (f-fmax-0-4 #xF) fmax-FRd (f-fmax-8-4 opc) (f-fmax-12-4 #x7)
-	  (f-fmax-16-4 0)  fmax-FRn (f-fmax-24-4 0) (f-fmax-30-1 0) (f-fmax-31-1 0))
-       sem
-       ()
-  )
-)
-
-(fmax-unary-arith fsqrts #x4 (set fmax-FRd (sqrt fmax-FRn)))
-(fmax-unary-arith fabss  #x5 (set fmax-FRd (abs fmax-FRn)))
-(fmax-unary-arith fnegs  #x7 (set fmax-FRd (neg fmax-FRn)))
-(fmax-unary-arith fmovs  #x6 (set fmax-FRd fmax-FRn))
-
-;------------------------------------------------------------------------------
-; Conversions
-(define-pmacro (fmax-conv op opc1 opc2 opnd1 opnd2 sem)
-  (dni op
-       (.str op " FRd,FRn")
-       (all-fmax-isas MAY_TRAP)
-       (.str op " ${" opnd1 "},${" opnd2 "}")
-       (+ (f-fmax-0-4 #xF) opnd1 (f-fmax-8-4 opc1) (f-fmax-12-4 #x7)
-	  (f-fmax-16-4 opc2)  opnd2 (f-fmax-24-4 0) (f-fmax-30-1 0) (f-fmax-31-1 0))
-       sem
-       ()
-  )
-)
-
-(fmax-conv froundws #xC #x0 fmax-FRd-int fmax-FRn     (set fmax-FRd-int (c-call SI "fmax_froundws" fmax-FRn)))
-(fmax-conv ftruncws #xD #x0 fmax-FRd-int fmax-FRn     (set fmax-FRd-int (c-call SI "fmax_ftruncws" fmax-FRn)))
-(fmax-conv fceilws  #xE #x0 fmax-FRd-int fmax-FRn     (set fmax-FRd-int (c-call SI "fmax_fceilws" fmax-FRn)))
-(fmax-conv ffloorws #xF #x0 fmax-FRd-int fmax-FRn     (set fmax-FRd-int (c-call SI "fmax_ffloorws" fmax-FRn)))
-(fmax-conv fcvtws   #x4 #x1 fmax-FRd-int fmax-FRn     (set fmax-FRd-int (c-call SI "fmax_fcvtws" fmax-FRn)))
-(fmax-conv fcvtsw   #x0 #x9 fmax-FRd     fmax-FRn-int (set fmax-FRd (float SF fmax-FRn-int)))
-
-;------------------------------------------------------------------------------
-; Comparisons
-;
-; Comparison with no exceptions
-(define-pmacro (fmax-f-sem x y)  (andif (gt x y) (lt x y))) ; do this to get exception detection
-(define-pmacro (fmax-u-sem x y)  (not (orif (lt x y) (orif (eq x y) (gt x y)))))
-(define-pmacro (fmax-e-sem x y)  (eq x y))
-(define-pmacro (fmax-ue-sem x y) (not (orif (lt x y) (gt x y))))
-(define-pmacro (fmax-l-sem x y)  (lt x y))
-(define-pmacro (fmax-ul-sem x y) (not (orif (gt x y) (eq x y))))
-(define-pmacro (fmax-le-sem x y) (orif (lt x y) (eq x y)))
-(define-pmacro (fmax-ule-sem x y) (not (gt x y)))
-
-(define-pmacro (fmax-comp cond suffix exceptions)
-  (dni (.sym fcmp cond suffix s)
-       (.str "fcmp" cond suffix "s FRn,FRm")
-       ;; Even though the instruction doesn't really trap if EXCEPTIONS
-       ;; is zero, we don't want gcc to put it in a repeat or erepeat
-       ;; block because of the hazards between fcmp instructions and
-       ;; anything that reads CBCR.
-       (all-fmax-isas MAY_TRAP)
-       (.str "fcmp" cond suffix "s ${fmax-FRn},${fmax-FRm}")
-       (+ (f-fmax-0-4 #xF) (f-fmax-4-4 0) (.sym FMAX_ cond suffix) (f-fmax-12-4 #x7)
-	  (f-fmax-16-4 #x2) (f-fmax-28-1 0) fmax-FRn fmax-FRm (f-fmax-31-1 0))
-       (sequence ()
-		 (set fmax-Compare-i-p exceptions)
-		 (set fmax-CBCR ((.sym fmax- cond -sem) fmax-FRn fmax-FRm))
-		 (set fmax-Compare-i-p 0)
-       )
-       ()
-  )
-)
-
-; Comparison with no exceptions
-(fmax-comp f   "" 0)
-(fmax-comp u   "" 0)
-(fmax-comp e   "" 0)
-(fmax-comp ue  "" 0)
-(fmax-comp l   "" 0)
-(fmax-comp ul  "" 0)
-(fmax-comp le  "" 0)
-(fmax-comp ule "" 0)
-
-; Comparison with exceptions
-(fmax-comp f   i 1)
-(fmax-comp u   i 1)
-(fmax-comp e   i 1)
-(fmax-comp ue  i 1)
-(fmax-comp l   i 1)
-(fmax-comp ul  i 1)
-(fmax-comp le  i 1)
-(fmax-comp ule i 1)
-
-;------------------------------------------------------------------------------
-; Move to/from core registers
-(dni cmov-frn-rm
-     "cmov FRn,Rm"
-     (all-fmax-isas (INTRINSIC "cmov1"))
-     "cmov ${fmax-FRd-int},${fmax-Rm}"
-     (+ (f-fmax-0-4 #xF) fmax-FRd-int fmax-Rm (f-fmax-12-4 #x7)
-	(f-fmax-16-4 #xF) (f-fmax-20-4 0) (f-fmax-24-4 0)
-	(f-fmax-29-1 0) (f-fmax-30-1 0) (f-fmax-31-1 0))
-     (set fmax-FRd-int fmax-Rm)
-     ()
-)
-(dni cmov-rm-frn
-     "cmov Rm,FRn"
-     (all-fmax-isas (INTRINSIC "cmov2"))
-     "cmov ${fmax-Rm},${fmax-FRd-int}"
-     (+ (f-fmax-0-4 #xF) fmax-FRd-int fmax-Rm (f-fmax-12-4 #x7)
-	(f-fmax-16-4 #xF) (f-fmax-20-4 0) (f-fmax-24-4 0)
-	(f-fmax-29-1 0) (f-fmax-30-1 0) (f-fmax-31-1 1))
-     (set fmax-Rm fmax-FRd-int)
-     ()
-)
-(dni cmovc-ccrn-rm
-     "cmovc CCRn,Rm"
-     (all-fmax-isas (INTRINSIC "cmovc1"))
-     "cmovc ${fmax-CCRn},${fmax-Rm}"
-     (+ (f-fmax-0-4 #xF) fmax-CCRn fmax-Rm (f-fmax-12-4 #x7)
-	(f-fmax-16-4 #xF) (f-fmax-20-4 0) (f-fmax-24-4 0)
-	(f-fmax-28-1 0) (f-fmax-29-1 0) (f-fmax-30-1 1) (f-fmax-31-1 0))
-     (set fmax-CCRn fmax-Rm)
-     ()
-)
-(dni cmovc-rm-ccrn
-     "cmovc Rm,CCRn"
-     (all-fmax-isas (INTRINSIC "cmovc2"))
-     "cmovc ${fmax-Rm},${fmax-CCRn}"
-     (+ (f-fmax-0-4 #xF) fmax-CCRn fmax-Rm (f-fmax-12-4 #x7)
-	(f-fmax-16-4 #xF) (f-fmax-20-4 0) (f-fmax-24-4 0)
-	(f-fmax-28-1 0) (f-fmax-29-1 0) (f-fmax-30-1 1) (f-fmax-31-1 1))
-     (set fmax-Rm fmax-CCRn)
-     ()
-)
diff -rupN binutils-2.19.1-original/cgen/cpu/mep-h1.cpu binutils-2.19.1/cgen/cpu/mep-h1.cpu
--- binutils-2.19.1-original/cgen/cpu/mep-h1.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/mep-h1.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,50 +0,0 @@
-; Insns introduced for the MeP-h1 core
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-;
-(dnci stcb_r "store in control bus space" (VOLATILE (MACH h1))
-     "stcb $rn,($rma)"
-     (+ MAJ_7 rn rma (f-sub4 12))
-     (c-call VOID "do_stcb" rn (and rma #xffff))
-     ((mep (unit u-use-gpr (in usereg rn))
-	   (unit u-use-gpr (in usereg rma))
-	   (unit u-exec)
-	   (unit u-stcb))))
-
-(dnci ldcb_r "load from control bus space" (VOLATILE (MACH h1) (LATENCY 3))
-     "ldcb $rn,($rma)"
-     (+ MAJ_7 rn rma (f-sub4 13))
-     (set rn (c-call SI "do_ldcb" (and rma #xffff)))
-      ((mep (unit u-use-gpr (in usereg rma))
-	    (unit u-ldcb)
-	    (unit u-exec)
-	    (unit u-ldcb-gpr (out loadreg rn)))))
-
-(dnci pref "cache prefetch" ((MACH h1) VOLATILE)
-     "pref $cimm4,($rma)"
-     (+ MAJ_7 cimm4 rma (f-sub4 5))
-     (sequence ()
-	       (c-call VOID "check_option_dcache" pc)
-	       (c-call VOID "do_cache_prefetch" cimm4 rma pc))
-     ((mep (unit u-use-gpr (in usereg rma))
-	   (unit u-exec))))
diff -rupN binutils-2.19.1-original/cgen/cpu/mep.opc binutils-2.19.1/cgen/cpu/mep.opc
--- binutils-2.19.1-original/cgen/cpu/mep.opc	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/mep.opc	1969-12-31 19:00:00.000000000 -0500
@@ -1,1307 +0,0 @@
-
-/* -*- C -*-
-   Copyright 2011 Free Software Foundation, Inc.
-
-   Contributed by Red Hat Inc;
-
-   This file is part of the GNU Binutils.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-/* -- opc.h */
-
-#undef  CGEN_DIS_HASH_SIZE
-#define CGEN_DIS_HASH_SIZE 1
-
-#undef  CGEN_DIS_HASH
-#define CGEN_DIS_HASH(buffer, insn) 0
-
-#define CGEN_VERBOSE_ASSEMBLER_ERRORS
-
-typedef struct
-{
-  char * name;
-  int    config_enum;
-  unsigned cpu_flag;
-  int    big_endian;
-  int    vliw_bits;
-  CGEN_ATTR_VALUE_BITSET_TYPE cop16_isa;
-  CGEN_ATTR_VALUE_BITSET_TYPE cop32_isa;
-  CGEN_ATTR_VALUE_BITSET_TYPE cop48_isa;
-  CGEN_ATTR_VALUE_BITSET_TYPE cop64_isa;
-  CGEN_ATTR_VALUE_BITSET_TYPE cop_isa;
-  CGEN_ATTR_VALUE_BITSET_TYPE core_isa;
-  unsigned int option_mask;
-} mep_config_map_struct;
-
-extern mep_config_map_struct mep_config_map[];
-extern int mep_config_index;
-
-extern void init_mep_all_core_isas_mask (void);
-extern void init_mep_all_cop_isas_mask  (void);
-extern CGEN_ATTR_VALUE_BITSET_TYPE mep_cop_isa  (void);
-
-#define MEP_CONFIG     (mep_config_map[mep_config_index].config_enum)
-#define MEP_CPU        (mep_config_map[mep_config_index].cpu_flag)
-#define MEP_OMASK      (mep_config_map[mep_config_index].option_mask)
-#define MEP_VLIW       (mep_config_map[mep_config_index].vliw_bits > 0)
-#define MEP_VLIW32     (mep_config_map[mep_config_index].vliw_bits == 32)
-#define MEP_VLIW64     (mep_config_map[mep_config_index].vliw_bits == 64)
-#define MEP_COP16_ISA  (mep_config_map[mep_config_index].cop16_isa)
-#define MEP_COP32_ISA  (mep_config_map[mep_config_index].cop32_isa)
-#define MEP_COP48_ISA  (mep_config_map[mep_config_index].cop48_isa)
-#define MEP_COP64_ISA  (mep_config_map[mep_config_index].cop64_isa)
-#define MEP_COP_ISA    (mep_config_map[mep_config_index].cop_isa)
-#define MEP_CORE_ISA   (mep_config_map[mep_config_index].core_isa)
-
-extern int mep_insn_supported_by_isa (const CGEN_INSN *, CGEN_ATTR_VALUE_BITSET_TYPE *);
-
-/* A mask for all ISAs executed by the core.  */
-#define MEP_ALL_CORE_ISAS_MASK mep_all_core_isas_mask
-extern CGEN_ATTR_VALUE_BITSET_TYPE mep_all_core_isas_mask;
-
-#define MEP_INSN_CORE_P(insn) ( \
-  init_mep_all_core_isas_mask (), \
-  mep_insn_supported_by_isa (insn, & MEP_ALL_CORE_ISAS_MASK) \
-)
-
-/* A mask for all ISAs executed by a VLIW coprocessor.  */
-#define MEP_ALL_COP_ISAS_MASK mep_all_cop_isas_mask 
-extern CGEN_ATTR_VALUE_BITSET_TYPE mep_all_cop_isas_mask;
-
-#define MEP_INSN_COP_P(insn) ( \
-  init_mep_all_cop_isas_mask (), \
-  mep_insn_supported_by_isa (insn, & MEP_ALL_COP_ISAS_MASK) \
-)
-
-extern int mep_cgen_insn_supported (CGEN_CPU_DESC, const CGEN_INSN *);
-
-/* -- asm.c */
-
-#define CGEN_VALIDATE_INSN_SUPPORTED
-
-       const char * parse_csrn       (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *);
-       const char * parse_tpreg      (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *);
-       const char * parse_spreg      (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *);
-       const char * parse_mep_align  (CGEN_CPU_DESC, const char **, enum cgen_operand_type, long *);
-       const char * parse_mep_alignu (CGEN_CPU_DESC, const char **, enum cgen_operand_type, unsigned long *);
-static const char * parse_signed16   (CGEN_CPU_DESC, const char **, int, long *);
-static const char * parse_unsigned16 (CGEN_CPU_DESC, const char **, int, unsigned long *);
-static const char * parse_lo16       (CGEN_CPU_DESC, const char **, int, long *, long);
-static const char * parse_unsigned7  (CGEN_CPU_DESC, const char **, enum cgen_operand_type, unsigned long *);
-static const char * parse_zero       (CGEN_CPU_DESC, const char **, int, long *);
-
-const char *
-parse_csrn (CGEN_CPU_DESC cd, const char **strp,
-	    CGEN_KEYWORD *keyword_table, long *field)
-{
-  const char *err;
-  unsigned long value;
-
-  err = cgen_parse_keyword (cd, strp, keyword_table, field);
-  if (!err)
-    return NULL;
-
-  err = cgen_parse_unsigned_integer (cd, strp, MEP_OPERAND_CSRN_IDX, & value);
-  if (err)
-    return err;
-  *field = value;
-  return NULL;
-}
-
-/* begin-cop-ip-parse-handlers */
-static const char *
-parse_fmax_cr (CGEN_CPU_DESC cd,
-	const char **strp,
-	CGEN_KEYWORD *keyword_table  ATTRIBUTE_UNUSED,
-	long *field)
-{
-  return cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_cr_fmax, field);
-}
-static const char *
-parse_fmax_ccr (CGEN_CPU_DESC cd,
-	const char **strp,
-	CGEN_KEYWORD *keyword_table  ATTRIBUTE_UNUSED,
-	long *field)
-{
-  return cgen_parse_keyword (cd, strp, & mep_cgen_opval_h_ccr_fmax, field);
-}
-/* end-cop-ip-parse-handlers */
-
-const char *
-parse_tpreg (CGEN_CPU_DESC cd, const char ** strp,
-	     CGEN_KEYWORD *keyword_table, long *field)
-{
-  const char *err;
-
-  err = cgen_parse_keyword (cd, strp, keyword_table, field);
-  if (err)
-    return err;
-  if (*field != 13)
-    return _("Only $tp or $13 allowed for this opcode");
-  return NULL;
-}
-
-const char *
-parse_spreg (CGEN_CPU_DESC cd, const char ** strp,
-	     CGEN_KEYWORD *keyword_table, long *field)
-{
-  const char *err;
-
-  err = cgen_parse_keyword (cd, strp, keyword_table, field);
-  if (err)
-    return err;
-  if (*field != 15)
-    return _("Only $sp or $15 allowed for this opcode");
-  return NULL;
-}
-
-const char *
-parse_mep_align (CGEN_CPU_DESC cd, const char ** strp,
-		 enum cgen_operand_type type, long *field)
-{
-  long lsbs = 0;
-  const char *err;
-
-  switch (type)
-    {
-    case MEP_OPERAND_PCREL8A2:
-    case MEP_OPERAND_PCREL12A2:
-    case MEP_OPERAND_PCREL17A2:
-    case MEP_OPERAND_PCREL24A2:
-    case MEP_OPERAND_CDISP8A2:
-    case MEP_OPERAND_CDISP8A4:
-    case MEP_OPERAND_CDISP8A8:
-      err = cgen_parse_signed_integer   (cd, strp, type, field);
-      break;
-    case MEP_OPERAND_PCABS24A2:
-    case MEP_OPERAND_UDISP7:
-    case MEP_OPERAND_UDISP7A2:
-    case MEP_OPERAND_UDISP7A4:
-    case MEP_OPERAND_UIMM7A4:
-    case MEP_OPERAND_ADDR24A4:
-      err = cgen_parse_unsigned_integer (cd, strp, type, (unsigned long *) field);
-      break;
-    default:
-      abort();
-    }
-  if (err)
-    return err;
-  switch (type)
-    {
-    case MEP_OPERAND_UDISP7:
-      lsbs = 0;
-      break;
-    case MEP_OPERAND_PCREL8A2:
-    case MEP_OPERAND_PCREL12A2:
-    case MEP_OPERAND_PCREL17A2:
-    case MEP_OPERAND_PCREL24A2:
-    case MEP_OPERAND_PCABS24A2:
-    case MEP_OPERAND_UDISP7A2:
-    case MEP_OPERAND_CDISP8A2:
-      lsbs = *field & 1;
-      break;
-    case MEP_OPERAND_UDISP7A4:
-    case MEP_OPERAND_UIMM7A4:
-    case MEP_OPERAND_ADDR24A4:
-    case MEP_OPERAND_CDISP8A4:
-      lsbs = *field & 3;
-      break;
-    case MEP_OPERAND_CDISP8A8:
-      lsbs = *field & 7;
-      break;
-    default:
-      /* Safe assumption?  */
-      abort ();
-    }
-  if (lsbs)
-    return "Value is not aligned enough";
-  return NULL;
-}
-
-const char *
-parse_mep_alignu (CGEN_CPU_DESC cd, const char ** strp,
-		 enum cgen_operand_type type, unsigned long *field)
-{
-  return parse_mep_align (cd, strp, type, (long *) field);
-}
-
-
-/* Handle %lo(), %tpoff(), %sdaoff(), %hi(), and other signed
-   constants in a signed context.  */
-
-static const char *
-parse_signed16 (CGEN_CPU_DESC cd,
-		const char **strp,
-		int opindex,
-		long *valuep)
-{
-  return parse_lo16 (cd, strp, opindex, valuep, 1);
-}
-
-static const char *
-parse_lo16 (CGEN_CPU_DESC cd,
-	    const char **strp,
-	    int opindex,
-	    long *valuep,
-	    long signedp)
-{
-  const char *errmsg;
-  enum cgen_parse_operand_result result_type;
-  bfd_vma value;
-
-  if (strncasecmp (*strp, "%lo(", 4) == 0)
-    {
-      *strp += 4;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_MEP_LOW16,
-				   & result_type, & value);
-      if (**strp != ')')
-	return _("missing `)'");
-      ++*strp;
-      if (errmsg == NULL
-	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
-	value &= 0xffff;
-      if (signedp)
-	*valuep = (long)(short) value;
-      else
-	*valuep = value;
-      return errmsg;
-    }
-
-  if (strncasecmp (*strp, "%hi(", 4) == 0)
-    {
-      *strp += 4;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_MEP_HI16S,
-				   & result_type, & value);
-      if (**strp != ')')
-	return _("missing `)'");
-      ++*strp;
-      if (errmsg == NULL
-	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
-	value = (value + 0x8000) >> 16;
-      *valuep = value;
-      return errmsg;
-    }
-
-  if (strncasecmp (*strp, "%uhi(", 5) == 0)
-    {
-      *strp += 5;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_MEP_HI16U,
-				   & result_type, & value);
-      if (**strp != ')')
-	return _("missing `)'");
-      ++*strp;
-      if (errmsg == NULL
-	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
-	value = value >> 16;
-      *valuep = value;
-      return errmsg;
-    }
-
-  if (strncasecmp (*strp, "%sdaoff(", 8) == 0)
-    {
-      *strp += 8;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_MEP_GPREL,
-				   NULL, & value);
-      if (**strp != ')')
-	return _("missing `)'");
-      ++*strp;
-      *valuep = value;
-      return errmsg;
-    }
-
-  if (strncasecmp (*strp, "%tpoff(", 7) == 0)
-    {
-      *strp += 7;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_MEP_TPREL,
-				   NULL, & value);
-      if (**strp != ')')
-	return _("missing `)'");
-      ++*strp;
-      *valuep = value;
-      return errmsg;
-    }
-
-  if (**strp == '%')
-    return _("invalid %function() here");
-
-  return cgen_parse_signed_integer (cd, strp, opindex, valuep);
-}
-
-static const char *
-parse_unsigned16 (CGEN_CPU_DESC cd,
-		  const char **strp,
-		  int opindex,
-		  unsigned long *valuep)
-{
-  return parse_lo16 (cd, strp, opindex, (long *) valuep, 0);
-}
-
-/* A special case of parse_signed16 which accepts only the value zero.  */
-
-static const char *
-parse_zero (CGEN_CPU_DESC cd, const char **strp, int opindex, long *valuep)
-{
-  const char *errmsg;
-  enum cgen_parse_operand_result result_type;
-  bfd_vma value;
-
-  /*fprintf(stderr, "dj: signed parse opindex `%s'\n", *strp);*/
-
-  /* Prevent ($ry) from being attempted as an expression on 'sw $rx,($ry)'.
-     It will fail and cause ry to be listed as an undefined symbol in the
-     listing.  */
-  if (strncmp (*strp, "($", 2) == 0)
-    return "not zero"; /* any string will do -- will never be seen.  */
-
-  if (strncasecmp (*strp, "%lo(", 4) == 0)
-    {
-      *strp += 4;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_MEP_LOW16,
-				   &result_type, &value);
-      if (**strp != ')')
-	return "missing `)'";
-      ++*strp;
-      if (errmsg == NULL
-	  && (result_type != CGEN_PARSE_OPERAND_RESULT_NUMBER || value != 0))
-	return "not zero"; /* any string will do -- will never be seen.  */
-      *valuep = value;
-      return errmsg;
-    }
-
-  if (strncasecmp (*strp, "%hi(", 4) == 0)
-    {
-      *strp += 4;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_MEP_HI16S,
-				   &result_type, &value);
-      if (**strp != ')')
-	return "missing `)'";
-      ++*strp;
-      if (errmsg == NULL
-	  && (result_type != CGEN_PARSE_OPERAND_RESULT_NUMBER || value != 0))
-	return "not zero"; /* any string will do -- will never be seen.  */
-      *valuep = value;
-      return errmsg;
-    }
-
-  if (strncasecmp (*strp, "%uhi(", 5) == 0)
-    {
-      *strp += 5;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_MEP_HI16U,
-				   &result_type, &value);
-      if (**strp != ')')
-	return "missing `)'";
-      ++*strp;
-      if (errmsg == NULL
-	  && (result_type != CGEN_PARSE_OPERAND_RESULT_NUMBER || value != 0))
-	return "not zero"; /* any string will do -- will never be seen.  */
-      *valuep = value;
-      return errmsg;
-    }
-
-  if (strncasecmp (*strp, "%sdaoff(", 8) == 0)
-    {
-      *strp += 8;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_MEP_GPREL,
-				   &result_type, &value);
-      if (**strp != ')')
-	return "missing `)'";
-      ++*strp;
-      if (errmsg == NULL
-	  && (result_type != CGEN_PARSE_OPERAND_RESULT_NUMBER || value != 0))
-	return "not zero"; /* any string will do -- will never be seen.  */
-      *valuep = value;
-      return errmsg;
-    }
-
-  if (strncasecmp (*strp, "%tpoff(", 7) == 0)
-    {
-      *strp += 7;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_MEP_TPREL,
-				   &result_type, &value);
-      if (**strp != ')')
-	return "missing `)'";
-      ++*strp;
-      if (errmsg == NULL
-	  && (result_type != CGEN_PARSE_OPERAND_RESULT_NUMBER || value != 0))
-	return "not zero"; /* any string will do -- will never be seen.  */
-      *valuep = value;
-      return errmsg;
-    }
-
-  if (**strp == '%')
-    return "invalid %function() here";
-
-  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NONE,
-			       &result_type, &value);
-  if (errmsg == NULL
-      && (result_type != CGEN_PARSE_OPERAND_RESULT_NUMBER || value != 0))
-    return "not zero"; /* any string will do -- will never be seen.  */
-
-  return errmsg;
-}
-
-static const char *
-parse_unsigned7 (CGEN_CPU_DESC cd, const char **strp,
-		 enum cgen_operand_type opindex, unsigned long *valuep)
-{
-  const char *errmsg;
-  bfd_vma value;
-
-  /* fprintf(stderr, "dj: unsigned7 parse `%s'\n", *strp); */
-
-  if (strncasecmp (*strp, "%tpoff(", 7) == 0)
-    {
-      int reloc;
-      *strp += 7;
-      switch (opindex)
-	{
-	case MEP_OPERAND_UDISP7:
-	  reloc = BFD_RELOC_MEP_TPREL7;
-	  break;
-	case MEP_OPERAND_UDISP7A2:
-	  reloc = BFD_RELOC_MEP_TPREL7A2;
-	  break;
-	case MEP_OPERAND_UDISP7A4:
-	  reloc = BFD_RELOC_MEP_TPREL7A4;
-	  break;
-	default:
-	  /* Safe assumption?  */
-	  abort (); 
-	}
-      errmsg = cgen_parse_address (cd, strp, opindex, reloc,
-				   NULL, &value);
-      if (**strp != ')')
-	return "missing `)'";
-      ++*strp;
-      *valuep = value;
-      return errmsg;
-    }
-
-  if (**strp == '%')
-    return _("invalid %function() here");
-
-  return parse_mep_alignu (cd, strp, opindex, valuep);
-}
-
-/* BEGIN LIGHTWEIGHT MACRO PROCESSOR.  */
-
-#define MAXARGS 9
-
-typedef struct
-{
-  char *name;
-  char *expansion;
-}  macro;
-
-typedef struct
-{
-  const char *start;
-  int len;
-} arg;
-
-macro macros[] =
-{
-  { "sizeof", "(`1.end + (- `1))"},
-  { "startof", "(`1 | 0)" },
-  { "align4", "(`1&(~3))"},
-/*{ "hi", "(((`1+0x8000)>>16) & 0xffff)" },  */
-/*{ "lo", "(`1 & 0xffff)" },  */
-/*{ "sdaoff", "((`1-__sdabase) & 0x7f)"},  */
-/*{ "tpoff", "((`1-__tpbase) & 0x7f)"},  */
-  { 0,0 }
-};
-
-static char  * expand_string    (const char *, int);
-
-static const char *
-mep_cgen_expand_macros_and_parse_operand
-  (CGEN_CPU_DESC, int, const char **, CGEN_FIELDS *);
-
-static char *
-str_append (char *dest, const char *input, int len)
-{  
-  char *new_dest;
-  int oldlen;
-
-  if (len == 0)
-    return dest;
-  /* printf("str_append: <<%s>>, <<%s>>, %d\n", dest, input, len); */
-  oldlen = (dest ? strlen(dest) : 0);
-  new_dest = realloc (dest, oldlen + len + 1);
-  memset (new_dest + oldlen, 0, len + 1);
-  return strncat (new_dest, input, len);
-}
-
-static macro *
-lookup_macro (const char *name)
-{
-  macro *m;
-
-  for (m = macros; m->name; ++m)
-    if (strncmp (m->name, name, strlen(m->name)) == 0)
-      return m;
-
-  return 0;
-}
-
-static char *
-expand_macro (arg *args, int narg, macro *mac)
-{
-  char *result = 0, *rescanned_result = 0;
-  char *e = mac->expansion;
-  char *mark = e;
-  int arg = 0;
-
-  /*  printf("expanding macro %s with %d args\n", mac->name, narg + 1); */
-  while (*e)
-    {
-      if (*e == '`' && 
-	  (*e+1) && 
-	  ((*(e + 1) - '1') <= MAXARGS) &&
-	  ((*(e + 1) - '1') <= narg))
-	{
-	  result = str_append (result, mark, e - mark);
-	  arg = (*(e + 1) - '1');
-	  /* printf("replacing `%d with %s\n", arg+1, args[arg].start); */
-	  result = str_append (result, args[arg].start, args[arg].len);
-	  ++e;
-	  mark = e+1;
-	}
-      ++e;
-    }
-
-  if (mark != e)
-    result = str_append (result, mark, e - mark);
-
-  if (result)
-    {
-      rescanned_result = expand_string (result, 0);
-      free (result);
-      return rescanned_result;
-    }
-  else 
-    return result;
-}
-
-#define IN_TEXT 0
-#define IN_ARGS 1
-
-static char *
-expand_string (const char *in, int first_only)
-{
-  int num_expansions = 0;
-  int depth = 0;
-  int narg = -1;
-  arg args[MAXARGS];
-  int state = IN_TEXT;
-  const char *mark = in;
-  macro *macro = 0;
-
-  char *expansion = 0;
-  char *result = 0;
-
-  while (*in)
-    {
-      switch (state)
-	{
-	case IN_TEXT:
-	  if (*in == '%' && *(in + 1) && (!first_only || num_expansions == 0)) 
-	    {	      
-	      macro = lookup_macro (in + 1);
-	      if (macro)
-		{
-		  /* printf("entering state %d at '%s'...\n", state, in); */
-		  result = str_append (result, mark, in - mark);
-		  mark = in;
-		  in += 1 + strlen (macro->name);
-		  while (*in == ' ') ++in;
-		  if (*in != '(')
-		    {
-		      state = IN_TEXT;		      
-		      macro = 0;
-		    }
-		  else
-		    {
-		      state = IN_ARGS;
-		      narg = 0;
-		      args[narg].start = in + 1;
-		      args[narg].len = 0;
-		      mark = in + 1;	      		      
-		    }
-		}
-	    }
-	  break;
-	case IN_ARGS:
-	  if (depth == 0)
-	    {
-	      switch (*in)
-		{
-		case ',':
-		  narg++;
-		  args[narg].start = (in + 1);
-		  args[narg].len = 0;
-		  break;
-		case ')':
-		  state = IN_TEXT;
-		  /* printf("entering state %d at '%s'...\n", state, in); */
-		  if (macro)
-		    {
-		      expansion = 0;
-		      expansion = expand_macro (args, narg, macro);
-		      num_expansions++;
-		      if (expansion)
-			{
-			  result = str_append (result, expansion, strlen (expansion));
-			  free (expansion);
-			}
-		    }
-		  else
-		    {
-		      result = str_append (result, mark, in - mark);
-		    }
-		  macro = 0;
-		  mark = in + 1;
-		  break;
-		case '(':
-		  depth++;
-		default:
-		  args[narg].len++;
-		  break;		  
-		}
-	    } 
-	  else
-	    {
-	      if (*in == ')')
-		depth--;
-	      if (narg > -1)
-		args[narg].len++;
-	    }
-	  
-	}
-      ++in;
-    }
-  
-  if (mark != in)
-    result = str_append (result, mark, in - mark);
-  
-  return result;
-}
-
-#undef IN_ARGS
-#undef IN_TEXT
-#undef MAXARGS
-
-
-/* END LIGHTWEIGHT MACRO PROCESSOR.  */
-
-const char * mep_cgen_parse_operand
-  (CGEN_CPU_DESC, int, const char **, CGEN_FIELDS *);
-
-const char *
-mep_cgen_expand_macros_and_parse_operand (CGEN_CPU_DESC cd, int opindex,
-					  const char ** strp_in, CGEN_FIELDS * fields)
-{
-  const char * errmsg = NULL;
-  char *str = 0, *hold = 0;
-  const char **strp = 0;
-
-  /* Set up a new pointer to macro-expanded string.  */
-  str = expand_string (*strp_in, 1);
-  /* fprintf (stderr, " expanded <<%s>> to <<%s>>\n", *strp_in, str); */
-
-  hold = str;
-  strp = (const char **)(&str);
-
-  errmsg = mep_cgen_parse_operand (cd, opindex, strp, fields);
-
-  /* Now work out the advance.  */
-  if (strlen (str) == 0)
-    *strp_in += strlen (*strp_in);
-
-  else
-    {
-      if (strstr (*strp_in, str))
-	/* A macro-expansion was pulled off the front.  */
-	*strp_in = strstr (*strp_in, str);  
-      else
-	/* A non-macro-expansion was pulled off the front.  */
-	*strp_in += (str - hold); 
-    }
-
-  if (hold)
-    free (hold);
-
-  return errmsg;
-}
-
-#define CGEN_ASM_INIT_HOOK (cd->parse_operand = mep_cgen_expand_macros_and_parse_operand); 
-
-/* -- dis.c */
-
-#include "elf/mep.h"
-#include "elf-bfd.h"
-
-#define CGEN_VALIDATE_INSN_SUPPORTED
-
-static void print_tpreg (CGEN_CPU_DESC, PTR, CGEN_KEYWORD *, long, unsigned int);
-static void print_spreg (CGEN_CPU_DESC, PTR, CGEN_KEYWORD *, long, unsigned int);
-
-static void
-print_tpreg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, PTR dis_info,
-	     CGEN_KEYWORD *table ATTRIBUTE_UNUSED, long val ATTRIBUTE_UNUSED,
-	     unsigned int flags ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  (*info->fprintf_func) (info->stream, "$tp");
-}
-
-static void
-print_spreg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, PTR dis_info, 
-	     CGEN_KEYWORD *table ATTRIBUTE_UNUSED, long val ATTRIBUTE_UNUSED,
-	     unsigned int flags ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  (*info->fprintf_func) (info->stream, "$sp");
-}
-
-/* begin-cop-ip-print-handlers */
-static void
-print_fmax_cr (CGEN_CPU_DESC cd,
-	void *dis_info,
-	CGEN_KEYWORD *keyword_table ATTRIBUTE_UNUSED,
-	long value,
-	unsigned int attrs)
-{
-  print_keyword (cd, dis_info, & mep_cgen_opval_h_cr_fmax, value, attrs);
-}
-static void
-print_fmax_ccr (CGEN_CPU_DESC cd,
-	void *dis_info,
-	CGEN_KEYWORD *keyword_table ATTRIBUTE_UNUSED,
-	long value,
-	unsigned int attrs)
-{
-  print_keyword (cd, dis_info, & mep_cgen_opval_h_ccr_fmax, value, attrs);
-}
-/* end-cop-ip-print-handlers */
-
-/************************************************************\
-*********************** Experimental *************************
-\************************************************************/
-
-#undef  CGEN_PRINT_INSN
-#define CGEN_PRINT_INSN mep_print_insn
-
-static int
-mep_print_vliw_insns (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info,
-		      bfd_byte *buf, int corelength, int copro1length,
-		      int copro2length ATTRIBUTE_UNUSED)
-{
-  int i;
-  int status = 0;
-  /* char insnbuf[CGEN_MAX_INSN_SIZE]; */
-  bfd_byte insnbuf[64];
-
-  /* If corelength > 0 then there is a core insn present. It
-     will be at the beginning of the buffer.  After printing
-     the core insn, we need to print the + on the next line.  */
-  if (corelength > 0)
-    {
-      int my_status = 0;
-	 
-      for (i = 0; i < corelength; i++ )
-	insnbuf[i] = buf[i];
-      cd->isas = & MEP_CORE_ISA;
-	 
-      my_status = print_insn (cd, pc, info, insnbuf, corelength);
-      if (my_status != corelength)
-	{
-	  (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
-	  my_status = corelength;
-	}
-      status += my_status;
-
-      /* Print the + to indicate that the following copro insn is   */
-      /* part of a vliw group.                                      */
-      if (copro1length > 0)
-	(*info->fprintf_func) (info->stream, " + "); 
-    }
-
-  /* Now all that is left to be processed is the coprocessor insns
-     In vliw mode, there will always be one.  Its positioning will
-     be from byte corelength to byte corelength+copro1length -1.
-     No need to check for existence.   Also, the first vliw insn,
-     will, as spec'd, always be at least as long as the core insn
-     so we don't need to flush the buffer.  */
-  if (copro1length > 0)
-    {
-      int my_status = 0;
-	 
-      for (i = corelength; i < corelength + copro1length; i++ )
-	insnbuf[i - corelength] = buf[i];
-
-      switch (copro1length)
-	{
-	case 0:
-	  break;
-	case 2:
-	  cd->isas = & MEP_COP16_ISA;
-	  break;
-	case 4:
-	  cd->isas = & MEP_COP32_ISA;
-	  break;
-	case 6:
-	  cd->isas = & MEP_COP48_ISA;
-	  break;
-	case 8:
-	  cd->isas = & MEP_COP64_ISA;
-	  break; 
-	default:
-	  /* Shouldn't be anything but 16,32,48,64.  */
-	  break;
-	}
-
-      my_status = print_insn (cd, pc, info, insnbuf, copro1length);
-
-      if (my_status != copro1length)
-	{
-	  (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
-	  my_status = copro1length;
-	}
-      status += my_status;
-    }
-
-#if 0
-  /* Now we need to process the second copro insn if it exists. We
-     have no guarantee that the second copro insn will be longer
-     than the first, so we have to flush the buffer if we are have
-     a second copro insn to process.  If present, this insn will
-     be in the position from byte corelength+copro1length to byte
-     corelength+copro1length+copro2length-1 (which better equal 8
-     or else we're in big trouble.  */
-  if (copro2length > 0)
-    {
-      int my_status = 0;
-
-      for (i = 0; i < 64 ; i++)
-	insnbuf[i] = 0;
-
-      for (i = corelength + copro1length; i < 64; i++)
-	insnbuf[i - (corelength + copro1length)] = buf[i];
-      
-      switch (copro2length)
-	{
-	case 2:
-	  cd->isas = 1 << ISA_EXT_COP1_16;
-	  break;
-	case 4:
-	  cd->isas = 1 << ISA_EXT_COP1_32;
-	  break;
-	case 6:
-	  cd->isas = 1 << ISA_EXT_COP1_48;
-	  break;
-	case 8:
-	  cd->isas = 1 << ISA_EXT_COP1_64; 
-	  break;
-	default:
-	  /* Shouldn't be anything but 16,32,48,64.  */
-	  break;
-	}
-
-      my_status = print_insn (cd, pc, info, insnbuf, copro2length);
-
-      if (my_status != copro2length)
-	{
-	  (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
-	  my_status = copro2length;
-	}
-
-      status += my_status;
-    }
-#endif
-
-  /* Status should now be the number of bytes that were printed
-     which should be 4 for VLIW32 mode and 64 for VLIW64 mode.  */
-
-  if ((!MEP_VLIW64 && (status != 4)) || (MEP_VLIW64 && (status != 8)))
-    return -1;
-  else
-    return status;
-}
-
-/* The two functions mep_examine_vliw[32,64]_insns are used find out 
-   which vliw combinaion (16 bit core with 48 bit copro, 32 bit core 
-   with 32 bit copro, etc.) is present.  Later on, when internally   
-   parallel coprocessors are handled, only these functions should    
-   need to be changed.                                               
-
-   At this time only the following combinations are supported: 
-   
-   VLIW32 Mode:
-   16 bit core insn (core) and 16 bit coprocessor insn (cop1)
-   32 bit core insn (core)
-   32 bit coprocessor insn (cop1)
-   Note: As of this time, I do not believe we have enough information
-         to distinguish a 32 bit core insn from a 32 bit cop insn. Also,
-         no 16 bit coprocessor insns have been specified.  
-
-   VLIW64 Mode:
-   16 bit core insn (core) and 48 bit coprocessor insn (cop1)
-   32 bit core insn (core) and 32 bit coprocessor insn (cop1)
-   64 bit coprocessor insn (cop1)
-  
-   The framework for an internally parallel coprocessor is also
-   present (2nd coprocessor insn is cop2), but at this time it 
-   is not used.  This only appears to be valid in VLIW64 mode.  */
-
-static int
-mep_examine_vliw32_insns (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
-{
-  int status;
-  int buflength;
-  int corebuflength;
-  int cop1buflength;
-  int cop2buflength;
-  bfd_byte buf[CGEN_MAX_INSN_SIZE];  
-  char indicator16[1];
-  char indicatorcop32[2]; 
-
-  /* At this time we're not supporting internally parallel coprocessors,
-     so cop2buflength will always be 0.  */
-  cop2buflength = 0;
-
-  /* Read in 32 bits.  */
-  buflength = 4; /* VLIW insn spans 4 bytes.  */
-  status = (*info->read_memory_func) (pc, buf, buflength, info);
-
-  if (status != 0)
-    {
-      (*info->memory_error_func) (status, pc, info);
-      return -1;
-    }
-
-  /* Put the big endian representation of the bytes to be examined
-     in the temporary buffers for examination.  */
-
-  if (info->endian == BFD_ENDIAN_BIG)
-    {
-      indicator16[0] = buf[0];
-      indicatorcop32[0] = buf[0];
-      indicatorcop32[1] = buf[1];
-    }
-  else
-    {
-      indicator16[0] = buf[1];
-      indicatorcop32[0] = buf[1];
-      indicatorcop32[1] = buf[0];
-    }
-
-  /* If the two high order bits are 00, 01 or 10, we have a 16 bit
-     core insn and a 48 bit copro insn.  */
-
-  if ((indicator16[0] & 0x80) && (indicator16[0] & 0x40))
-    {
-      if ((indicatorcop32[0] & 0xf0) == 0xf0 && (indicatorcop32[1] & 0x07) == 0x07)
-	{
-          /* We have a 32 bit copro insn.  */
-          corebuflength = 0;
-	  /* All 4 4ytes are one copro insn. */
-          cop1buflength = 4;
-	}
-      else
-	{
-          /* We have a 32 bit core.  */
-          corebuflength = 4;
-          cop1buflength = 0;
-	}
-    }
-  else
-    {
-      /* We have a 16 bit core insn and a 16 bit copro insn.  */
-      corebuflength = 2;
-      cop1buflength = 2;
-    }
-
-  /* Now we have the distrubution set.  Print them out.  */
-  status = mep_print_vliw_insns (cd, pc, info, buf, corebuflength,
-				 cop1buflength, cop2buflength);
-
-  return status;
-}
-
-static int
-mep_examine_vliw64_insns (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
-{
-  int status;
-  int buflength;
-  int corebuflength;
-  int cop1buflength;
-  int cop2buflength;
-  bfd_byte buf[CGEN_MAX_INSN_SIZE];
-  char indicator16[1];
-  char indicator64[4];
-
-  /* At this time we're not supporting internally parallel
-     coprocessors, so cop2buflength will always be 0.  */
-  cop2buflength = 0;
-
-  /* Read in 64 bits.  */
-  buflength = 8; /* VLIW insn spans 8 bytes.  */
-  status = (*info->read_memory_func) (pc, buf, buflength, info);
-
-  if (status != 0)
-    {
-      (*info->memory_error_func) (status, pc, info);
-      return -1;
-    }
-
-  /* We have all 64 bits in the buffer now.  We have to figure out
-     what combination of instruction sizes are present.  The two
-     high order bits will indicate whether or not we have a 16 bit
-     core insn or not.  If not, then we have to look at the 7,8th
-     bytes to tell whether we have 64 bit copro insn or a 32 bit
-     core insn with a 32 bit copro insn.  Endianness will make a
-     difference here.  */
-
-  /* Put the big endian representation of the bytes to be examined
-     in the temporary buffers for examination.  */
-
-  /* indicator16[0] = buf[0];  */
-  if (info->endian == BFD_ENDIAN_BIG)
-    {
-      indicator16[0] = buf[0];
-      indicator64[0] = buf[0];
-      indicator64[1] = buf[1];
-      indicator64[2] = buf[2];
-      indicator64[3] = buf[3];
-    }
-  else
-    {
-      indicator16[0] = buf[1];
-      indicator64[0] = buf[1];
-      indicator64[1] = buf[0];
-      indicator64[2] = buf[3];
-      indicator64[3] = buf[2];
-    }
-
-  /* If the two high order bits are 00, 01 or 10, we have a 16 bit
-     core insn and a 48 bit copro insn.  */
-
-  if ((indicator16[0] & 0x80) && (indicator16[0] & 0x40))
-    {
-      if ((indicator64[0] & 0xf0) == 0xf0 && (indicator64[1] & 0x07) == 0x07
-	  && ((indicator64[2] & 0xfe) != 0xf0 || (indicator64[3] & 0xf4) != 0))
-	{
-          /* We have a 64 bit copro insn.  */
-          corebuflength = 0;
-	  /* All 8 bytes are one copro insn.  */
-          cop1buflength = 8;
-	}
-      else
-	{
-          /* We have a 32 bit core insn and a 32 bit copro insn.  */
-          corebuflength = 4;
-          cop1buflength = 4;
-	}
-    }
-  else
-    {
-      /* We have a 16 bit core insn and a 48 bit copro insn.  */
-      corebuflength = 2;
-      cop1buflength = 6;
-    }
-
-  /* Now we have the distrubution set.  Print them out. */
-  status = mep_print_vliw_insns (cd, pc, info, buf, corebuflength,
-				 cop1buflength, cop2buflength);
-
-  return status;
-}
-
-static int
-mep_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
-{
-  int status;
-
-  /* Extract and adapt to configuration number, if available. */
-  if (info->section && info->section->owner)
-    {
-      bfd *abfd = info->section->owner;
-      mep_config_index = abfd->tdata.elf_obj_data->elf_header->e_flags & EF_MEP_INDEX_MASK;
-      /* This instantly redefines MEP_CONFIG, MEP_OMASK, .... MEP_VLIW64 */
-    }
-
-  /* Picking the right ISA bitmask for the current context is tricky.  */
-  if (info->section)
-    {
-      if (info->section->flags & SEC_MEP_VLIW)
-	{
-	  /* Are we in 32 or 64 bit vliw mode?  */
-	  if (MEP_VLIW64)
-	    status = mep_examine_vliw64_insns (cd, pc, info);
-	  else
-	    status = mep_examine_vliw32_insns (cd, pc, info);
-	  /* Both the above branches set their own isa bitmasks.  */
-	}
-      else
-	{
-	  cd->isas = & MEP_CORE_ISA;
-	  status = default_print_insn (cd, pc, info);
-	}
-    }
-  else /* sid or gdb */
-    {
-      status = default_print_insn (cd, pc, info);
-    }
-
-  return status;
-}
-
-
-/* -- opc.c */
-#include "elf/mep.h"
-
-/* A mask for all ISAs executed by the core. */
-CGEN_ATTR_VALUE_BITSET_TYPE mep_all_core_isas_mask = {0, 0};
-
-void
-init_mep_all_core_isas_mask (void)
-{
-  if (mep_all_core_isas_mask.length != 0)
-    return;
-  cgen_bitset_init (& mep_all_core_isas_mask, ISA_MAX);
-  cgen_bitset_set (& mep_all_core_isas_mask, ISA_MEP);
-  /* begin-all-core-isas */
-  cgen_bitset_add (& mep_all_core_isas_mask, ISA_EXT_CORE1);
-  cgen_bitset_add (& mep_all_core_isas_mask, ISA_EXT_CORE2);
-  /* end-all-core-isas */
-}
-
-CGEN_ATTR_VALUE_BITSET_TYPE mep_all_cop_isas_mask = {0, 0};
-
-void
-init_mep_all_cop_isas_mask (void)
-{
-  if (mep_all_cop_isas_mask.length != 0)
-    return;
-  cgen_bitset_init (& mep_all_cop_isas_mask, ISA_MAX);
-  /* begin-all-cop-isas */
-  cgen_bitset_add (& mep_all_cop_isas_mask, ISA_EXT_COP2_16);
-  cgen_bitset_add (& mep_all_cop_isas_mask, ISA_EXT_COP2_32);
-  cgen_bitset_add (& mep_all_cop_isas_mask, ISA_EXT_COP2_48);
-  cgen_bitset_add (& mep_all_cop_isas_mask, ISA_EXT_COP2_64);
-  /* end-all-cop-isas */
-}
-
-int
-mep_insn_supported_by_isa (const CGEN_INSN *insn, CGEN_ATTR_VALUE_BITSET_TYPE *isa_mask)
-{
-  CGEN_BITSET insn_isas = CGEN_INSN_BITSET_ATTR_VALUE (insn, CGEN_INSN_ISA);
-  return cgen_bitset_intersect_p (& insn_isas, isa_mask);
-}
-
-#define OPTION_MASK \
-	( (1 << CGEN_INSN_OPTIONAL_BIT_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_MUL_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_DIV_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_DEBUG_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_LDZ_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_ABS_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_AVE_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_MINMAX_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_CLIP_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_SAT_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_UCI_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_DSP_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_CP_INSN) \
-	| (1 << CGEN_INSN_OPTIONAL_CP64_INSN) )
-
-
-mep_config_map_struct mep_config_map[] =
-{
-  /* config-map-start */
-  /* Default entry: mep core only, all options enabled. */
-  { "", 0, EF_MEP_CPU_C2, 1, 0, {1,"\x0"}, {1,"\x0"}, {1,"\x0"}, {1,"\x0"}, {1,"\x0"}, {1,"\x80"}, OPTION_MASK },
-  { "simple", CONFIG_SIMPLE, EF_MEP_CPU_C2, 1, 0, { 1, "\x0" }, { 1, "\x0" }, { 1, "\x0" }, { 1, "\x0" }, { 1, "\x0" }, { 1, "\xc0" },
-	  0 },
-  { "fmax", CONFIG_FMAX, EF_MEP_CPU_C2, 1, 0, { 1, "\x10" }, { 1, "\x8" }, { 1, "\x4" }, { 1, "\x2" }, { 1, "\x1e" }, { 1, "\xa0" },
-	  0
-	| (1 << CGEN_INSN_OPTIONAL_CP_INSN)
-	| (1 << CGEN_INSN_OPTIONAL_MUL_INSN)
-	| (1 << CGEN_INSN_OPTIONAL_DIV_INSN)
-	| (1 << CGEN_INSN_OPTIONAL_BIT_INSN)
-	| (1 << CGEN_INSN_OPTIONAL_LDZ_INSN)
-	| (1 << CGEN_INSN_OPTIONAL_ABS_INSN)
-	| (1 << CGEN_INSN_OPTIONAL_AVE_INSN)
-	| (1 << CGEN_INSN_OPTIONAL_MINMAX_INSN)
-	| (1 << CGEN_INSN_OPTIONAL_CLIP_INSN)
-	| (1 << CGEN_INSN_OPTIONAL_SAT_INSN) },
-  /* config-map-end */
-  { 0, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, 0 }
-};
-
-int mep_config_index = 0;
-
-static int
-check_configured_mach (int machs)
-{
-  /* All base insns are supported.  */
-  int mach = 1 << MACH_BASE;
-  switch (MEP_CPU)
-    {
-    case EF_MEP_CPU_C2:
-    case EF_MEP_CPU_C3:
-      mach |= (1 << MACH_MEP);
-      break;
-    case EF_MEP_CPU_H1:
-      mach |= (1 << MACH_H1);
-      break;
-    default:
-      break;
-    }
-  return machs & mach;
-}
-
-int
-mep_cgen_insn_supported (CGEN_CPU_DESC cd, const CGEN_INSN *insn)
-{
-  int iconfig = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_CONFIG);
-  int machs = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_MACH);
-  CGEN_BITSET isas = CGEN_INSN_BITSET_ATTR_VALUE (insn, CGEN_INSN_ISA);
-  int ok1;
-  int ok2;
-  int ok3;
-
-  /* If the insn has an option bit set that we don't want,
-     reject it.  */
-  if (CGEN_INSN_ATTRS (insn)->bool & OPTION_MASK & ~MEP_OMASK)
-    return 0;
-
-  /* If attributes are absent, assume no restriction. */
-  if (machs == 0)
-    machs = ~0;
-
-  ok1 = ((machs & cd->machs) && cgen_bitset_intersect_p (& isas, cd->isas));
-  /* If the insn is config-specific, make sure it matches.  */
-  ok2 =  (iconfig == 0 || iconfig == MEP_CONFIG);
-  /* Make sure the insn is supported by the configured mach  */
-  ok3 = check_configured_mach (machs);
-
-  return (ok1 && ok2 && ok3);
-}
diff -rupN binutils-2.19.1-original/cgen/cpu/mep-rhcop.cpu binutils-2.19.1/cgen/cpu/mep-rhcop.cpu
--- binutils-2.19.1-original/cgen/cpu/mep-rhcop.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/mep-rhcop.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,343 +0,0 @@
-;; This coprocessor definition is being used to verify vliw mode behaviour.
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-;; This is a mock-up done by Red Hat and is in no way supposed to represent
-;; a real coprocessor.  The hardware is defined in mep-core.cpu.
-
-; Coprocessor registers
-(define-pmacro rh-isa-1 () (ISA ext_cop1_16,ext_cop1_32,ext_cop1_48,ext_cop1_64))
-
-(define-hardware
-  (name h-cr64-rh-1)
-  (comment "64-bit coprocessor registers for rh coprocessor for core 1")
-  (attrs VIRTUAL rh-isa-1)
-  (type register DI (32))
-  (set (index newval) (c-call VOID "h_cr64_set" index newval))
-  (get (index) (c-call DI "h_cr64_get" index))
-  (indices keyword "$c" (.map -reg-pair (.iota 32)))
-)
-
-(define-hardware
-  (name h-cr-rh-1)
-  (comment "32-bit coprocessor registers for rh coprocessor for core 1")
-  (attrs VIRTUAL rh-isa-1)
-  (type register SI (32))
-  (set (index newval) (c-call VOID "h_cr64_set" index (ext DI newval)))
-  (get (index) (trunc SI (c-call DI "h_cr64_get" index)))
-  (indices keyword "$c" (.map -reg-pair (.iota 32)))
-)
-
-(define-hardware
-  (name h-ccr-rh-1)
-  (comment "Coprocessor control registers for rh coprocessor for core 1")
-  (attrs VIRTUAL rh-isa-1)
-  (type register SI (64))
-  (set (index newval) (c-call VOID "h_ccr_set" index newval))
-  (get (index) (c-call DI "h_ccr_get" index))
-  (indices keyword "" (.map -ccr-reg-pair (.iota 64)))
-)
- 
-; ifields For 16-bit insns
-(dnf f-cphigh4 "High 4 bits" 		((ISA ext_cop1_16,ext_cop1_32,ext_cop1_48,ext_cop1_64))   0  4)
-(dnf f-cpcrn   "Copro Reg"  		((ISA ext_cop1_16,ext_cop1_32,ext_cop1_48,ext_cop1_64))   4  5)
-(dnf f-cpcrm   "Copro Reg"  		((ISA ext_cop1_16,ext_cop1_32,ext_cop1_48,ext_cop1_64))  11  5)
-(dnf f-uu2   "UU for 16-bit insns"      ((ISA ext_cop1_16))   9  2)
-(dnf f-uu3   "UU for 16-bit insns"      ((ISA ext_cop1_16))   9  3)
-(dnf f-cprm   "Core GPR"                ((ISA ext_cop1_16))  12  4)
-
-; ifields For 32-bit insns (some of the above are used too)
-; Notes: 
-; 
-;  f-alone: A value of 0111 means that the insn can run alone in 
-;           one of the vliw modes.  
-;
-;  f-seg32:   Together f-seg32 and f-seg32-a allow 64 different 32-bit 
-;  f-seg32-a: insns to be defined.
-(dnf f-seg32 "Enumerate 32 bit-insns"     ((ISA ext_cop1_32))   9  3)
-(dnf f-alone "Run-alone indicator"        ((ISA ext_cop1_16,ext_cop1_32,ext_cop1_64))  12  4) 
-(dnf f-seg32-a "Enumerate 32 bit-insns"   ((ISA ext_cop1_32))  21  3)
-(dnf f-code8 "8 bit unsigned immediate"   ((ISA ext_cop1_32))  24 8)
-(dnf f-cpcrm-32 "Corpocessor Reg"         ((ISA ext_cop1_32))  16  5)
-
-; ifields for 48-bit insns
-; Note: Part of f-uu12 can be broken off later to enumerate 
-;       any 48-bit insns that may be added. 
-(dnf f-uu12 "Unusued 12 bits"            ((ISA ext_cop1_48))   4 12)
-(dnf f-code16a "Unsigned immediate"      ((ISA ext_cop1_48))  16 16)
-(dnf f-code16b "Unsigned immediate"      ((ISA ext_cop1_48,ext_cop1_64))  32 16)
-
-; ifields for 64-bit insns
-(dnf f-uu8 "Unsused 8 bits"               ((ISA ext_cop1_64))   4  8)
-(dnf f-uu8a "Unused 13 bits"              ((ISA ext_cop1_64))  16  8)
-(dnf f-seg64 "Enumerate 64-bit insns"     ((ISA ext_cop1_64))  24  8)
-(dnf f-code16c "Unsigned immediate"       ((ISA ext_cop1_64))  48 16)
-(dnf f-cpcrn-64 "Coprocessor Register"    ((ISA ext_cop1_64))  32  5)
-(dnf f-cpcrm-64 "Coprocessor Register"    ((ISA ext_cop1_64))  37  4)
-(dnf f-code23 "23 Bit Unisgned Immediate" ((ISA ext_cop1_64))  41 23)
-(dnf f-cpccrn-64 "Coprocessor Register"   ((ISA ext_cop1_64))  32  4)
-(dnf f-cpccrm-64 "Core GPR"               ((ISA ext_cop1_64))  36  4)
-(dnf f-code24 "24 Bit Unisgned Immediate" ((ISA ext_cop1_64))  40 24)
-
-
-; Operands for 16-bit insns
-(dnop cpcrn   "cpcrn"  ((ISA ext_cop1_16,ext_cop1_32)) h-cr64-rh-1 f-cpcrn)
-(dnop cpcrm   "cpcrm"  ((ISA ext_cop1_16,ext_cop1_32)) h-cr64-rh-1 f-cpcrm)
-(dnop cprm    "cprm"   ((ISA ext_cop1_16)) h-gpr f-cprm)
-
-; Additional operands for 32-bit insns 
-(dnop code8 "imm8" ((ISA ext_cop1_32)) h-uint f-code8)
-
-; Operands for 48-bit insns
-(dnop code16a "code16a" ((ISA ext_cop1_48)) h-uint f-code16a)
-(dnop code16b "code16b" ((ISA ext_cop1_48,ext_cop1_64)) h-uint f-code16b)
-
-; Additional operands for 64-bit insns
-(dnop code16c "code16c" ((ISA ext_cop1_64)) h-uint f-code16c)
-(dnop cpcrn64 "cpcrn64" ((ISA ext_cop1_64)) h-cr64-rh-1 f-cpcrn-64)
-(dnop cpcrm64 "crm64" ((ISA ext_cop1_64)) h-gpr f-cpcrm-64)
-(dnop cpccrn64 "cpccrn64" ((ISA ext_cop1_64)) h-ccr-rh-1 f-cpccrn-64)
-(dnop cpccrm64 "cpccrm64" ((ISA ext_cop1_64)) h-gpr f-cpccrm-64)
-(dnop cpcode23 "cpcode23" ((ISA ext_cop1_64)) h-uint f-code23)
-(dnop cpcode24 "cpcode24" ((ISA ext_cop1_64)) h-uint f-code24)
-
-
-
-; 16- and 32-bit nops can be defined as normal instructions without
-; any problems.  nops take no operands, so nops longer than 32 
-; bits cannot be defined as normal insns since that would result in
-; decodable bits beyond cgen's 32-bit boundary.  As a result, we
-; have to use macros and other real insns to create 48- and 64-bit nops.
-; 
-; In addition, since the names of the nops that will be created as part
-; of future insn sets are not known at this time, the assembler needs a
-; fixed set of nop names that it can use for automatic nop insertion.  
-; The idea is that no matter what those insns are called, we don't want
-; to have to change the C code in the assemblers vliw grouping validation
-; and nop insertion routines.  We therefore have to create macros for
-; all nops to map the macro names which are known to the assembler to the
-; names of the real nop insns.
-;
-; These emitted insns in these macros will need to be modified when
-; new nops are defined in new coprocessor insn sets.
-
-; A real 16-bit nop insn exists
-(dnmi cpnop16 "cpnop16"
-      ((ISA ext_cop1_16))
-      "cpnop16"
-      (emit cp16nop)
-)
-
-; A real 32-bit nop insn exists
-(dnmi cpnop32 "cpnop32"
-      ((ISA ext_cop1_32))
-      "cpnop32"
-      (emit cp32nop)
-)
-
-; There is no 48-bit nop insn so we use a real "dummy" insn to enable the nop.
-(dnmi cpnop48 "cpnop48"
-      ((ISA ext_cop1_48))
-      "cpnop48"
-      (emit cpf1nop (code16a 0) (code16b 0))
-)
-
-; There is no 64-bit nop insn so we use a real "dummy" insn to enable the nop.
-(dnmi cpnop64 "cpnop64"
-      ((ISA ext_cop1_64))
-      "cpnop64"
-      (emit cpf3nop (code16b 0) (code16c 0))
-)
-
-
-(define-pmacro (dncp116i xname xcomment xattrs xsyntax xformat xsemantics xtiming)  (dni-isa xname xcomment xattrs xsyntax xformat xsemantics xtiming ext_cop1_16))
-(define-pmacro (dncp132i xname xcomment xattrs xsyntax xformat xsemantics xtiming)  (dni-isa xname xcomment xattrs xsyntax xformat xsemantics xtiming ext_cop1_32))
-(define-pmacro (dncp148i xname xcomment xattrs xsyntax xformat xsemantics xtiming)  (dni-isa xname xcomment xattrs xsyntax xformat xsemantics xtiming ext_cop1_48))
-(define-pmacro (dncp164i xname xcomment xattrs xsyntax xformat xsemantics xtiming)  (dni-isa xname xcomment xattrs xsyntax xformat xsemantics xtiming ext_cop1_64))
-
-; 16-Bit Insns
-(dncp116i movcp16 "16-bit coprocessor move insn"
-        (VLIW64_NO_MATCHING_NOP)
-        "movcp16 $cpcrn,$cpcrm"
-        (+ (f-cphigh4 1) cpcrn (f-uu2 0) cpcrm)
-        (set cpcrn cpcrm)
-        () 
-)
-
-(dncp116i movcp16a "16-bit coprocessor move insn" 
-	(VLIW64_NO_MATCHING_NOP)
-	"movcp16a $cpcrn,$cprm"
-        (+ (f-cphigh4 2) cpcrn (f-uu3 0) cprm)
-        (set cpcrn (zext DI cprm))
-        ()
-)
-
-(dncp116i movcp16b "16-bit coprocessor move insn" 
-	(VLIW64_NO_MATCHING_NOP)
-	"movcp16b $cprm,$cpcrn"
-        (+ (f-cphigh4 3) cpcrn (f-uu3 0) cprm)
-	(set cprm (subword SI cpcrn 1))
-        ()
-)
-
-(dncp116i cp16nop "16-bit coprocessor nop" 
-	(VLIW64_NO_MATCHING_NOP)
-	"cp16nop"
-        (+ (f-cphigh4 0) (f-cpcrn 0) (f-uu2 0) (f-cpcrm 0))
-	(unimp "cp16nop")
-        ()
-)
-
-; 32-Bit Insns
-(dncp132i cp32nop "32-bit coprocessor nop" 
-	(VLIW64_NO_MATCHING_NOP)
-	"cp32nop"
-        (+ (f-cphigh4 #xf ) (f-cpcrn 0) (f-seg32 0) (f-alone #x7) 
-           (f-cpcrm-32 0) (f-seg32-a 0) (f-code8 0))
-	(unimp "cpnop32")
-        ()
-)
-
-(dncp132i cpf2 "General 32-bit insn for compatibility with toshiba's tests " 
-	(VLIW64_NO_MATCHING_NOP)
-	"cpf2 $code8"
-        (+ (f-cphigh4 #xf ) (f-cpcrn 0) (f-seg32 0) (f-alone #x7) 
-           (f-cpcrm-32 0) (f-seg32-a 1) code8)
-	(unimp "cpf2")
-        ()
-)
-
-; 48-Bit Insns
-(dncp148i cpf1 "48-bit coprocessor helper insn" 
-	()
-	"cpf1 $code16a,$code16b"
-        (+ (f-cphigh4 4) (f-uu12 0) code16a code16b) 
-	(sequence ((HI result))
-           (if (eq code16a 0)
-               (set pc (c-call USI "cop_exception" pc))
-               ; Set branch condition flags to value of code16a[0:3]
-               ; Branch condition flags do not exist yet.
-               (nop)
-           )
-        )
-        ()
-)
-
-(dncp148i cpf1nop "48-bit coprocessor nop insn" 
-	()
-	"cpf1nop $code16a,$code16b"
-        (+ (f-cphigh4 5) (f-uu12 0) code16a code16b) 
-	(sequence ((HI result))
-           (set result (add code16a code16b))
-        )
-        ()
-)
-
-; 64-Bit Insns
-(dncp164i cpf3 "64-bit coprocessor helper insn" 
-	()
-	"cpf3 $code16b,$code16c"
-        (+ (f-cphigh4 #xf) (f-uu8 0) (f-alone 7) (f-uu8a 0) 
-           (f-seg64 0) code16b code16c)
-	(sequence ((HI result))
-           (set result (add code16b code16c))
-        )
-        ()
-)
-
-(dncp164i cpf3nop "64-bit coprocessor helper insn" 
-	()
-	"cpf3nop $code16b,$code16c"
-        (+ (f-cphigh4 #xf) (f-uu8 0) (f-alone 7) (f-uu8a 0) 
-           (f-seg64 7) code16b code16c)
-	(sequence ((HI result))
-           (set result (add code16b code16c))
-        )
-        ()
-)
-
-(dncp164i cmov64a "64-bit cmov" 
-	()
-	"cmov64a $cpcrn64,$cpcrm64,$cpcode23"
-        (+ (f-cphigh4 #xf ) (f-uu8 0) (f-alone 7) (f-uu8a 0) 
-           (f-seg64 1) cpcrn64 cpcrm64 cpcode23) 
-        (sequence ((SI dummy))
-           (set dummy cpcode23)
-           (set cpcrn64 (zext DI cpcrm64)))
-        ()
-)
-
-(dncp164i cmov64b "64-bit cmov" 
-	()
-	"cmov64b $cpcrm64,$cpcrn64,$cpcode23"
-        (+ (f-cphigh4 #xf ) (f-uu8 0) (f-alone 7) (f-uu8a 0) 
-           (f-seg64 2) cpcrn64 cpcrm64 cpcode23) 
-        (sequence ((SI dummy))
-          (set dummy cpcode23)
-          (set cpcrm64 (subword SI cpcrn64 1)))
-        ()
-)
-
-(dncp164i cmovh64a "64-bit cmovh" 
-	()
-	"cmovh64a $cpcrn64,$cpcrm64,$cpcode23"
-        (+ (f-cphigh4 #xf ) (f-uu8 0) (f-alone 7) (f-uu8a 0) 
-           (f-seg64 3) cpcrn64 cpcrm64 cpcode23) 
-        (sequence ((SI dummy))
-           (set dummy cpcode23)
-           (set cpcrn64 (or (sll (zext DI cpcrm64) 32) (zext DI (subword SI cpcrn64 1)))))
-        ()
-)
-
-(dncp164i cmovh64b "64-bit cmovh" 
-	()
-	"cmovh64b $cpcrm64,$cpcrn64,$cpcode23"
-        (+ (f-cphigh4 #xf ) (f-uu8 0) (f-alone 7) (f-uu8a 0) 
-           (f-seg64 4) cpcrn64 cpcrm64 cpcode23) 
-        (sequence ((SI dummy))
-           (set dummy cpcode23)
-           (set cpcrm64 (subword SI cpcrn64 0)))
-        ()
-)
-
-(dncp164i cmovc64a "64-bit cmovc" 
-	()
-	"cmovc64a $cpccrn64,$cpccrm64,$cpcode24"
-        (+ (f-cphigh4 #xf ) (f-uu8 0) (f-alone 7) (f-uu8a 0) 
-           (f-seg64 5) cpccrn64 cpccrm64 cpcode24) 
-        (sequence ((SI dummy))
-           (set dummy cpcode24)
-           (set cpccrn64 cpccrm64))
-        ()
-)
-
-(dncp164i cmovc64b "64-bit cmovc" 
-	()
-	"cmovc64b $cpccrm64,$cpccrn64,$cpcode24"
-        (+ (f-cphigh4 #xf ) (f-uu8 0) (f-alone 7) (f-uu8a 0) 
-           (f-seg64 6) cpccrn64 cpccrm64 cpcode24) 
-        (sequence ((SI dummy))
-           (set dummy cpcode24)
-           (set cpccrm64 cpccrn64))
-        ()
-)
-
diff -rupN binutils-2.19.1-original/cgen/cpu/mep-sample-ucidsp.cpu binutils-2.19.1/cgen/cpu/mep-sample-ucidsp.cpu
--- binutils-2.19.1-original/cgen/cpu/mep-sample-ucidsp.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/mep-sample-ucidsp.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,121 +0,0 @@
-
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-; This file provides sample definitions for the UCI and DSP
-; instructions.  It is incorporated into the overall description by
-; including it from a top-level file that includes all of the required
-; option files.
-
-; UCI option.
-
-(define-pmacro mep-ext1-isa () (ISA ext_core1))
-
-
-; uci instructions for ELFextension test
-
-; uci.elfext.1    $simm16
-; 1111_IIII_0000_0010 0001_iiii_iiii_iiii
-; simm16 = I[4:7]||i[20:31]
-
-; uci.elfext.2    $uimm16
-; 1111_IIII_0000_0010 0010_iiii_iiii_iiii
-; uimm16 = I[4:7]||i[20:31]
-
-; define simm16
-(df f-uci_elfext_1-hi  "uci_elfext_1 simm16 hi 4s7"   (mep-ext1-isa)  4  4  INT #f #f)
-(df f-uci_elfext_1-lo  "uci_elfext_1 simm16 lo 20s31" (mep-ext1-isa) 20 12 UINT #f #f)
-(define-multi-ifield
-  (name f-uci_elfext_1)
-  (comment "16-bits uci_elfext_ signed constant")
-  (attrs mep-ext1-isa)
-  (mode INT)
-  (subfields f-uci_elfext_1-hi f-uci_elfext_1-lo)
-  (insert (sequence ()
-                    (set (ifield f-uci_elfext_1-hi) (srl (ifield f-uci_elfext_1) 12))
-                    (set (ifield f-uci_elfext_1-lo) (and (ifield f-uci_elfext_1) #xfff))))
-  (extract (set (ifield f-uci_elfext_1)
-                (or (sll (ifield f-uci_elfext_1-hi) 12)
-                    (ifield f-uci_elfext_1-lo))))
-  )
-(dpop uci_elfext_1simm16    "signed imm (16 bits)"  (mep-ext1-isa) h-sint  f-uci_elfext_1  "signed16")
-
-; define uimm16
-(df f-uci_elfext_2-hi  "uci_elfext_2 uimm16 hi 4u7"   (mep-ext1-isa)  4  4 UINT #f #f)
-(df f-uci_elfext_2-lo  "uci_elfext_2 uimm16 lo 20u31" (mep-ext1-isa) 20 12 UINT #f #f)
-(define-multi-ifield
-  (name f-uci_elfext_2)
-  (comment "16-bits uci_elfext_ unsigned constant")
-  (attrs mep-ext1-isa)
-  (mode UINT)
-  (subfields f-uci_elfext_2-hi f-uci_elfext_2-lo)
-  (insert (sequence ()
-                    (set (ifield f-uci_elfext_2-hi) (srl (ifield f-uci_elfext_2) 12))
-                    (set (ifield f-uci_elfext_2-lo) (and (ifield f-uci_elfext_2) #xfff))))
-  (extract (set (ifield f-uci_elfext_2)
-                (or (sll (ifield f-uci_elfext_2-hi) 12)
-                    (ifield f-uci_elfext_2-lo))))
-  )
-(dpop uci_elfext_2uimm16    "unsigned imm (16 bits)"  (mep-ext1-isa) h-uint  f-uci_elfext_2  "unsigned16")
-
-; define sub-opcode
-(df f-uci_elfext-sub  "sub-opcode for uci_elfext instructions"  (mep-ext1-isa) 16 4 UINT #f #f)
-
-
-; define instruction
-(dni uci.elfext.1 "uci_elfext instruction 1" (OPTIONAL_UCI_INSN VOLATILE mep-ext1-isa)
-	 "uci.elfext.1 $uci_elfext_1simm16"
-	 (+ MAJ_15 (f-rm 0) (f-sub4 2) (f-uci_elfext-sub 1) uci_elfext_1simm16)
-	 (c-call "check_option_uci" pc)
-	 ()
-	 )
-
-; define instruction
-(dni uci.elfext.2 "uci_elfext instruction 1" (OPTIONAL_UCI_INSN VOLATILE mep-ext1-isa)
-	 "uci.elfext.2 $uci_elfext_2uimm16"
-	 (+ MAJ_15 (f-rm 0) (f-sub4 2) (f-uci_elfext-sub 2) uci_elfext_2uimm16)
-	 (c-call "check_option_uci" pc)
-	 ()
-	 )
-
-
-
-;; some general samples
-; UCI option.
-
-(dni uci "user defined instruction" (OPTIONAL_UCI_INSN mep-ext1-isa)
-     "uci $rn,$rm,$code16"
-     (+ MAJ_15 rn rm (f-sub4 2) code16)
-     (sequence ()
-	       (c-call "check_option_uci" pc)
-	       (unimp "uci"))
-     ())
-
-; DSP option.
-
-(dni dsp "dsp instruction" (OPTIONAL_DSP_INSN mep-ext1-isa)
-     "dsp $rn,$rm,$code16"
-     (+ MAJ_15 rn rm (f-sub4 0) code16)
-     (sequence ()
-	       (c-call "check_option_dsp" pc)
-	       (set pc (c-call USI "dsp_exception" pc)))
-     ())
diff -rupN binutils-2.19.1-original/cgen/cpu/openrisc.cpu binutils-2.19.1/cgen/cpu/openrisc.cpu
--- binutils-2.19.1-original/cgen/cpu/openrisc.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/openrisc.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,779 +0,0 @@
-
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-(include "simplify.inc")
-
-; OpenRISC 1000 is an architecture of a family of open source, 
-; synthesizeable RISC microprocessor cores. It is a 32-bit load 
-; and  store RISC architecture designed  with emphasis on speed,
-; compact instruction set and scalability. OpenRISC 1000 targets
-; wide range of embedded environments. 
-
-(define-arch
-  (name openrisc)
-  (comment "OpenRISC 1000")
-  (insn-lsb0? #t)
-  (machs openrisc or1300)
-  (isas or32)
-)
-
-
-; Attributes
-
-; An attribute to describe if a model has insn and/or data caches.
-(define-attr
-  (for model)
-  (type enum)
-  (name HAS-CACHE)
-  (comment "if this model has caches")
-  (values DATA-CACHE INSN-CACHE)
-)
-
-; An attribute to describe if an insn can be in the delay slot or not.
-(define-attr
-  (for insn)
-  (type boolean)
-  (name NOT-IN-DELAY-SLOT)
-  (comment "insn can't go in delay slot")
-)
-
-; IDOC attribute for instruction documentation.
-
-(define-attr
-  (for insn)
-  (type enum)
-  (name IDOC)
-  (comment "insn kind for documentation")
-  (attrs META)
-  (values
-   (MEM - () "Memory")
-   (ALU - () "ALU")
-   (FPU - () "FPU")
-   (BR - () "Branch")
-   (PRIV - () "Priviledged")
-   (MISC - () "Miscellaneous")
-  )
-)
-
-; Enum for exception vectors.
-(define-enum
-  (name e-exception)
-  (comment "exception vectors")
-  (attrs)
-  (prefix E_)
-  (values (("RESET") ("BUSERR" -) ("DPF" -) ("IPF" -) ("EXTINT" -) ("ALIGN" -) 
-          ("ILLEGAL" -) ("PEINT" -) ("DTLBMISS" -) ("ITLBMISS" -) ("RRANGE" -) 
-          ("SYSCALL" -) ("BREAK" -) ("RESERVED" -)))
-)
-
-
-; Instruction set parameters.
- 
-(define-isa
-  ; Name of the ISA.
-  (name or32)
-
-  ; Base insturction length.  The insns is always 32 bits wide.
-  (base-insn-bitsize 32)
-
-  ; Address of insn in delay slot
-  (setup-semantics (set-quiet (reg h-delay-insn) (add pc (attr (current-insn) 4))))
-)
-
-
-; CPU family definitions.
-  
-(define-cpu
-  ; CPU names must be distinct from the architecture name and machine names.
-  ; The "b" suffix stands for "base" and is the convention.
-  ; The "f" suffix stands for "family" and is the convention.
-  (name openriscbf)
-  (comment "OpenRISC base family")
-  (endian big)
-  (word-bitsize 32)
-)
-
-; Generic machine
-(define-mach
-  (name openrisc)
-  (comment "Generic OpenRISC cpu")
-  (cpu openriscbf)
-  (bfd-name "openrisc")
-)
-
-; OpenRISC 1300 machine
-(define-mach
-  (name or1300)
-  (comment "OpenRISC 1300")
-  (cpu openriscbf)
-  (bfd-name "openrisc:1300")
-)
-
-
-; Model descriptions
-
-; Generic OpenRISC model 
-(define-model
-  (name openrisc-1) (comment "OpenRISC generic model")  (attrs)
-  (mach openrisc)
-
-  ; Nothing special about this.
-  (unit u-exec "Execution Unit" () 1 1 () () () ())
-)
-
-; OpenRISC 1320 
-(define-model
-  (name or1320-1) (comment "OpenRISC 1320 model") 
-
-  ; This model has both instruction and data cache
-  (attrs (HAS-CACHE INSN-CACHE,DATA-CACHE))
-  (mach or1300)
-
-  ; Nothing special about this.
-  (unit u-exec "Execution Unit" () 1 1 () () () ())
-)
-
-
-; Instruction fields.
-
-; Attributes:
-;  . PCREL-ADDR  pc relative value (for reloc and disassembly purposes)
-;  . ABS-ADDR    absolute address (for reloc and disassembly purposes?)
-;  . RESERVED    bits are not used to decode insn, must be all 0
-
-; Instruction classes.
-(dnf f-class     "insn class"          () 31 2)
-(dnf f-sub       "sub class"           () 29 4)
-
-; Register fields.
-(dnf f-r1        "r1"                  () 25 5)
-(dnf f-r2        "r2"                  () 20 5)
-(dnf f-r3        "r3"                  () 15 5)
-
-; Immediates.
-(df  f-simm16    "signed imm (16)"     () 15 16 INT #f #f)
-(dnf f-uimm16    "unsigned imm (16)"   () 15 16)
-(dnf f-uimm5     "unsigned imm (5)"    () 4  5)
-(df  f-hi16      "high 16"             () 15 16 INT #f #f)
-(df  f-lo16      "low 16"              () 15 16 INT #f #f)
-
-; Sub fields
-(dnf f-op1       "op1"                 () 31 2)
-(dnf f-op2       "op2"                 () 29 4)
-(dnf f-op3       "op3"                 () 25 2)
-(dnf f-op4       "op4"                 () 23 3)
-(dnf f-op5       "op3"                 () 25 5)
-(dnf f-op6       "op4"                 () 7  3)
-(dnf f-op7       "op5"                 () 3  4)
-
-(dnf f-i16-1     "uimm16-1"            () 10 11)
-(dnf f-i16-2     "uimm16-2"            () 25  5)
-
-; PC relative, 26-bit (2 shifted to right)
-(df f-disp26     "disp26"              (PCREL-ADDR) 25 26 INT
-    ((value pc) (sra WI (sub WI value pc) (const 2)))
-    ((value pc) (add WI (sll WI value (const 2)) pc)))
-
-; absolute, 26-bit (2 shifted to right)
-(df f-abs26      "abs26"               (ABS-ADDR) 25 26 INT
-    ((value pc) (sra WI pc     (const 2)))
-    ((value pc) (sll WI value  (const 2))))
-
-(define-multi-ifield
-  (name f-i16nc)
-  (comment "16 bit signed")
-  (attrs SIGN-OPT)
-  (mode HI)
-  (subfields f-i16-1 f-i16-2)
-  (insert (sequence ()
-                    (set (ifield f-i16-2) (and (sra (ifield f-i16nc) 
-                                                    (const 11)) 
-                                               (const #x1f)))
-                    (set (ifield f-i16-1) (and (ifield f-i16nc) 
-                                               (const #x7ff)))))
-  (extract (sequence ()
-                     (set (ifield f-i16nc) (c-raw-call SI "@arch@_sign_extend_16bit" 
-                                           (or (sll (ifield f-i16-2) 
-                                                    (const 11))
-                                               (ifield f-i16-1))))))
-)
-
-
-; Enums.
-
-; insn-class: bits 31-30
-(define-normal-insn-enum insn-class "FIXME" () OP1_ f-class
-  (.map .str (.iota 4))
-)
-
-(define-normal-insn-enum insn-sub "FIXME" () OP2_ f-sub
-  (.map .str (.iota 16))
-)
-
-(define-normal-insn-enum insn-op3 "FIXME" () OP3_ f-op3
-  (.map .str (.iota 4))
-)
-
-(define-normal-insn-enum insn-op4 "FIXME" () OP4_ f-op4
-  (.map .str (.iota 8))
-)
-
-(define-normal-insn-enum insn-op5  "FIXME" () OP5_ f-op5
-  (.map .str (.iota 32))
-)
-
-(define-normal-insn-enum insn-op6  "FIXME" () OP6_ f-op6
-  (.map .str (.iota 8))
-)
-
-(define-normal-insn-enum insn-op7  "FIXME" () OP7_ f-op7
-  (.map .str (.iota 16))
-)
-
-
-
-; Hardware pieces.
-; These entries list the elements of the raw hardware.
-; They're also used to provide tables and other elements of the assembly
-; language.
-
-(dnh h-pc "program counter" (PC PROFILE) (pc) () () ())
-
-(define-hardware
-  (name h-gr) (comment "general registers") (attrs PROFILE)
-  (type register WI (32))
-  (indices keyword ""
-           ((r0 0) (r1 1) (r2 2) (r3 3) (r4 4) (r5 5) (r6 6) (r7 7)
-            (r8 8) (r9 9) (r10 10) (r11 11) (r12 12) (r13 13) (r14 14) 
-            (r15 15) (r16 16) (r17 17) (r18 18) (r19 19) (r20 20) 
-            (r21 21) (r22 22) (r23 23) (r24 24) (r25 25) (r26 26) 
-            (r27 27) (r28 28) (r29 29) (r30 30) (r31 31) (lr 11) 
-            (sp 1)  (fp 2)))
-)
-
-(define-hardware
-  (name h-sr) (comment "special registers")
-  (type register WI (#x20000))    
-  (get (index) (c-call SI "@arch@_h_sr_get_handler" index))
-  (set (index newval) (c-call VOID "@arch@_h_sr_set_handler" index newval))
-)
-
-(dnh h-hi16 "high 16 bits" () (immediate (INT 16)) () () ())
-(dnh h-lo16 "low 16 bits"  () (immediate (INT 16)) () () ())
-
-(dsh h-cbit "condition bit" () (register BI))
-(dsh h-delay-insn "delay insn addr" () (register SI))
-
-
-; Instruction operands.
-
-(dnop sr      "special register"           (SEM-ONLY)  h-sr   f-nil)
-(dnop cbit    "condition bit"              (SEM-ONLY)  h-cbit f-nil)
-(dnop simm-16 "16 bit signed immediate"    ()          h-sint f-simm16)
-(dnop uimm-16 "16 bit unsigned immediate"  ()          h-uint f-uimm16)
-(dnop disp-26 "pc-rel 26 bit"              ()          h-iaddr f-disp26)
-(dnop abs-26  "abs 26 bit"                 ()          h-iaddr f-abs26)
-(dnop uimm-5  "imm5"                       ()          h-uint f-uimm5)
-
-(dnop rD      "destination register"       ()          h-gr   f-r1)
-(dnop rA      "source register A"          ()          h-gr   f-r2)
-(dnop rB      "source register B"          ()          h-gr   f-r3)
-
-(dnop op-f-23 "f-op23"                     ()          h-uint f-op4)
-(dnop op-f-3  "f-op3"                      ()          h-uint f-op5)
-
-; For hi(foo).
-(define-operand
-  (name hi16) (comment "high 16 bit immediate, sign optional") 
-  (attrs SIGN-OPT)
-  (type h-hi16)
-  (index f-simm16)
-  (handlers (parse "hi16"))
-)
-
-; For lo(foo)
-(define-operand
-  (name lo16) (comment "low 16 bit immediate, sign optional")
-  (attrs SIGN-OPT)
-  (type h-lo16)
-  (index f-lo16)
-  (handlers (parse "lo16"))
-)
-
-(define-operand
-  (name ui16nc)
-  (comment "16 bit immediate, sign optional")
-  (attrs)
-  (type h-lo16)
-  (index f-i16nc)
-  (handlers (parse "lo16"))
-)
-
-
-; Instructions.
-
-; Branch releated instructions 
-
-(dni l-j "jump (absolute iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT) 
-
-     "l.j ${abs-26}"
-     (+ OP1_0 OP2_0 abs-26)
-
-     ; We execute the delay slot before doin' the real branch
-     (delay 1 (set pc abs-26))
-     ()
-)
-
-(dni l-jal "jump and link (absolute iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.jal ${abs-26}"
-     (+ OP1_0 OP2_1 abs-26)
-
-     ; We execute the delay slot before doin' the real branch
-     ; Set LR to (delay insn addr + 4)
-     (sequence ()
-               (set (reg h-gr 11) (add (reg h-delay-insn) 4))
-               (delay 1 (set pc abs-26)))
-     ()
-)
-
-(dni l-jr "jump register (absolute iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.jr $rA"
-     (+ OP1_0 OP2_5 OP3_0 OP4_0 rA uimm-16)
-
-     ; We execute the delay slot before doin' the real branch
-     (delay 1 (set pc rA))
-     ()
-)
-
-(dni l-jalr "jump register and link (absolute iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.jalr $rA"
-     (+ OP1_0 OP2_5 OP3_0 OP4_1 rA uimm-16)
-
-     ; We save the value of rA in a temporary slot before setting
-     ; the link register.  This because "l.jalr r11" would cause
-     ; a forever-and-ever loop otherwise.
-     ;
-     ; We execute the delay slot before doin' the real branch
-     (sequence ((WI tmp-slot))
-               (set tmp-slot rA)
-               (set (reg h-gr 11) (add (reg h-delay-insn) 4))
-               (delay 1 (set pc tmp-slot)))
-     ()
-)
-
-(dni l-bal "branch and link (pc relative iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.bal ${disp-26}"
-     (+ OP1_0 OP2_2 disp-26)
-
-     ; We execute the delay slot before doin' the real branch
-     ; Set LR to (delay insn addr + 4)
-     (sequence ()
-               (set (reg h-gr 11) (add (reg h-delay-insn) 4))
-               (delay 1 (set pc disp-26)))
-     ()
-)
-
-(dni l-bnf "branch if condition bit not set (pc relative iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.bnf ${disp-26}"
-     (+ OP1_0 OP2_3 disp-26)
-
-     ; We execute the delay slot before doin' the real branch
-     (if (eq cbit 0)
-         (sequence ()
-                   (delay 1 (set pc disp-26))))
-     ()
-)
-
-(dni l-bf "branch if condition bit is set (pc relative iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.bf ${disp-26}"
-     (+ OP1_0 OP2_4 disp-26)
-
-     ; We execute the delay slot before doin' the real branch
-     (if (eq cbit 1)
-         (sequence ()
-                   (delay 1 (set pc disp-26))))
-     ()
-)
-
-(dni l-brk "break (exception)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.brk ${uimm-16}"
-     (+ OP1_0 OP2_5 OP3_3 OP4_0 rA uimm-16)
-
-     ; FIXME should we do it like this ??
-     (c-call VOID "@cpu@_cpu_brk" uimm-16)
-     ()
-)
-
-(dni l-rfe "return from exception"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.rfe $rA"
-     (+ OP1_0 OP2_5 OP3_0 OP4_2 rA uimm-16)
-     (sequence ()
-               (delay 1 (set pc (c-call SI "@cpu@_cpu_rfe" rA))))
-     ()
-)
-
-(dni l-sys "syscall (exception)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.sys ${uimm-16}"
-     (+ OP1_0 OP2_5 OP3_2 OP4_0 rA uimm-16)
-     (sequence()
-              (delay 1 (set pc (c-call SI "@cpu@_except" pc 
-                                       #xc00 uimm-16))))
-     ()
-)
-
-
-; Misc instructions
-
-(dni l-nop "nop"
-     ()
-     "l.nop"
-     (+ OP1_0 OP2_5 OP3_1 OP4_0 rA uimm-16)
-     (nop)
-     ()
-)
-
-(dnmi l-ret "ret" ()
-      "l.ret"
-      (emit l-jr (rA 11) (uimm-16 0))
-)
-
-(dni l-movhi "movhi"
-     (DELAY-SLOT)
-     "l.movhi $rD,$hi16"
-     (+ OP1_0 OP2_6 hi16 rD rA)
-     (set rD (sll WI hi16 (const 16)))
-     ()
-)
-
-
-; System releated instructions
-
-(dni l-mfsr "mfsr"
-     (DELAY-SLOT)
-     "l.mfsr $rD,$rA"
-     (+ OP1_0 OP2_7 rD rA uimm-16)
-     (set rD (c-call SI "@cpu@_cpu_mfsr" rA))
-     ()
-)
-
-(dni l-mtsr "mtsr"
-     (DELAY-SLOT)
-     "l.mtsr $rA,$rB"
-     (+ OP1_1 OP2_0 rA rB rD (f-i16-1 0))
-     (c-call VOID "@cpu@_cpu_mtsr" rA rB)
-     ()
-)
-
-
-
-; Load instructions
-
-(dni l-lw "load word"
-     (DELAY-SLOT)
-     "l.lw $rD,${simm-16}($rA)"
-     (+ OP1_2 OP2_0 rD rA simm-16)
-     (set rD (mem SI (add rA simm-16)))
-     ()
-)
-
-(dni l-lbz "load byte (zero extend)"
-     (DELAY-SLOT)
-     "l.lbz $rD,${simm-16}($rA)"
-     (+ OP1_2 OP2_1 rD rA simm-16)
-     (set rD (zext SI (mem QI (add rA simm-16))))
-     ()
-)
-
-(dni l-lbs "load byte (sign extend)"
-     (DELAY-SLOT)
-     "l.lbs $rD,${simm-16}($rA)"
-     (+ OP1_2 OP2_2 rD rA simm-16)
-     (set rD (ext SI (mem QI (add rA simm-16))))
-     ()
-)
-
-(dni l-lhz "load halfword (zero extend)"
-     (DELAY-SLOT)
-     "l.lhz $rD,${simm-16}($rA)"
-     (+ OP1_2 OP2_3 rD simm-16 rA)
-     (set rD (zext SI (mem HI (add rA simm-16))))
-     ()
-)
-
-(dni l-lhs "load halfword (sign extend)"
-     (DELAY-SLOT)
-     "l.lhs $rD,${simm-16}($rA)"
-     (+ OP1_2 OP2_4 rD rA simm-16)
-     (set rD (ext SI (mem HI (add rA simm-16))))
-     ()
-)
-
-
-; Store instructions
-;
-; We have to use a multi field since the integer is splited over 2 fields
-
-(define-pmacro (store-insn mnemonic op2-op mode-op)
-  (begin
-     (dni (.sym l- mnemonic)
-          (.str "l." mnemonic " imm(reg)/reg")
-          (DELAY-SLOT)
-          (.str "l." mnemonic " ${ui16nc}($rA),$rB")
-          (+ OP1_3 op2-op rB rD ui16nc)
-          (set (mem mode-op (add rA ui16nc)) rB)
-          ()
-     )
-   )
-)
-
-(store-insn sw OP2_5 SI)
-(store-insn sb OP2_6 QI)
-(store-insn sh OP2_7 HI)
-
-
-
-; Shift and rotate instructions
-
-; Reserved fields.
-(dnf f-f-15-8 "nop" (RESERVED) 15 8)
-(dnf f-f-10-3 "nop" (RESERVED) 10 3)
-(dnf f-f-4-1  "nop" (RESERVED) 4  1)
-(dnf f-f-7-3  "nop" (RESERVED) 7  3)
-
-(define-pmacro (shift-insn mnemonic op4-op)
-  (begin
-     (dni (.sym l- mnemonic)
-          (.str "l." mnemonic " reg/reg/reg")
-          ()
-          (.str "l." mnemonic " $rD,$rA,$rB")
-          (+ OP1_3 OP2_8 rD rA rB (f-f-10-3 0) op4-op (f-f-4-1 0) OP7_8)
-          (set rD (mnemonic rA rB))
-          ()
-     )
-     (dni (.sym l- mnemonic "i")
-          (.str "l." mnemonic " reg/reg/imm")
-          ()
-          (.str "l." mnemonic "i $rD,$rA,${uimm-5}")
-          (+ OP1_2 OP2_13 rD rA (f-f-15-8 0) op4-op uimm-5)
-          (set rD (mnemonic rA uimm-5))
-          ()
-     )
-   )
-)
-
-(shift-insn sll OP6_0)
-(shift-insn srl OP6_1)
-(shift-insn sra OP6_2)
-(shift-insn ror OP6_4)
-
-
-; Arethmetic insns
-
-; Reserved fields.
-(dnf f-f-10-7 "nop" (RESERVED) 10 7)
-
-(define-pmacro (ar-insn-u mnemonic op2-op op5-op)
-  (begin
-     (dni (.sym l- mnemonic)
-          (.str "l." mnemonic " reg/reg/reg")
-          ()
-          (.str "l." mnemonic " $rD,$rA,$rB")
-          (+ OP1_3 OP2_8 rD rA rB (f-f-10-7 0) op5-op)
-          (set rD (mnemonic rA rB))
-          ()
-     )
-     (dni (.sym l- mnemonic "i")
-          (.str "l." mnemonic " reg/reg/lo16")
-          ()
-          (.str "l." mnemonic "i $rD,$rA,$lo16")
-          (+ OP1_2 op2-op rD rA lo16)
-          (set rD (mnemonic rA (and lo16 #xffff)))
-          ()
-     )
-   )
-)
-
-(define-pmacro (ar-insn-s mnemonic op2-op op5-op)
-  (begin
-     (dni (.sym l- mnemonic)
-          (.str "l." mnemonic " reg/reg/reg")
-          ()
-          (.str "l." mnemonic " $rD,$rA,$rB")
-          (+ OP1_3 OP2_8 rD rA rB (f-f-10-7 0) op5-op)
-          (set rD (mnemonic rA rB))
-          ()
-     )
-     (dni (.sym l- mnemonic "i")
-          (.str "l." mnemonic " reg/reg/lo16")
-          ()
-          (.str "l." mnemonic "i $rD,$rA,$lo16")
-          (+ OP1_2 op2-op rD rA lo16)
-          (set rD (mnemonic rA lo16))
-          ()
-     )
-   )
-)
-
-(ar-insn-s add OP2_5  OP7_0)
-;;(ar-op-s addc OP2_5  OP7_0)
-(ar-insn-s sub OP2_7  OP7_2)
-(ar-insn-u and OP2_8  OP7_3)
-(ar-insn-u or  OP2_9  OP7_4)
-(ar-insn-u xor OP2_10 OP7_5)
-(ar-insn-u mul OP2_11 OP7_6)
-;;(ar-op-u mac OP2_12 OP7_7)
-
-
-(dni l-div "divide (signed)"
-     (DELAY-SLOT)
-     "l.div $rD,$rA,$rB"
-     (+ OP1_3 OP2_8 rD rA rB (f-f-10-7 0) OP7_9)
-     (if VOID (eq rB (const 0))
-         (c-call VOID "@arch@_cpu_trap" pc (enum SI E_ILLEGAL))
-         (set rD (div rA rB)))
-     ()
-)
-
-(dni l-divu "divide (unsigned)"
-     (DELAY-SLOT)
-     "l.divu $rD,$rA,$rB"
-     (+ OP1_3 OP2_8 rD rA rB (f-f-10-7 0) OP7_10)
-     (if VOID (eq rB (const 0))
-         (c-call VOID "@arch@_cpu_trap" pc (enum SI E_ILLEGAL))
-         (set rD (udiv rA rB))) 
-     ()
-)
-
-
-; Compare instructions
-
-; Reserved fields.
-(dnf f-f-10-11 "nop" (RESERVED) 10 11)
-
-; Register compare (both signed and unsigned)
-(define-pmacro (sf-insn-r op1-op op2-op op3-op op3-op-2 sem-op)
-  (begin
-     (dni (.sym l- "sf" (.sym sem-op "s"))
-          (.str "l." mnemonic " reg/reg")
-          (DELAY-SLOT)
-          (.str "l.sf" (.str sem-op) "s $rA,$rB")
-          (+ op1-op op2-op op3-op-2 rA rB (f-f-10-11 0))
-          (set cbit (sem-op rA rB))
-          ()
-     )
-     (dni (.sym l- "sf" (.sym sem-op "u"))
-          (.str "l." mnemonic " reg/reg")
-          (DELAY-SLOT)
-          (.str "l.sf" (.str sem-op) "u $rA,$rB")
-          (+ op1-op op2-op op3-op rA rB (f-f-10-11 0))
-          (set cbit (sem-op rA rB))
-          ()
-     )
-   )
-)
-
-; Immediate compare (both signed and unsigned)
-(define-pmacro (sf-insn-i op1-op op2-op op3-op op3-op-2 sem-op)
-  (begin
-     (dni (.sym l- "sf" (.sym sem-op "si"))
-          (.str "l." mnemonic "si reg/imm")
-          (DELAY-SLOT)
-          (.str "l.sf" (.str sem-op) "si $rA,${simm-16}")
-          (+ op1-op op2-op op3-op-2 rA simm-16)
-          (set cbit (sem-op rA simm-16))
-          ()
-     )
-     (dni (.sym l- "sf" (.sym sem-op "ui"))
-          (.str "l." mnemonic "ui reg/imm")
-          (DELAY-SLOT)
-          (.str "l.sf" (.str sem-op) "ui $rA,${uimm-16}")
-          (+ op1-op op2-op op3-op rA uimm-16)
-          (set cbit (sem-op rA uimm-16))
-          ()
-     )
-   )
-)
-
-(define-pmacro (sf-insn op5-op sem-op)
-  (begin
-     (dni (.sym l- "sf" sem-op)
-          (.str "l." mnemonic " reg/reg")
-          (DELAY-SLOT)
-          (.str "l.sf" (.str sem-op) " $rA,$rB")
-          (+ OP1_3 OP2_9 op5-op rA rB (f-f-10-11 0))
-          (set cbit (sem-op rA rB))
-          ()
-     )
-     (dni (.sym l- "sf" (.sym sem-op "i"))
-          (.str "l." mnemonic "i reg/imm")
-          (DELAY-SLOT)
-          (.str "l.sf" (.str sem-op) "i $rA,${simm-16}")
-          (+ OP1_2 OP2_14 op5-op rA simm-16)
-          (set cbit (sem-op rA simm-16))
-          ()
-     )
-   )
-)
-
-
-(sf-insn-r OP1_3 OP2_9 OP5_2 OP5_6 gt)
-(sf-insn-r OP1_3 OP2_9 OP5_3 OP5_7 ge)
-(sf-insn-r OP1_3 OP2_9 OP5_4 OP5_8 lt)
-(sf-insn-r OP1_3 OP2_9 OP5_5 OP5_9 le)
-
-(sf-insn-i OP1_2 OP2_14 OP5_2 OP5_6 gt)
-(sf-insn-i OP1_2 OP2_14 OP5_3 OP5_7 ge)
-(sf-insn-i OP1_2 OP2_14 OP5_4 OP5_8 lt)
-(sf-insn-i OP1_2 OP2_14 OP5_5 OP5_9 le)
-
-(sf-insn   OP5_0 eq)
-(sf-insn   OP5_1 ne)
diff -rupN binutils-2.19.1-original/cgen/cpu/openrisc.opc binutils-2.19.1/cgen/cpu/openrisc.opc
--- binutils-2.19.1-original/cgen/cpu/openrisc.opc	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/openrisc.opc	1969-12-31 19:00:00.000000000 -0500
@@ -1,165 +0,0 @@
-
-/* -*- C -*-
-   Copyright 2011 Free Software Foundation, Inc.
-
-   Contributed by Red Hat Inc;
-
-   This file is part of the GNU Binutils.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-/* This file is an addendum to or32.cpu.  Heavy use of C code isn't
-   appropriate in .cpu files, so it resides here.  This especially applies
-   to assembly/disassembly where parsing/printing can be quite involved.
-   Such things aren't really part of the specification of the cpu, per se,
-   so .cpu files provide the general framework and .opc files handle the
-   nitty-gritty details as necessary.
-
-   Each section is delimited with start and end markers.
-
-   <arch>-opc.h additions use: "-- opc.h"
-   <arch>-opc.c additions use: "-- opc.c"
-   <arch>-asm.c additions use: "-- asm.c"
-   <arch>-dis.c additions use: "-- dis.c"
-   <arch>-ibd.h additions use: "-- ibd.h"  */
-
-/* -- opc.h */
-#undef  CGEN_DIS_HASH_SIZE
-#define CGEN_DIS_HASH_SIZE 64
-#undef  CGEN_DIS_HASH
-#define CGEN_DIS_HASH(buffer, value) (((unsigned char *) (buffer))[0] >> 2)
-
-extern long openrisc_sign_extend_16bit (long);
-/* -- */
-
-/* -- opc.c */
-/* -- */
-
-/* -- asm.c */
-
-static const char * MISSING_CLOSING_PARENTHESIS = N_("missing `)'");
-
-#define CGEN_VERBOSE_ASSEMBLER_ERRORS
-
-long
-openrisc_sign_extend_16bit (long value)
-{
-  return ((value & 0xffff) ^ 0x8000) - 0x8000;
-}
-
-/* Handle hi().  */
-
-static const char *
-parse_hi16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
-{
-  const char *errmsg;
-  enum cgen_parse_operand_result result_type;
-  unsigned long ret;
-
-  if (**strp == '#')
-    ++*strp;
-
-  if (strncasecmp (*strp, "hi(", 3) == 0)
-    {
-      bfd_vma value;
-
-      *strp += 3;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_HI16,
-				   & result_type, & value);
-      if (**strp != ')')
-        return MISSING_CLOSING_PARENTHESIS;
-
-      ++*strp;
-      if (errmsg == NULL
-          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
-        value >>= 16;
-      ret = value;
-    }
-  else
-    {
-      if (**strp == '-')
-	{
-	  long value;
-
-	  errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
-	  ret = value;
-	}
-      else
-	{
-	  unsigned long value;
-
-	  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &value);
-	  ret = value;
-	}
-    }
-
-  *valuep = ((ret & 0xffff) ^ 0x8000) - 0x8000;
-  return errmsg;
-}
-
-/* Handle lo().  */
-
-static const char *
-parse_lo16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
-{
-  const char *errmsg;
-  enum cgen_parse_operand_result result_type;
-  unsigned long ret;
-
-  if (**strp == '#')
-    ++*strp;
-
-  if (strncasecmp (*strp, "lo(", 3) == 0)
-    {
-      bfd_vma value;
-
-      *strp += 3;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LO16,
-				   & result_type, & value);
-      if (**strp != ')')
-        return MISSING_CLOSING_PARENTHESIS;
-
-      ++*strp;
-      ret = value;
-    }
-  else
-    {
-      if (**strp == '-')
-	{
-	  long value;
-
-	  errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
-	  ret = value;
-	}
-      else
-	{
-	  unsigned long value;
-
-	  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &value);
-	  ret = value;
-	}
-    }
-
-  *valuep = ((ret & 0xffff) ^ 0x8000) - 0x8000;
-  return errmsg;
-}
-
-/* -- */
-
-/* -- ibd.h */
-extern long openrisc_sign_extend_16bit (long);
-
-/* -- */
diff -rupN binutils-2.19.1-original/cgen/cpu/simplify.inc binutils-2.19.1/cgen/cpu/simplify.inc
--- binutils-2.19.1-original/cgen/cpu/simplify.inc	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/simplify.inc	1969-12-31 19:00:00.000000000 -0500
@@ -1,216 +0,0 @@
-; Collection of macros, for GNU Binutils .cpu files. -*- Scheme -*-
-;
-; Copyright 2000, 2007 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc.
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-; Enums.
-
-; Define a normal enum without using name/value pairs.
-; This is currently the same as define-full-enum but it needn't remain
-; that way (it's define-full-enum that would change).
-
-(define-pmacro (define-normal-enum name comment attrs prefix vals)
-  "\
-Define a normal enum, fixed number of arguments.
-"
-  (define-full-enum name comment attrs prefix vals)
-)
-
-; Define a normal insn enum.
-
-(define-pmacro (define-normal-insn-enum name comment attrs prefix fld vals)
-  "\
-Define a normal instruction opcode enum.
-"
-  (define-full-insn-enum name comment attrs prefix fld vals)
-)
-
-; Instruction fields.
-
-; Normally, fields are unsigned have no encode/decode needs.
-
-(define-pmacro (define-normal-ifield name comment attrs start length)
-  "Define a normal instruction field.\n"
-  (define-full-ifield name comment attrs start length UINT #f #f)
-)
-
-; For those who don't like typing.
-
-(define-pmacro df
-  "Shorthand form of define-full-ifield.\n"
-  define-full-ifield
-)
-(define-pmacro dnf
-  "Shorthand form of define-normal-ifield.\n"
-  define-normal-ifield
-)
-
-; Define a normal multi-ifield.
-; FIXME: The define-normal version for ifields doesn't include the mode.
-
-(define-pmacro (define-normal-multi-ifield name comment attrs
-		 mode subflds insert extract)
-  "Define a normal multi-part instruction field.\n"
-  (define-full-multi-ifield name comment attrs mode subflds insert extract)
-)
-
-; For those who don't like typing.
-
-(define-pmacro dnmf
-  "Shorthand form of define-normal-multi-ifield.\n"
-  define-normal-multi-ifield
-)
-
-; Simple multi-ifields: mode is UINT, default insert/extract support.
-
-(define-pmacro (dsmf name comment attrs subflds)
-  "Define a simple multi-part instruction field.\n"
-  (define-full-multi-ifield name comment attrs UINT subflds #f #f)
-)
-
-; Hardware.
-
-; Simpler version for most hardware elements.
-; Allow special assembler support specification but no semantic-name or
-; get/set specs.
-
-(define-pmacro (define-normal-hardware name comment attrs type
-		 indices values handlers)
-  "\
-Define a normal hardware element.
-"
-  (define-full-hardware name comment attrs name type
-    indices values handlers () () ())
-)
-
-; For those who don't like typing.
-
-(define-pmacro dnh
-  "Shorthand form of define-normal-hardware.\n"
-  define-normal-hardware
-)
-
-; Simpler version of dnh that leaves out the indices, values, handlers,
-; get, set, and layout specs.
-; This is useful for 1 bit registers.
-; ??? While dsh and dnh aren't that distinguishable when perusing a .cpu file,
-; they both take a fixed number of positional arguments, and dsh is a proper
-; subset of dnh with all arguments in the same positions, so methinks things
-; are ok.
-
-(define-pmacro (define-simple-hardware name comment attrs type)
-  "\
-Define a simple hardware element (usually a scalar register).
-"
-  (define-full-hardware name comment attrs name type () () () () () ())
-)
-
-(define-pmacro dsh
-  "Shorthand form of define-simple-hardware.\n"
-  define-simple-hardware
-)
-
-; Operands.
-
-(define-pmacro (define-normal-operand name comment attrs type index)
-  "Define a normal operand.\n"
-  (define-full-operand name comment attrs type DFLT index () () ())
-)
-
-; For those who don't like typing.
-; FIXME: dno?
-
-(define-pmacro dnop
-  "Shorthand form of define-normal-operand.\n"
-  define-normal-operand
-)
-
-(define-pmacro (dndo x-name x-mode x-args
-		     x-syntax x-base-ifield x-encoding x-ifield-assertion
-		     x-getter x-setter)
-  "Define a normal derived operand."
-  (define-derived-operand
-    (name x-name)
-    (mode x-mode)
-    (args x-args)
-    (syntax x-syntax)
-    (base-ifield x-base-ifield)
-    (encoding x-encoding)
-    (ifield-assertion x-ifield-assertion)
-    (getter x-getter)
-    (setter x-setter)
-    )
-)
-
-; Instructions.
-
-; Define an instruction object, normal version.
-; At present all fields must be specified.
-; Fields ifield-assertion is absent.
-
-(define-pmacro (define-normal-insn name comment attrs syntax fmt semantics timing)
-  "Define a normal instruction.\n"
-  (define-full-insn name comment attrs syntax fmt () semantics timing)
-)
-
-; To reduce the amount of typing.
-; Note that this is the same name as the D'ni in MYST.  Oooohhhh.....
-; this must be the right way to go. :-)
-
-(define-pmacro dni
-  "Shorthand form of define-normal-insn.\n"
-  define-normal-insn
-)
-
-; Macro instructions.
-
-; Define a macro-insn object, normal version.
-; This only supports expanding to one real insn.
-
-(define-pmacro (define-normal-macro-insn name comment attrs syntax expansion)
-  "Define a normal macro instruction.\n"
-  (define-full-minsn name comment attrs syntax expansion)
-)
-
-; To reduce the amount of typing.
-
-(define-pmacro dnmi
-  "Shorthand form of define-normal-macro-insn.\n"
-  define-normal-macro-insn
-)
-
-; Modes.
-; ??? Not currently available for use.
-;
-; Define Normal Mode
-;
-;(define-pmacro (define-normal-mode name comment attrs bits bytes
-;		 non-mode-c-type printf-type sem-mode ptr-to host?)
-;  "Define a normal mode.\n"
-;  (define-full-mode name comment attrs bits bytes
-;    non-mode-c-type printf-type sem-mode ptr-to host?)
-;)
-;
-; For those who don't like typing.
-;(define-pmacro dnm
-;  "Shorthand form of define-normal-mode.\n"
-;  define-normal-mode
-;)
diff -rupN binutils-2.19.1-original/cgen/cpu/xc16x.cpu binutils-2.19.1/cgen/cpu/xc16x.cpu
--- binutils-2.19.1-original/cgen/cpu/xc16x.cpu	2007-07-05 05:49:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/xc16x.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,3129 +0,0 @@
-; Infineon XC16X CPU description.  -*- Scheme -*-
-;
-; Copyright 2006, 2007 Free Software Foundation, Inc.
-;
-; Contributed by KPIT Cummins Infosystems Ltd.; developed under contract 
-; from Infineon Systems, GMBH , Germany.
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
-; 02110-1301, USA.
-
-(include "simplify.inc")
-
-; define-arch appears first
-
-(define-arch
-  (name xc16x) ; name of cpu family
-  (comment "Infineon XC16X")
-  (default-alignment aligned)
-  (insn-lsb0? #t)		
-  (machs xc16x)
-  (isas xc16x)
-)
-
-; Attributes.   
-; An attribute to describe which pipeline an insn runs in generally OS.
-(define-attr
-  (for insn)
-  (type enum)
-  (name PIPE)
-  (comment "parallel execution pipeline selection")
-  (values NONE OS)
-)
-
-; Instruction set parameters.
-
-(define-isa
-  (name xc16x)
-  (default-insn-bitsize 32)
-  (base-insn-bitsize 32)
-  (default-insn-word-bitsize 16)
-  (decode-assist (15 14 13 12))
-  ; The XC16X fetches 1 insn at a time.
-  (liw-insns 1)
-  (parallel-insns 1)
-)
-
-; Cpu family definitions.
-
-(define-cpu
-  ; cpu names must be distinct from the architecture name and machine names.
-  ; The "b" suffix stands for "base" and is the convention.
-  ; The "f" suffix stands for "family" and is the convention.
-  (name xc16xbf)
-  (comment "Infineon XC16X base family")
-  (endian little)
-  (insn-chunk-bitsize 32)
-  (word-bitsize 16)
-  (parallel-insns 1)
-)
-
-(define-mach
-  (name xc16x)
-  (comment "Infineon XC16X cpu")
-  (cpu xc16xbf)
-)
-
-; Model descriptions.
-
-(define-model
-  (name xc16x) (comment "XC16X") (attrs)
-  (mach xc16x)
-  
-  (pipeline p-mem "" () ((prefetch) (fetch) (decode) (address) (memory) (execute) (writeback)))
-  
-    ; `state' is a list of variables for recording model state
-    (state
-     ; bit mask of h-gr registers, =1 means value being loaded from memory
-     (h-gr UINT)
-    )
-  
-  (unit u-exec "Execution Unit" ()
-  	1 1 ; issue done
-  	() ; state
-  	((dr INT -1) (sr INT -1)) ; inputs
-  	((dr INT -1)) ; outputs
-  	() ; profile action (default)
-	)
-  (unit u-cmp "Compare Unit" ()
-  	1 1 ; issue done
-  	() ; state
-  	((src1 INT -1) (src2 INT -1)) ; inputs
-  	() ; outputs
-  	() ; profile action (default)
-	)
-  (unit u-cti "Jump & Call Unit" ()
-  	1 1 ; issue done
-  	() ; state
-  	((condbit) (sr INT -1)) ; inputs
-  	((pc)) ; outputs
-  	() ; profile action (default)
-	)
-  (unit u-mov "Data Movement Unit" ()
-  	1 1 ; issue done
-  	() ;state
-  	((dr INT -1) (sr INT -1)) ; inputs
-  	((dr INT -1)) ; output
-  	() ; profile action (default)
-  	)
- ) 
- 
-; Instruction fields.
-;
-; Attributes:
-; PCREL-ADDR: pc relative value (for reloc and disassembly purposes)
-; ABS-ADDR: absolute address (for reloc and disassembly purposes)
-; RELOC: there is a relocation associated with this field (experiment)
-
-(define-attr
-  (for ifield operand)
-  (type boolean)
-  (name RELOC)
-  (comment "there is a reloc associated with this field (experiment)")
-)
-
-(dnf f-op1       "op1"                 () 7  4)
-(dnf f-op2       "op2"                 () 3  4)
-(dnf f-condcode  "condcode"            () 7  4)  ;condition code required in other jmps and calls
-(dnf f-icondcode "indrct condcode"     () 15 4)  ;condition code required in other jmpi and calli
-(dnf f-rcond     "relative-cond"       () 7  4)  ;condition code required in JMPR 
-(dnf f-qcond     "qbit"                () 7  4)  ;used in enum of bset/bclear macro
-(dnf f-extccode  "extended condcode"   () 15 5)  ;condition code required in other jmpa and calla
-(dnf f-r0	 "r0"		       () 9  2)  ;required where 2 bit register used(only R0-R3)
-(dnf f-r1        "r1"                  () 15 4)
-(dnf f-r2        "r2"                  () 11 4)
-(dnf f-r3        "r3"                  () 12 4)
-(dnf f-r4        "r4"                  () 11 4)
-(dnf f-uimm2     "uimm2"               () 13 2)  ;used for immediate data,eg in ADD,MOV insns
-(dnf f-uimm3     "uimm3"               () 10 3)  ;used for immediate data,eg in ADD,SUB insns
-(dnf f-uimm4     "uimm4"               () 15 4)  ;used for immediate data,eg in MOV insns
-(dnf f-uimm7     "uimm7"               (PCREL-ADDR RELOC) 15 7)	;used in TRAP
-(dnf f-uimm8     "uimm8"               () 23 8)  ;used in immediate byte data,eg in ADDB,MOVB insns
-(dnf f-uimm16    "uimm16"              () 31 16) ;used for immediate word data
-(dnf f-memory    "memory"              () 31 16) ; used for memory operands 
-(dnf f-memgr8    "memory" 	       () 31 16) ; memory location of gr
-(dnf f-rel8      "rel8"                (PCREL-ADDR RELOC) 15 8)	;used in JMPR,CALLR
-(dnf f-relhi8    "relhi8"              (PCREL-ADDR RELOC) 23 8)	;used in JB,JBC,JNB,JNBS
-(dnf f-reg8      "reg8"                () 15 8)	;required where 8bit gp register used
-(dnf f-regmem8   "regmem8"             () 15 8) ;required where 8bit register used
-(dnf f-regoff8   "regoff8"             () 15 8)	;required for offset calc
-(dnf f-reghi8    "reghi8"              () 23 8)	;required where 8bit register number used
-(dnf f-regb8     "regb8"               () 15 8)	;required for byte registers RL0,RH0, till RL8,RH8
-(dnf f-seg8      "seg8"                () 15 8) ;used as segment number in JMPS,CALLS
-(dnf f-segnum8   "segnum8"             () 23 8) ;used in EXTS,EXTSR        
-(dnf f-mask8     "mask8"               () 23 8) ;used as mask in BFLDH,BFLDL insns
-(dnf f-pagenum   "page num"            () 25 10);used in EXTP,EXTPR
-(dnf f-datahi8   "datahi8"             () 31 8) ;used for filling with const data
-(dnf f-data8     "data8"               () 23 8) ;used for filling with const data
-(dnf f-offset16  "address offset16"    (ABS-ADDR RELOC) 31 16) ;used in JMPS,JMPA,CALLA,CALLS
-(dnf f-op-bit1   "gap of 1 bit"        () 11 1)	;used for filling with const data
-(dnf f-op-bit2   "gap of 2 bits"       () 11 2)	;used for filling with const data
-(dnf f-op-bit4   "gap of 4 bits"       () 11 4) ;used for filling with const data
-(dnf f-op-bit3   "gap of 3 bits"       () 10 3) ;used in CALLA, JMPA
-(dnf f-op-2bit   "gap of 2 bits"       () 10 2) ;used in CALLA
-(dnf f-op-bitone "gap of 1 bit "       () 10 1) ;used in JMPA
-(dnf f-op-onebit "gap of 1 bit "       () 9  1) ;used in JMPA
-(dnf f-op-1bit   "gap of 1 bit "       () 8  1) ;used in JMPA, CALLA
-(dnf f-op-lbit4  "gap of 4 bits"       () 15 4) ;used for filling with const data
-(dnf f-op-lbit2  "gap of 2 bits"       () 15 2) ;used for filling with const data
-(dnf f-op-bit8	 "gap of 8 bits"       () 31 8) ;used for filling with const data
-(dnf f-op-bit16	 "gap of 16 bits"      () 31 16) ;used for filling with const data
-(dnf f-qbit      "qbit"                () 7  4) ;used in bit field of bset/bclear
-(dnf f-qlobit    "qlobit"              () 31 4) ;used for filling with const data
-(dnf f-qhibit    "qhibit"              () 27 4) ;used for filling with const data
-(dnf f-qlobit2   "qlobit2"             () 27 2) ;used for filling with const data
-(dnf f-pof    "upof16"                 () 31 16) ; used for memory operands 
-
-; Enums.
-; insn-op1: bits 0-3
-(define-normal-insn-enum insn-op1 "insn format enums" () OP1_ f-op1
-  ("0" "1" "2" "3" "4" "5" "6" "7"
-   "8" "9" "10" "11" "12" "13" "14" "15")
-)
-
-; insn-op2: bits 4-7
-(define-normal-insn-enum insn-op2 "op2 enums" () OP2_ f-op2
-  ("0" "1" "2" "3" "4" "5" "6" "7"
-   "8" "9" "10" "11" "12" "13" "14" "15")
-)
-
-;/*for bclr/bset*/
-; insn-rcond: bits 0-3
-(define-normal-insn-enum insn-qcond "bit set/clear enums" () QBIT_ f-qcond
-  (("0" 0) ("1" 1) ("2" 2) ("3" 3) ("4" 4) ("5" 5) ("6" 6) ("7" 7) ("8" 8) ("9" 9) ("10" 10) 
-   ("11" 11) ("12" 12) ("13" 13) ("14" 14) ("15" 15))
-)
-;/************/
-; insn-rcond: bits 0-3
-(define-normal-insn-enum insn-rcond "relative jump condition code op2 enums" () COND_ f-rcond
-  (("UC" 0) ("NET" 1) ("Z" 2) ("NE_NZ" 3) ("V" 4)  ("NV" 5) ("N" 6) ("NN" 7)
-   ("C" 8) ("NC" 9) ("SGT" 10) ("SLE" 11) ("SLT" 12) ("SGE" 13) ("UGT" 14) ("ULE" 15)
-   ("EQ" 2) ("NE" 3) ("ULT" 8) ("UGE" 9))
-)
-
-
-
-; Hardware pieces.
-; These entries list the elements of the raw hardware.
-; They're also used to provide tables and other elements of the assembly
-; language.
-
-(dnh h-pc "program counter" (PC) (pc) () () ())
-
-(define-keyword
-  (name gr-names)
-  (print-name h-gr)
-  (prefix "")
-  (values (r0 0) (r1 1) (r2 2) (r3 3) (r4 4) (r5 5) (r6 6) (r7 7)
-	  (r8 8) (r9 9) (r10 10) (r11 11) (r12 12) (r13 13) (r14 14) (r15 15))
-
-)
-(define-hardware
-  (name h-gr)
-  (comment "general registers")
-  (attrs PROFILE CACHE-ADDR)
-  (type register HI (16))
-  (indices extern-keyword gr-names)
-)
-
-(define-keyword
-  (name ext-names)
-  (print-name h-ext)
-  (prefix "")
-  (values (0x1 0) (0x2 1) (0x3 2) (0x4 3)
-          ("1" 0) ("2" 1) ("3" 2) ("4" 3))
-
-)
-
-(define-hardware
-  (name h-ext)
-  (comment "ext values")
-  (attrs PROFILE CACHE-ADDR)
-  (type register HI (8))
-  (indices extern-keyword ext-names)
-)
-
-(define-keyword
-  (name psw-names)
-  (print-name h-psw)
-  (prefix "")
-  (values ("IEN" 136) ("r0.11" 240) ("r1.11" 241) ("r2.11" 242) ("r3.11" 243) ("r4.11" 244)
-                      ("r5.11" 245) ("r6.11" 246) ("r7.11" 247) ("r8.11" 248)
-                      ("r9.11" 249) ("r10.11" 250) ("r11.11" 251) ("r12.11" 252)
-                      ("r13.11" 253) ("r14.11" 254) ("r15.11" 255))
-)
-
-(define-hardware
-  (name h-psw)
-  (comment "ext values")
-  (attrs PROFILE CACHE-ADDR)
-  (type register HI (1))
-  (indices extern-keyword psw-names)
-)
-
-(define-keyword
-  (name grb-names)
-  (print-name h-grb)
-  (prefix "")
-  (values (rl0 0) (rh0 1) (rl1 2) (rh1 3) (rl2 4) (rh2 5) (rl3 6) (rh3 7) 
-          (rl4 8) (rh4 9) (rl5 10) (rh5 11) (rl6 12) (rh6 13) (rl7 14) (rh7 15))
-)
-
-(define-hardware
-  (name h-grb)
-  (comment "general registers")
-  (attrs PROFILE CACHE-ADDR)
-  (type register QI (16))
-  (indices extern-keyword grb-names)
-)
-
-(define-keyword
-  (name conditioncode-names)
-  (print-name h-cc)
-  (prefix "")
-  (values (cc_UC 0) (cc_NET 1) (cc_Z 2) (cc_EQ 2) (cc_NZ 3) (cc_NE 3) (cc_V 4) (cc_NV 5) (cc_N 6)  (cc_NN 7) (cc_ULT 8)  (cc_UGE 9) 
-	  (cc_C 8) (cc_NC 9) (cc_SGT 10) (cc_SLE 11) (cc_SLT 12) (cc_SGE 13) (cc_UGT 14) 
-          (cc_ULE 15))
-)
-(define-hardware
-  (name h-cc)
-  (comment "condition codes")
-  (attrs PROFILE CACHE-ADDR)
-  (type register QI (16))
-  (indices extern-keyword conditioncode-names)
-)
-
-(define-keyword
-  (name extconditioncode-names)
-  (print-name h-ecc)
-  (prefix "")
-  (values(cc_UC 0) (cc_NET 2) (cc_Z 4) (cc_EQ 4) (cc_NZ 6) (cc_NE 6) (cc_V 8) (cc_NV 10) (cc_N 12)  (cc_NN 14) (cc_ULT 16)  (cc_UGE 18) (cc_C 16) (cc_NC 18) (cc_SGT 20) 
-         (cc_SLE 22) (cc_SLT 24) (cc_SGE 26) (cc_UGT 28) (cc_ULE 30) (cc_nusr0 1) 
-         (cc_nusr1 3) (cc_usr0 5) (cc_usr1 7))
-)
-(define-hardware
-  (name h-ecc)
-  (comment "extended condition codes")
-  (attrs PROFILE CACHE-ADDR)
-  (type register QI (4))
-  (indices extern-keyword extconditioncode-names)
-)
-
-(define-keyword
-  (name grb8-names)
-  (print-name h-grb8)
-  (prefix "")
-  (values (dpp0 0)  (dpp1 1)  (dpp2 2)  (dpp3 3)
-	  (psw 136)   (cp 8)    (mdl 7)   (mdh  6)
-	  (mdc 135)   (sp 9)    (csp 4)  (vecseg 137)
-          (stkov 10)  (stkun 11) (cpucon1 12) (cpucon2 13)
-	  (zeros 142)  (ones 143) (spseg 134) (tfr 214)
-	  (rl0 240) (rh0 241) (rl1 242) (rh1 243) (rl2 244) (rh2 245) (rl3 246) (rh3 247)
-	  (rl4 248) (rh4 249) (rl5 250) (rh5 251) (rl6 252) (rh6 253) (rl7 254) (rh7 255))
-)
-
-(define-hardware
-  (name h-grb8)
-  (comment "general byte registers")
-  (attrs PROFILE CACHE-ADDR)
-  (type register QI (36))
-  (indices extern-keyword grb8-names)
-)
-
-(define-keyword
-  (name r8-names)
-  (print-name h-r8)
-  (prefix "")
-  (values (dpp0 0)  (dpp1 1)  (dpp2 2)  (dpp3 3)
-	  (psw 136)   (cp 8)    (mdl 7)   (mdh  6)
-	  (mdc 135)   (sp 9)    (csp 4)  (vecseg 137)
-          (stkov 10)  (stkun 11) (cpucon1 12) (cpucon2 13)
-	  (zeros 142)  (ones 143) (spseg 134) (tfr 214)
-	  (r0 240) (r1 241) (r2 242) (r3 243) (r4 244) (r5 245) (r6 246) (r7 247)
-	  (r8 248) (r9 249) (r10 250) (r11 251) (r12 252) (r13 253) (r14 254) (r15 255))
-)
-
-(define-hardware
-  (name h-r8)
-  (comment "registers")
-  (attrs PROFILE CACHE-ADDR)
-  (type register HI (36))
-  (indices extern-keyword r8-names)
-)
-
-(define-keyword
-  (name regmem8-names)
-  (print-name h-regmem8)
-  (prefix "")
-  (values (dpp0 0)  (dpp1 1)  (dpp2 2)  (dpp3 3)
-	  (psw 136)   (cp 8)    (mdl 7)   (mdh  6)
-	  (mdc 135)   (sp 9)    (csp 4)  (vecseg 137)
-          (stkov 10)  (stkun 11) (cpucon1 12) (cpucon2 13)
-	  (zeros 142)  (ones 143) (spseg 134) (tfr 214)
-	  (r0 240) (r1 241) (r2 242) (r3 243) (r4 244) (r5 245) (r6 246) (r7 247)
-	  (r8 248) (r9 249) (r10 250) (r11 251) (r12 252) (r13 253) (r14 254) (r15 255))
-)
-
-(define-hardware
-  (name h-regmem8)
-  (comment "registers")
-  (attrs )
-  (type register HI (16))
-  (indices extern-keyword regmem8-names)
-)
-
-(define-keyword
-  (name regdiv8-names)
-  (print-name h-regdiv8)
-  (prefix "")
-  (values (r0 0) (r1 17) (r2 34) (r3 51) (r4 68) (r5 85) (r6 102) (r7 119)
-	  (r8 136) (r9 153) (r10 170) (r11 187) (r12 204) (r13 221) (r14 238) (r15 255))
-)
-
-(define-hardware
-  (name h-regdiv8)
-  (comment "division insn registers")
-  (attrs PROFILE CACHE-ADDR)
-  (type register HI (16))
-  (indices extern-keyword regdiv8-names)
-)
-
-(define-keyword
-  (name reg0-name)
-  (print-name h-reg0)
-  (prefix "")
-  (values (0x1 1) (0x2 2) (0x3 3) (0x4 4) (0x5 5) (0x6 6) (0x7 7) (0x8 8) (0x9 9) (0xa 10) (0xb 11) 
-          (0xc 12) (0xd 13) (0xe 14) (0xf 15)
-          ("1" 1) ("2" 2) ("3" 3) ("4" 4) ("5" 5) ("6" 6) ("7" 7) ("8" 8) ("9" 9) ("10" 10) ("11" 11) 
-          ("12" 12) ("13" 13) ("14" 14) ("15" 15))
-)
-
-(define-hardware
-  (name h-r0)
-  (comment "for 4-bit data excuding 0")
-  (attrs PROFILE CACHE-ADDR)
-  (type register HI (30))
-  (indices extern-keyword reg0-name)
-)
-
-(define-keyword
-  (name reg0-name1)
-  (print-name h-reg01)
-  (prefix "")
-  (values (0x1 1) (0x2 2) (0x3 3) (0x4 4) (0x5 5) (0x6 6) (0x7 7)
-          ("1" 1) ("2" 2) ("3" 3) ("4" 4) ("5" 5) ("6" 6) ("7" 7))
-)
-
-(define-hardware
-  (name h-r01)
-  (comment "for 4-bit data excuding 0")
-  (attrs PROFILE CACHE-ADDR)
-  (type register HI (14))
-  (indices extern-keyword reg0-name1)
-)
-
-(define-keyword
-  (name regbmem8-names)
-  (print-name h-regbmem8)
-  (prefix "")
-  (values (dpp0 0)  (dpp1 1)  (dpp2 2)  (dpp3 3)
-	  (psw 136)   (cp 8)    (mdl 7)   (mdh  6)
-	  (mdc 135)   (sp 9)    (csp 4)  (vecseg 137)
-          (stkov 10)  (stkun 11) (cpucon1 12) (cpucon2 13)
-	  (zeros 142)  (ones 143) (spseg 134) (tfr 214)
-	  (rl0 240) (rh0 241) (rl1 242) (rh1 243) (rl2 244) (rh2 245) (rl3 246) (rh3 247)
-	  (rl4 248) (rh4 249) (rl5 250) (rh5 251) (rl6 252) (rh6 253) (rl7 254) (rh7 255))
-)
-
-(define-hardware
-  (name h-regbmem8)
-  (comment "registers")
-  (attrs PROFILE CACHE-ADDR)
-  (type register HI (36))
-  (indices extern-keyword regbmem8-names)
-)
-
-(define-keyword
-  (name memgr8-names)
-  (print-name h-memgr8)
-  (prefix "")
-  (values (dpp0 65024)  (dpp1 65026)  (dpp2 65028)  (dpp3 65030)
-	  (psw 65296)   (cp 65040)    (mdl 65038)   (mdh  65036)
-	  (mdc 65294)   (sp 65042)    (csp 65032)  (vecseg 65298)
-          (stkov 65044)  (stkun 65046) (cpucon1 65048) (cpucon2 65050)
-	  (zeros 65308)  (ones 65310) (spseg 65292) (tfr 65452) )
-)
-
-(define-hardware
-  (name h-memgr8)
-  (comment "memory location of registers")
-  (attrs )
-  (type register HI (20))
-  (indices extern-keyword memgr8-names)
-)
-
-(dsh h-cond "condition bit" () (register BI))   ;any bit from PSW while comparison
-; This bit is part of the PSW register 
-(dsh h-cbit  "carry bit"		() (register BI))
-
-(dsh h-sgtdis "segmentation enable bit" () (register BI)) ;0 means segmentation enabled
-
-;Instruction operands 
-; -- layer between the assembler and the raw hardware description 
-; -- the main means of manipulating instruction fields in the semantic code 
-
-; XC16X specific operand attributes:
-
-(define-attr
-  (for operand)
-  (type boolean)
-  (name HASH-PREFIX)
-  (comment "immediates have an optional '#' prefix")
-)
-
-(define-attr
-  (for operand)
-  (type boolean)
-  (name DOT-PREFIX)
-  (comment "bit addr have an optional '.' prefix")
-)
-
-(define-attr
-  (for operand)
-  (type boolean)
-  (name POF-PREFIX)
-  (comment "page offset ")
-)
-
-(define-attr
-  (for operand)
-  (type boolean)
-  (name PAG-PREFIX)
-  (comment "page ")
-)
-
-(define-attr
-  (for operand)
-  (type boolean)
-  (name SOF-PREFIX)
-  (comment "segment offset selection")
-)
-
-(define-attr
-  (for operand)
-  (type boolean)
-  (name SEG-PREFIX)
-  (comment "segment")
-)
-
-(dnop sr      "source register"              () h-gr    f-r2)
-(dnop dr      "destination register"         () h-gr    f-r1)
-(dnop dri     "destination register"         () h-gr    f-r4)
-(dnop srb     "source register"              () h-grb   f-r2)
-(dnop drb     "destination register"         () h-grb   f-r1)
-(dnop sr2     "2 bit source register"	     () h-gr    f-r0)
-(dnop src1    "source register 1"            () h-gr   f-r1)
-(dnop src2    "source register 2"            () h-gr   f-r2)
-(dnop srdiv   "source register 2"            () h-regdiv8   f-reg8)
-(dnop RegNam  "PSW bits"                     () h-psw f-reg8) 
-(dnop uimm2   "2 bit unsigned number"        (HASH-PREFIX) h-ext f-uimm2) 
-(dnop uimm3   "3 bit unsigned number"        (HASH-PREFIX) h-r01 f-uimm3)
-(dnop uimm4   "4 bit unsigned number"        (HASH-PREFIX) h-uint f-uimm4)
-(dnop uimm7   "7 bit trap number"            (HASH-PREFIX) h-uint f-uimm7)
-(dnop uimm8   "8 bit unsigned immediate"     (HASH-PREFIX) h-uint f-uimm8)
-(dnop uimm16  "16 bit unsigned immediate"    (HASH-PREFIX) h-uint f-uimm16)
-(dnop upof16  "16 bit unsigned immediate"    (POF-PREFIX) h-addr f-memory)
-(dnop reg8    "8 bit word register number"   () h-r8 f-reg8)
-(dnop regmem8 "8 bit word register number"   () h-regmem8 f-regmem8)
-(dnop regbmem8 "8 bit byte register number"  () h-regbmem8 f-regmem8)
-(dnop regoff8 "8 bit word register number"   () h-r8 f-regoff8)
-(dnop reghi8  "8 bit word register number"   () h-r8 f-reghi8)
-(dnop regb8   "8 bit byte register number"   () h-grb8 f-regb8)
-(dnop genreg  "8 bit word register number"   () h-r8 f-regb8)
-(dnop seg     "8 bit segment number"         () h-uint f-seg8)
-(dnop seghi8  "8 bit hi segment number"      () h-uint f-segnum8)
-(dnop caddr   "16 bit address offset"        () h-addr f-offset16)
-(dnop rel     "8 bit signed relative offset" () h-sint f-rel8)
-(dnop relhi   "hi 8 bit signed relative offset" () h-sint f-relhi8)	
-(dnop condbit "condition bit"                (SEM-ONLY) h-cond f-nil)
-(dnop bit1    "gap of 1 bit"    	     () h-uint f-op-bit1)
-(dnop bit2    "gap of 2 bits"	             () h-uint f-op-bit2)
-(dnop bit4    "gap of 4 bits"                () h-uint f-op-bit4)
-(dnop lbit4   "gap of 4 bits"                () h-uint f-op-lbit4)
-(dnop lbit2   "gap of 2 bits"                () h-uint f-op-lbit2)
-(dnop bit8    "gap of 8 bits"	             () h-uint f-op-bit8)
-(dnop u4      "gap of 4 bits"	             () h-r0   f-uimm4)
-(dnop bitone  "field of 1 bit"	             () h-uint f-op-onebit)
-(dnop bit01   "field of 1 bit"	             () h-uint f-op-1bit)
-(dnop cond    "condition code" 	             () h-cc   f-condcode)
-(dnop icond   "indirect condition code"      () h-cc   f-icondcode)
-(dnop extcond "extended condition code"      () h-ecc  f-extccode)
-(dnop memory  "16 bit memory" 		     () h-addr f-memory)
-(dnop memgr8  "16 bit memory"		     () h-memgr8 f-memgr8)
-(dnop cbit    "carry bit"                    (SEM-ONLY) h-cbit  f-nil)
-(dnop qbit    "bit addr"               	     (DOT-PREFIX) h-uint  f-qbit)
-(dnop qlobit  "bit addr"                     (DOT-PREFIX) h-uint  f-qlobit)
-(dnop qhibit  "bit addr"                     (DOT-PREFIX) h-uint  f-qhibit)
-(dnop mask8   "8 bit mask"     		     (HASH-PREFIX) h-uint f-mask8)
-(dnop masklo8 "8 bit mask"     		     (HASH-PREFIX) h-uint f-datahi8)
-(dnop pagenum "10 bit page number"     	     (HASH-PREFIX) h-uint f-pagenum)
-(dnop data8   "8 bit data"     		     (HASH-PREFIX) h-uint f-data8)
-(dnop datahi8 "8 bit data"     	             (HASH-PREFIX) h-uint f-datahi8)
-(dnop sgtdisbit "segmentation enable bit"    (SEM-ONLY) h-sgtdis f-nil)
-(dnop upag16  "16 bit unsigned immediate"    (PAG-PREFIX) h-uint f-uimm16)
-(dnop useg8   "8 bit segment "    	     (SEG-PREFIX) h-uint f-seg8)
-(dnop useg16  "16 bit address offset"        (SEG-PREFIX) h-uint f-offset16)
-(dnop usof16  "16 bit address offset"        (SOF-PREFIX) h-uint f-offset16)
-
-; define hash operator
-(define-operand (name hash) (comment "# prefix") (attrs)
-  (type h-sint)  
-  (index f-nil)
-  (handlers (parse "hash") (print "hash"))
-)
-
-; define dot operator
-(define-operand (name dot) (comment ". prefix") (attrs)
-  (type h-sint)  
-  (index f-nil)
-  (handlers (parse "dot") (print "dot"))
-)
-
-; define pof operator
-(define-operand (name pof) (comment "pof: prefix") (attrs)
-  (type h-sint)  
-  (index f-nil)
-  (handlers (parse "pof") (print "pof"))
-)
-
-; define pag operator
-(define-operand (name pag) (comment "pag: prefix") (attrs)
-  (type h-sint)
-  (index f-nil)
-  (handlers (parse "pag") (print "pag"))
-)
-
-; define sof operator
-(define-operand (name sof) (comment "sof: prefix") (attrs)
-  (type h-sint)  
-  (index f-nil)
-  (handlers (parse "sof") (print "sof"))
-)
-
-; define seg operator
-(define-operand (name segm) (comment "seg: prefix") (attrs)
-  (type h-sint)
-  (index f-nil)
-  (handlers (parse "seg") (print "seg"))
-)
-
-; IDOC attribute for instruction documentation.
-(define-attr
-  (for insn)
-  (type enum)
-  (name IDOC)
-  (comment "insn kind for documentation")
-  (attrs META)
-  (values
-   (MOVE - () "Data Movement")
-   (ALU  - () "Arithmatic & logical")
-   (CMP  - () "Compare")
-   (JMP  - () "Jump & Call")
-   (MISC - () "Miscellaneous")
-   (SYSC - () "System control")
-  )
-)
-
-; Include the instruction set descriptions from their respective
-; source files.
-
-;Arithmatic insns
-;******************************************************************
-
-;add/sub register and immediate
-(define-pmacro (arithmetic16 name insn insn1 opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$"dir"$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 (mem HI op2)))
-       ()
-  )
-)
-(arithmetic16 addrpof add add OP1_0 OP2_2 reg8 upof16 HI "pof")
-(arithmetic16 subrpof sub sub OP1_2 OP2_2 reg8 upof16 HI "pof")
-(arithmetic16 addbrpof addb add OP1_0 OP2_3 regb8 upof16 QI "pof")
-(arithmetic16 subbrpof subb sub OP1_2 OP2_3 regb8 upof16 QI "pof")
-(arithmetic16 addrpag add add OP1_0 OP2_2 reg8 upag16 HI "pag")
-(arithmetic16 subrpag sub sub OP1_2 OP2_2 reg8 upag16 HI "pag")
-(arithmetic16 addbrpag addb add OP1_0 OP2_3 regb8 upag16 QI "pag")
-(arithmetic16 subbrpag subb sub OP1_2 OP2_3 regb8 upag16 QI "pag")
-
-;add/sub register and immediate
-(define-pmacro (arithmetic17 name insn insn1 opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$"dir"$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 (mem HI op2) cbit))
-       ()
-  )
-)
-(arithmetic17 addcrpof addc addc OP1_1 OP2_2 reg8 upof16 HI "pof")
-(arithmetic17 subcrpof subc subc OP1_3 OP2_2 reg8 upof16 HI "pof")
-(arithmetic17 addcbrpof addcb addc OP1_1 OP2_3 regb8 upof16 QI "pof")
-(arithmetic17 subcbrpof subcb subc OP1_3 OP2_3 regb8 upof16 QI "pof")
-(arithmetic17 addcrpag addc addc OP1_1 OP2_2 reg8 upag16 HI "pag")
-(arithmetic17 subcrpag subc subc OP1_3 OP2_2 reg8 upag16 HI "pag")
-(arithmetic17 addcbrpag addcb addc OP1_1 OP2_3 regb8 upag16 QI "pag")
-(arithmetic17 subcbrpag subcb subc OP1_3 OP2_3 regb8 upag16 QI "pag")
-
-;add/sub register and immediate
-(define-pmacro (arithmetic18 name insn insn1 opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"dir"$"op1 ",$"op2)
-       (+ opc1 opc2 op2 op1)
-       (set (mem HI op1) (insn1 (mem HI op1) op2 ))
-       ()
-  )
-)
-(arithmetic18 addrpofr add add OP1_0 OP2_4 upof16 reg8 HI "pof")
-(arithmetic18 subrpofr sub sub OP1_2 OP2_4 upof16 reg8 HI "pof")
-(arithmetic18 addbrpofr addb add OP1_0 OP2_5 upof16 regb8 QI "pof")
-(arithmetic18 subbrpofr subb sub OP1_2 OP2_5 upof16 regb8 QI "pof")
-
-;add/sub register and immediate
-(define-pmacro (arithmetic19 name insn insn1 opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"dir"$"op1 ",$"op2)
-       (+ opc1 opc2 op2 op1)
-       (set (mem HI op1) (insn1 mode (mem HI op1) op2 cbit))
-       ()
-  )
-)
-(arithmetic19 addcrpofr addc addc OP1_1 OP2_4 upof16 reg8 HI "pof")
-(arithmetic19 subcrpofr subc subc OP1_3 OP2_4 upof16 reg8 HI "pof")
-(arithmetic19 addcbrpofr addcb addc OP1_1 OP2_5 upof16 regb8 QI "pof")
-(arithmetic19 subcbrpofr subcb subc OP1_3 OP2_5 upof16 regb8 QI "pof")
-
-;add/sub register and immediate
-(define-pmacro (arithmetic20 name insn insn1 opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"dir"$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-(arithmetic20 addrhpof add add OP1_0 OP2_6 reg8 uimm16 HI "pof")
-(arithmetic20 subrhpof sub sub OP1_2 OP2_6 reg8 uimm16 HI "pof")
-(arithmetic20 addbrhpof add add OP1_0 OP2_6 reg8 uimm16 HI "pag")
-(arithmetic20 subbrhpof sub sub OP1_2 OP2_6 reg8 uimm16 HI "pag")
-
-;add/sub register and immediate
-(define-pmacro (arithmetic21 name insn insn1 opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"dir"$"op2)
-       (+ opc1 opc2 op1 (f-op-bit1 0) op2)
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-(arithmetic21 addrhpof3 add add OP1_0 OP2_8 dr uimm3 HI "pof")
-(arithmetic21 subrhpof3 sub sub OP1_2 OP2_8 dr uimm3 HI "pof")
-(arithmetic21 addbrhpag3 addb add OP1_0 OP2_9 drb uimm3 QI "pag")
-(arithmetic21 subbrhpag3 subb sub OP1_2 OP2_9 drb uimm3 QI "pag")
-(arithmetic21 addrhpag3 add add OP1_0 OP2_8 dr uimm3 HI "pag")
-(arithmetic21 subrhpag3 sub sub OP1_2 OP2_8 dr uimm3 HI "pag")
-(arithmetic21 addbrhpof3 addb add OP1_0 OP2_9 drb uimm3 QI "pof")
-(arithmetic21 subbrhpof3 subb sub OP1_2 OP2_9 drb uimm3 QI "pof")
-
-;add/sub register and immediate
-(define-pmacro (arithmetic22 name insn insn1 opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"dir"$"op2)
-       (+ opc1 opc2 op1 op2 (f-op-bit8 0))
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-(arithmetic22 addrbhpof addb add OP1_0 OP2_7 regb8 uimm8 QI "pof")
-(arithmetic22 subrbhpof subb sub OP1_2 OP2_7 regb8 uimm8 QI "pof")
-(arithmetic22 addbrhpag addb add OP1_0 OP2_7 regb8 uimm8 QI "pag")
-(arithmetic22 subbrhpag subb sub OP1_2 OP2_7 regb8 uimm8 QI "pag")
-
-;add/sub register and immediate
-(define-pmacro (arithmetic23 name insn insn1 opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"dir"$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 op2 cbit))
-       ()
-  )
-)
-(arithmetic23 addcrhpof addc addc OP1_1 OP2_6 reg8 uimm16 HI "pof")
-(arithmetic23 subcrhpof subc subc OP1_3 OP2_6 reg8 uimm16 HI "pof")
-(arithmetic23 addcbrhpof addc addc OP1_1 OP2_6 reg8 uimm16 HI "pag")
-(arithmetic23 subcbrhpof subc subc OP1_3 OP2_6 reg8 uimm16 HI "pag")
-
-;add/sub register and immediate
-(define-pmacro (arithmetic24 name insn insn1 opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"dir"$"op2)
-       (+ opc1 opc2 op1 (f-op-bit1 0) op2)
-       (set mode op1 (insn1 mode op1 op2 cbit))
-       ()
-  )
-)
-(arithmetic24 addcrhpof3 addc addc OP1_1 OP2_8 dr uimm3 HI "pof")
-(arithmetic24 subcrhpof3 subc subc OP1_3 OP2_8 dr uimm3 HI "pof")
-(arithmetic24 addcbrhpag3 addcb addc OP1_1 OP2_9 drb uimm3 QI "pag")
-(arithmetic24 subcbrhpag3 subcb subc OP1_3 OP2_9 drb uimm3 QI "pag")
-(arithmetic24 addcrhpag3 addc addc OP1_1 OP2_8 dr uimm3 HI "pag")
-(arithmetic24 subcrhpag3 subc subc OP1_3 OP2_8 dr uimm3 HI "pag")
-(arithmetic24 addcbrhpof3 addcb addc OP1_1 OP2_9 drb uimm3 QI "pof")
-(arithmetic24 subcbrhpof3 subcb subc OP1_3 OP2_9 drb uimm3 QI "pof")
-
-;add/sub register and immediate
-(define-pmacro (arithmetic25 name insn insn1 opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"dir"$"op2)
-       (+ opc1 opc2 op1 op2 (f-op-bit8 0))
-       (set mode op1 (insn1 mode op1 op2 cbit))
-       ()
-  )
-)
-(arithmetic25 addcrbhpof addcb addc OP1_1 OP2_7 regb8 uimm8 QI "pof")
-(arithmetic25 subcrbhpof subcb subc OP1_3 OP2_7 regb8 uimm8 QI "pof")
-(arithmetic25 addcbrhpag addcb addc OP1_1 OP2_7 regb8 uimm8 QI "pag")
-(arithmetic25 subcbrhpag subcb subc OP1_3 OP2_7 regb8 uimm8 QI "pag")
-
-;add/sub register and immediate
-(define-pmacro (arithmetic10 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op1 (f-op-bit1 0) op2)
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-(arithmetic10 addri add add OP1_0 OP2_8 dr uimm3 HI)
-(arithmetic10 subri sub sub OP1_2 OP2_8 dr uimm3 HI)
-(arithmetic10 addbri addb add OP1_0 OP2_9 drb uimm3 QI)
-(arithmetic10 subbri subb sub OP1_2 OP2_9 drb uimm3 QI)
-
-;add/sub register and immediate
-(define-pmacro (arithmetic11 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-(arithmetic11 addrim add add OP1_0 OP2_6 reg8 uimm16 HI)
-(arithmetic11 subrim sub sub OP1_2 OP2_6 reg8 uimm16 HI)
-
-;add/sub register and immediate
-(define-pmacro (arithmetic12 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op1 op2 (f-op-bit8 0))
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-(arithmetic12 addbrim addb add OP1_0 OP2_7 regb8 uimm8 QI)
-(arithmetic12 subbrim subb sub OP1_2 OP2_7 regb8 uimm8 QI)
-
-;add/sub register and immediate with carry
-(define-pmacro (arithmetic13 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op1 (f-op-bit1 0) op2)
-       (set mode op1 (insn1 mode op1 op2 cbit))
-       ()
-  )
-)
-(arithmetic13 addcri addc addc OP1_1 OP2_8 dr uimm3 HI)
-(arithmetic13 subcri subc subc OP1_3 OP2_8 dr uimm3 HI)
-(arithmetic13 addcbri addcb addc OP1_1 OP2_9 drb uimm3 QI)
-(arithmetic13 subcbri subcb subc OP1_3 OP2_9 drb uimm3 QI)
-
-;add/sub register and immediate with carry
-(define-pmacro (arithmetic14 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 op2 cbit))
-       ()
-  )
-)
-(arithmetic14 addcrim addc addc OP1_1 OP2_6 reg8 uimm16 HI)
-(arithmetic14 subcrim subc subc OP1_3 OP2_6 reg8 uimm16 HI)
-
-;add/sub register and immediate with carry
-(define-pmacro (arithmetic15 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op1 op2 (f-op-bit8 0))
-       (set mode op1 (insn1 mode op1 op2 cbit))
-       ()
-  )
-)
-(arithmetic15 addcbrim addcb addc OP1_1 OP2_7 regb8 uimm8 QI)
-(arithmetic15 subcbrim subcb subc OP1_3 OP2_7 regb8 uimm8 QI)
-
-
-;add/sub registers
-(define-pmacro (arithmetic name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-(arithmetic addr add add OP1_0 OP2_0 dr sr HI)
-(arithmetic subr sub sub OP1_2 OP2_0 dr sr HI)
-(arithmetic addbr addb add OP1_0 OP2_1 drb srb QI)
-(arithmetic subbr subb sub OP1_2 OP2_1 drb srb QI)
-
-;add/sub register and indirect memory
-(define-pmacro (arithmetic1 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",[$"op2"]")
-       (+ opc1 opc2 op1 (f-op-bit2 2) op2)
-       (set mode op1 (insn1 mode op1 (mem HI op2)))
-       ()
-  )
-)
-(arithmetic1 add2 add add OP1_0 OP2_8 dr sr2 HI)
-(arithmetic1 sub2 sub sub OP1_2 OP2_8 dr sr2 HI)
-(arithmetic1 addb2 addb add OP1_0 OP2_9 drb sr2 QI)
-(arithmetic1 subb2 subb sub OP1_2 OP2_9 drb sr2 QI)
-
-;add/sub register and indirect memory post increment
-(define-pmacro (arithmetic2 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",[$"op2"+]")
-       (+ opc1 opc2 op1 (f-op-bit2 3) op2)
-       (sequence ()
-	   (set mode op1 (insn1 mode op1 (mem HI op2)))
-	   (set HI op2 (add HI op2 (const 2)))
-       )
-       ()
-  )
-)
-(arithmetic2 add2i add add OP1_0 OP2_8 dr sr2 HI)
-(arithmetic2 sub2i sub sub OP1_2 OP2_8 dr sr2 HI)
-(arithmetic2 addb2i addb add OP1_0 OP2_9 drb sr2 QI)
-(arithmetic2 subb2i subb sub OP1_2 OP2_9 drb sr2 QI)
-
-;add/sub registers with carry
-(define-pmacro (arithmetic3 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 op2 cbit))
-       ()
-  )
-)
-(arithmetic3 addcr addc addc OP1_1 OP2_0 dr sr HI)
-(arithmetic3 subcr subc subc OP1_3 OP2_0 dr sr HI)
-(arithmetic3 addbcr addcb addc OP1_1 OP2_1 drb srb QI) 
-(arithmetic3 subbcr subcb subc OP1_3 OP2_1 drb srb QI)
-
-
-;add/sub register and indirect memory
-(define-pmacro (arithmetic4 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",[$"op2"]")
-       (+ opc1 opc2 op1 (f-op-bit2 2) op2)
-       (set mode op1 (insn1 mode op1 (mem HI op2) cbit))
-       ()
-  )
-)
-(arithmetic4 addcr2 addc addc OP1_1 OP2_8 dr sr2 HI)
-(arithmetic4 subcr2 subc subc OP1_3 OP2_8 dr sr2 HI)
-(arithmetic4 addbcr2 addcb addc OP1_1 OP2_9 drb sr2 QI)
-(arithmetic4 subbcr2 subcb subc OP1_3 OP2_9 drb sr2 QI)
-
-;add/sub register and indirect memory post increment
-(define-pmacro (arithmetic5 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",[$"op2"+]")
-       (+ opc1 opc2 op1 (f-op-bit2 3) op2)
-       (sequence ()
-           (set mode op1 (insn1 mode op1 (mem HI op2) cbit))
-           (set HI op2 (add HI op2 (const 2)))
-       )
-       ()
-  )
-)
-(arithmetic5 addcr2i addc addc OP1_1 OP2_8 dr sr2 HI)
-(arithmetic5 subcr2i subc subc OP1_3 OP2_8 dr sr2 HI)
-(arithmetic5 addbcr2i addcb addc OP1_1 OP2_9 drb sr2 QI)
-(arithmetic5 subbcr2i subcb subc OP1_3 OP2_9 drb sr2 QI)
-
-;add/sub register and direct memory
-(define-pmacro (arithmetic6 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-
-;add/sub register and direct memory
-(define-pmacro (arithmetic7 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op2 op1)
-       (set (mem HI op1) (insn1 (mem HI op1) op2))
-       ()
-  )
-)
-(arithmetic6 addrm2 add add OP1_0 OP2_2 regmem8 memgr8 HI)
-(arithmetic7 addrm3 add add OP1_0 OP2_4 memgr8 regmem8 HI)
-(arithmetic6 addrm add add OP1_0 OP2_2 reg8 memory HI)
-(arithmetic7 addrm1 add add OP1_0 OP2_4 memory reg8 HI)
-(arithmetic6 subrm3 sub sub OP1_2 OP2_2 regmem8 memgr8 HI)
-(arithmetic7 subrm2 sub sub OP1_2 OP2_4 memgr8 regmem8 HI)
-(arithmetic6 subrm1 sub sub OP1_2 OP2_2 reg8 memory HI)
-(arithmetic7 subrm sub sub OP1_2 OP2_4 memory reg8 HI)
-(arithmetic6 addbrm2 addb add OP1_0 OP2_3 regbmem8 memgr8 QI)
-(arithmetic7 addbrm3 addb add OP1_0 OP2_5 memgr8 regbmem8 QI)
-(arithmetic6 addbrm addb add OP1_0 OP2_3 regb8 memory QI)
-(arithmetic7 addbrm1 addb add OP1_0 OP2_5 memory regb8 QI)
-(arithmetic6 subbrm3 subb sub OP1_2 OP2_3 regbmem8 memgr8 QI)
-(arithmetic7 subbrm2 subb sub OP1_2 OP2_5 memgr8 regbmem8 QI)
-(arithmetic6 subbrm1 subb sub OP1_2 OP2_3 regb8 memory QI)
-(arithmetic7 subbrm subb sub OP1_2 OP2_5 memory regb8 QI)
-
-;add/sub registers with carry
-(define-pmacro (arithmetic8 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 op2 cbit))
-       ()
-  )
-)
-
-;add/sub registers with carry
-(define-pmacro (arithmetic9 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op2 op1)
-       (set (mem HI op1) (insn1 (mem HI op1) op2 cbit))
-       ()
-  )
-)
-(arithmetic8 addcrm2 addc addc OP1_1 OP2_2 regmem8 memgr8 HI)
-(arithmetic9 addcrm3 addc addc OP1_1 OP2_4  memgr8 regmem8 HI)
-(arithmetic8 addcrm addc addc OP1_1 OP2_2 reg8 memory HI)
-(arithmetic9 addcrm1 addc addc OP1_1 OP2_4  memory reg8 HI)
-(arithmetic8 subcrm3 subc subc OP1_3 OP2_2  regmem8 memgr8 HI)
-(arithmetic9 subcrm2 subc subc OP1_3 OP2_4 memgr8 regmem8 HI)
-(arithmetic8 subcrm1 subc subc OP1_3 OP2_2  reg8 memory HI)
-(arithmetic9 subcrm subc subc OP1_3 OP2_4 memory reg8 HI)
-(arithmetic8 addcbrm2 addcb addc OP1_1 OP2_3 regbmem8 memgr8 QI)
-(arithmetic9 addcbrm3 addcb addc OP1_1 OP2_5  memgr8 regbmem8 QI)
-(arithmetic8 addcbrm addcb addc OP1_1 OP2_3 regb8 memory QI)
-(arithmetic9 addcbrm1 addcb addc OP1_1 OP2_5  memory regb8 QI)
-(arithmetic8 subcbrm3 subcb subc OP1_3 OP2_3  regbmem8 memgr8 QI)
-(arithmetic9 subcbrm2 subcb subc OP1_3 OP2_5 memgr8 regbmem8 QI)
-(arithmetic8 subcbrm1 subcb subc OP1_3 OP2_3  regb8 memory QI)
-(arithmetic9 subcbrm subcb subc OP1_3 OP2_5 memory regb8 QI)
-
-; MUL Rwn,Rwm
-(dni muls "signed multiplication"
-     ((PIPE OS) (IDOC ALU))
-     "mul $src1,$src2"
-     (+ OP1_0 OP2_11 src1 src2)
-     (reg SI h-md 0)
-     ()
-)
-; MULU Rwn,Rwm
-(dni mulu "unsigned multiplication"
-     ((PIPE OS) (IDOC ALU))
-     "mulu $src1,$src2"
-     (+ OP1_1 OP2_11 src1 src2)
-     (reg SI h-md 0)
-     ()
-)
-; DIV Rwn
-(dni div "16-by-16 signed division"
-     ((PIPE OS) (IDOC ALU))
-     "div $srdiv"
-     (+ OP1_4 OP2_11 srdiv )
-     (sequence ()
-         (set HI (reg HI h-cr 6) (div HI (reg HI h-cr 6) srdiv))
-         (set HI (reg HI h-cr 7) (mod HI (reg HI h-cr 6) srdiv))
-     )
-     ()
-) 
-; DIVL Rwn
-(dni divl "32-by16 signed division"
-     ((PIPE OS) (IDOC ALU))
-     "divl $srdiv"
-     (+ OP1_6 OP2_11 srdiv )
-     (sequence ()
-         (set HI (reg HI h-cr 6) (div SI (reg SI h-md 0) srdiv))
-	 (set HI (reg HI h-cr 7) (mod SI (reg SI h-md 0) srdiv))
-     )
-     ()
-)
-; DIVLU Rwn 
-(dni divlu "32-by16 unsigned division"
-     ((PIPE OS) (IDOC ALU))
-     "divlu $srdiv"
-     (+ OP1_7 OP2_11 srdiv )
-     (sequence ()
-         (set HI (reg HI h-cr 6) (udiv SI (reg SI h-md 0) srdiv))
-	 (set HI (reg HI h-cr 7) (umod SI (reg SI h-md 0) srdiv))
-     )
-     ()
-)
-; DIVU Rwn
-(dni divu "16-by-16 unsigned division"
-     ((PIPE OS) (IDOC ALU))
-     "divu $srdiv"
-     (+ OP1_5 OP2_11 srdiv )
-     (sequence ()
-         (set HI (reg HI h-cr 6) (udiv HI (reg HI h-cr 6) srdiv))
-         (set HI (reg HI h-cr 7) (umod HI (reg HI h-cr 6) srdiv))
-     )
-     ()
-)
-
-;Integer one's complement
-; CPL Rwn
-(dni cpl "Integer Ones complement"
-     ((PIPE OS) (IDOC MISC))
-     "cpl $dr"
-     (+ OP1_9 OP2_1 dr (f-op-bit4 0))
-     (set dr (inv HI dr))
-     ()
-)
-
-;Bytes one's complement
-; CPLB Rbn
-(dni cplb "Byte Ones complement"
-     ((PIPE OS) (IDOC MISC))
-     "cplb $drb"
-     (+ OP1_11 OP2_1 drb (f-op-bit4 0))
-     (set drb (inv QI drb))
-     ()
-)
-;Integer two's complement
-; NEG Rwn
-(dni neg "Integer two's complement"
-     ((PIPE OS) (IDOC MISC))
-     "neg $dr"
-     (+ OP1_8 OP2_1 dr (f-op-bit4 0))
-     (set dr (neg HI dr))
-     ()
-)
-;Bytes two's complement
-; NEGB Rbn
-(dni negb "byte twos complement"
-     ((PIPE OS) (IDOC MISC))
-     "negb $drb"
-     (+ OP1_10 OP2_1 drb (f-op-bit4 0))
-     (set drb (neg QI drb))
-     ()
-)
-
-;****************************************************************
-;logical insn
-;****************************************************************
-;and/or/xor registers
-(define-pmacro (logical name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "logical" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-
-(logical andr and and OP1_6 OP2_0 dr sr HI)
-(logical orr or or OP1_7 OP2_0 dr sr HI)
-(logical xorr xor xor OP1_5 OP2_0 dr sr HI)
-(logical andbr andb and OP1_6 OP2_1 drb srb QI)
-(logical orbr orb or OP1_7 OP2_1 drb srb QI)
-(logical xorbr xorb xor OP1_5 OP2_1 drb srb QI)
-
-;and/or/xor register and immediate
-(define-pmacro (logical1 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "logical" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op1 (f-op-bit1 0) op2)
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-(logical1 andri and and OP1_6 OP2_8 dr uimm3 HI)
-(logical1 orri or or OP1_7 OP2_8 dr uimm3 HI)
-(logical1 xorri xor xor OP1_5 OP2_8 dr uimm3 HI)
-(logical1 andbri andb and OP1_6 OP2_9 drb uimm3 QI)
-(logical1 orbri orb or OP1_7 OP2_9 drb uimm3 QI)
-(logical1 xorbri xorb xor OP1_5 OP2_9 drb uimm3 QI)
-
-;and/or/xor register and immediate
-(define-pmacro (logical2 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "logical" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-(logical2 andrim and and OP1_6 OP2_6 reg8 uimm16 HI)
-(logical2 orrim or or OP1_7 OP2_6 reg8 uimm16 HI)
-(logical2 xorrim xor xor OP1_5 OP2_6 reg8 uimm16 HI)
-
-;and/or/xor register and immediate
-(define-pmacro (logical3 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "logical" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op1 op2 (f-op-bit8 0))
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-(logical3 andbrim andb and OP1_6 OP2_7 regb8 uimm8 QI)
-(logical3 orbrim orb or OP1_7 OP2_7 regb8 uimm8 QI)
-(logical3 xorbrim xorb xor OP1_5 OP2_7 regb8 uimm8 QI)
-
-;and/or/xor register and indirect memory
-(define-pmacro (logical4 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "logical" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",[$"op2"]")
-       (+ opc1 opc2 op1 (f-op-bit2 2) op2)
-       (set mode op1 (insn1 mode op1 (mem HI op2)))
-       ()
-  )
-)
-(logical4 and2 and and OP1_6 OP2_8 dr sr2 HI)
-(logical4 or2 or or OP1_7 OP2_8 dr sr2 HI)
-(logical4 xor2 xor xor OP1_5 OP2_8 dr sr2 HI)
-(logical4 andb2 andb and OP1_6 OP2_9 drb sr2 QI)
-(logical4 orb2 orb or OP1_7 OP2_9 drb sr2 QI)
-(logical4 xorb2 xorb xor OP1_5 OP2_9 drb sr2 QI)
-
-;and/or/xor register and indirect memory post increment
-(define-pmacro (logical5 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "logical" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",[$"op2"+]")
-       (+ opc1 opc2 op1 (f-op-bit2 3) op2)
-       (sequence ()
-	   (set mode op1 (insn1 mode op1 (mem HI op2)))
-	   (set HI op2 (add HI op2 (const 2)))
-       )
-       ()
-  )
-)
-(logical5 and2i and and OP1_6 OP2_8 dr sr2 HI)
-(logical5 or2i or or OP1_7 OP2_8 dr sr2 HI)
-(logical5 xor2i xor xor OP1_5 OP2_8 dr sr2 HI)
-(logical5 andb2i andb and OP1_6 OP2_9 drb sr2 QI)
-(logical5 orb2i orb or OP1_7 OP2_9 drb sr2 QI)
-(logical5 xorb2i xorb xor OP1_5 OP2_9 drb sr2 QI)
-
-;add/sub register and immediate
-(define-pmacro (logical7 name insn insn1 opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"dir"$"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set (mem HI op1) (insn1 (mem HI op1) op2 ))
-       ()
-  )
-)
-(logical7 andpofr and and OP1_6 OP2_2 reg8 upof16 HI "pof")
-(logical7 orpofr or or OP1_7 OP2_2 reg8 upof16 HI "pof")
-(logical7 xorpofr xor xor OP1_5 OP2_2 reg8 upof16 HI "pof")
-(logical7 andbpofr andb and OP1_6 OP2_3 regb8 upof16 QI "pof")
-(logical7 orbpofr orb or OP1_7 OP2_3 regb8 upof16 QI "pof")
-(logical7 xorbpofr xorb xor OP1_5 OP2_3 regb8 upof16 QI "pof")
-
-;add/sub register and immediate
-(define-pmacro (logical8 name insn insn1 opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"dir"$"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set (mem HI op1) (insn1 (mem HI op1) op2 ))
-       ()
-  )
-)
-(logical8 andrpofr and and OP1_6 OP2_4 upof16 reg8 HI "pof")
-(logical8 orrpofr or or OP1_7 OP2_4 upof16 reg8 HI "pof")
-(logical8 xorrpofr xor xor OP1_5 OP2_4 upof16 reg8 HI "pof")
-(logical8 andbrpofr andb and OP1_6 OP2_5 upof16 regb8 QI "pof")
-(logical8 orbrpofr orb or OP1_7 OP2_5 upof16 regb8 QI "pof")
-(logical8 xorbrpofr xorb xor OP1_5 OP2_5 upof16 regb8 QI "pof")
-
-;and/or/xor register and direct memory
-(define-pmacro (logical6 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-
-;and/or/xor register and direct memory
-(define-pmacro (logical7 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "arithmetic" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op2 op1)
-       (set (mem HI op1) (insn1 (mem HI op1) op2))
-       ()
-  )
-)
-(logical6 andrm2 and and OP1_6 OP2_2 regmem8 memgr8 HI)
-(logical7 andrm3 and and OP1_6 OP2_4 memgr8 regmem8 HI)
-(logical6 andrm and and OP1_6 OP2_2 reg8 memory HI)
-(logical7 andrm1 and and OP1_6 OP2_4 memory reg8 HI)
-(logical6 orrm3 or or OP1_7 OP2_2 regmem8 memgr8 HI)
-(logical7 orrm2 or or OP1_7 OP2_4 memgr8 regmem8 HI)
-(logical6 orrm1 or or OP1_7 OP2_2 reg8 memory HI)
-(logical7 orrm or or OP1_7 OP2_4 memory reg8 HI)
-(logical6 xorrm3 xor xor OP1_5 OP2_2 regmem8 memgr8 HI)
-(logical7 xorrm2 xor xor OP1_5 OP2_4 memgr8 regmem8 HI)
-(logical6 xorrm1 xor xor OP1_5 OP2_2 reg8 memory HI)
-(logical7 xorrm xor xor OP1_5 OP2_4 memory reg8 HI)
-(logical6 andbrm2 andb and OP1_6 OP2_3 regbmem8 memgr8 QI)
-(logical7 andbrm3 andb and OP1_6 OP2_5 memgr8 regbmem8 QI)
-(logical6 andbrm andb and OP1_6 OP2_3 regb8 memory QI)
-(logical7 andbrm1 andb and OP1_6 OP2_5 memory regb8 QI)
-(logical6 orbrm3 orb or OP1_7 OP2_3 regbmem8 memgr8 QI)
-(logical7 orbrm2 orb or OP1_7 OP2_5 memgr8 regbmem8 QI)
-(logical6 orbrm1 orb or OP1_7 OP2_3 regb8 memory QI)
-(logical7 orbrm orb or OP1_7 OP2_5 memory regb8 QI)
-(logical6 xorbrm3 xorb xor OP1_5 OP2_3 regbmem8 memgr8 QI)
-(logical7 xorbrm2 xorb xor OP1_5 OP2_5 memgr8 regbmem8 QI)
-(logical6 xorbrm1 xorb xor OP1_5 OP2_3 regb8 memory QI)
-(logical7 xorbrm xorb xor OP1_5 OP2_5 memory regb8 QI)
-
-;****************************************************************
-;logical insn
-;****************************************************************
-;mov registers
-(define-pmacro (move name insn opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "mov registers" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 op2)
-       ()
-  )
-)
-(move movr mov OP1_15 OP2_0 dr sr HI)
-(move movrb movb OP1_15 OP2_1 drb srb HI)
-
-;mov register and immediate
-(define-pmacro (move1 name insn opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op2 op1)
-       (set mode op1 op2)
-       ()
-  )
-)
-(move1 movri mov  OP1_14 OP2_0 dri u4 HI)
-(move1 movbri movb  OP1_14 OP2_1 srb u4 QI)
-
-; MOV Rwn,#data16
-(dni movi "move immediate to register"
-     ((PIPE OS) (IDOC MOVE))
-     "mov $reg8,$hash$uimm16"
-     (+ OP1_14 OP2_6 reg8 uimm16)
-     (set HI reg8 uimm16)
-     ()
-)
-
-; MOVB reg,#data8
-(dni movbi "move immediate to register"
-     ((PIPE OS) (IDOC MOVE))
-     "movb $regb8,$hash$uimm8"
-     (+ OP1_14 OP2_7 regb8 uimm8 (f-op-bit8 0))
-     (set QI regb8 uimm8)
-     ()
-)
-
-;move and indirect memory
-(define-pmacro (mov2 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",[$"op2"]")
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (mem HI op2))
-       ()
-  )
-)
-(mov2 movr2 mov OP1_10 OP2_8 dr sr HI)
-(mov2 movbr2 movb OP1_10 OP2_9 drb sr QI)
-
-;move and indirect memory
-(define-pmacro (mov3 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " [$"op2 "],$"op1)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (mem HI op2))
-       ()
-  )
-)
-(mov3 movri2 mov OP1_11 OP2_8 dr sr HI)
-(mov3 movbri2 movb OP1_11 OP2_9 drb sr QI)
-
-;move and indirect memory
-(define-pmacro (mov4 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " [-$"op2 "],$"op1)
-       (+ opc1 opc2 op1 op2)
-       (sequence HI ()
-	  (set op1 (sub op2 (const HI 2)))
-	  (set HI (mem HI op2) op1)
-       )
-       ()
-  )
-)
-(mov4 movri3 mov OP1_8 OP2_8 dr sr HI)
-(mov4 movbri3 movb OP1_8 OP2_9 drb sr QI)
-
-;mov register and indirect memory post increment
-(define-pmacro (mov5 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",[$"op2"+]")
-       (+ opc1 opc2 op1 op2)
-       (sequence ()
-	   (set mode op1 (mem HI op2))
-	   (set HI op2 (add HI op2 (const 2)))
-       )
-       ()
-  )
-)
-(mov5 mov2i mov OP1_9 OP2_8 dr sr HI)
-(mov5 movb2i movb OP1_9 OP2_9 drb sr HI)
-
-;mov indirect memory
-(define-pmacro (mov6 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " [$"op1 "],[$"op2"]")
-       (+ opc1 opc2 op1 op2)
-       (set HI (mem HI op1) (mem HI op2))
-       ()
-  )
-)
-(mov6 mov6i mov OP1_12 OP2_8 dr sr HI)
-(mov6 movb6i movb OP1_12 OP2_9 dr sr HI)
-
-;mov indirect memory
-(define-pmacro (mov7 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " [$"op1 "+],[$"op2"]")
-       (+ opc1 opc2 op1 op2)
-       (sequence ()
-          (set mode (mem mode op1) (mem mode op2))
-          (set mode op1 (add mode op1 (const mode 2)))
-       )
-       ()
-  )
-)
-(mov7 mov7i mov OP1_13 OP2_8 dr sr HI)
-(mov7 movb7i movb OP1_13 OP2_9 dr sr HI)
-
-;mov indirect memory
-(define-pmacro (mov8 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " [$"op1 "],[$"op2"+]")
-       (+ opc1 opc2 op1 op2)
-       (sequence ()
-          (set mode (mem mode op1) (mem mode op2))
-          (set mode op2 (add mode op2 (const mode 2)))
-       )
-       ()
-  )
-)
-(mov8 mov8i mov OP1_14 OP2_8 dr sr HI)
-(mov8 movb8i movb OP1_14 OP2_9 dr sr HI)
-
-;mov indirect memory
-(define-pmacro (mov9 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",[$"op2"+$hash$"uimm16"]")
-       (+ opc1 opc2 op1 op2 uimm16)
-       (sequence mode ((mode tmp1))
-	   (set mode tmp1 (add HI op2 uimm16))
-	   (set mode op1 (mem HI tmp1))
-       )
-       ()
-  )
-)
-(mov9 mov9i mov OP1_13 OP2_4 dr sr HI)
-(mov9 movb9i movb OP1_15 OP2_4 drb sr QI)
-
-;mov indirect memory
-(define-pmacro (mov10 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " [$"op2"+$hash$"uimm16 "],$"op1)
-       (+ opc1 opc2 op1 op2 uimm16)
-       (sequence mode ((mode tmp1))
-	   (set mode tmp1 (add HI op1 uimm16))
-	   (set mode (mem HI tmp1) op1)
-       )
-       ()
-  )
-)
-(mov10 mov10i mov OP1_12 OP2_4 dr sr HI)
-(mov10 movb10i movb OP1_14 OP2_4 drb sr QI)
-
-;move and indirect memory
-(define-pmacro (mov11 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " [$"op1 "],$"op2)
-       (+ opc1 opc2 (f-op-lbit4 0) op1 op2)
-       (set (mem mode op1) (mem HI op2))
-       ()
-  )
-)
-(mov11 movri11 mov OP1_8 OP2_4 src2 memory HI)
-(mov11 movbri11 movb OP1_10 OP2_4 src2 memory HI)
-
-;move and indirect memory
-(define-pmacro (mov12 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op2 ",[$"op1"]")
-       (+ opc1 opc2 (f-op-lbit4 0) op1 op2)
-       (set (mem HI op2) (mem mode op1))
-       ()
-  )
-)
-(mov12 movri12 mov OP1_9 OP2_4 src2 memory HI)
-(mov12 movbri12 movb OP1_11 OP2_4 src2 memory HI)
-
-(define-pmacro (movemem3 name insn opc1 opc2 op1 op2  dir)
-  (dni name 
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",$hash$"dir"$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set HI op1 op2)
-       ()
-  )
-)
-(movemem3 movehm5 mov OP1_14 OP2_6 regoff8 upof16 "pof")
-(movemem3 movehm6 mov OP1_14 OP2_6 regoff8 upag16 "pag")
-(movemem3 movehm7 mov OP1_14 OP2_6 regoff8 useg16 "segm")
-(movemem3 movehm8 mov OP1_14 OP2_6 regoff8 usof16 "sof")
-
-(define-pmacro (movemem4 name insn opc1 opc2 op1 op2 dir)
-  (dni name 
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",$hash$"dir"$"op2)
-       (+ opc1 opc2 op1 op2 (f-op-bit8 0))
-       (set QI op1 op2)
-       ()
-  )
-)
-(movemem4 movehm9 movb OP1_14 OP2_7 regb8 uimm8 "pof")
-(movemem4 movehm10 movb OP1_14 OP2_7 regoff8 uimm8 "pag")
-
-(define-pmacro (movemem name insn opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",$"dir"$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (mem HI op2))
-       ()
-  )
-)
-(movemem movrmp mov OP1_15 OP2_2 regoff8 upof16 HI "pof")
-(movemem movrmp1 movb OP1_15 OP2_3 regb8 upof16 QI "pof")
-(movemem movrmp2 mov OP1_15 OP2_2 regoff8 upag16 HI "pag")
-(movemem movrmp3 movb OP1_15 OP2_3 regb8 upag16 QI "pag")
-
-(define-pmacro (movemem1 name insn opc1 opc2 op1 op2 dir)
-  (dni name 
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"dir"$"op1 ",$"op2)
-       (+ opc1 opc2 op2 op1)
-       (set (mem HI op1) op2 )
-       ()
-  )
-)
-(movemem1 movrmp4 mov OP1_15 OP2_6  upof16 regoff8 "pof")
-(movemem1 movrmp5 movb OP1_15 OP2_7 upof16 regb8 "pof")
-
-(define-pmacro (movemem2 name insn opc1 opc2 op1 op2 mode dir)
-  (dni name 
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",$hash$"dir"$"op2)
-       (+ opc1 opc2 op2 op1)
-       (set mode op1 op2)
-       ()
-  )
-)
-(movemem2 movehm1 mov OP1_14 OP2_0 dri u4 HI "pof")
-(movemem2 movehm2 movb OP1_14 OP2_1 srb u4 QI "pof")
-(movemem2 movehm3 mov OP1_14 OP2_0 dri u4 HI "pag")
-(movemem2 movehm4 movb OP1_14 OP2_1 srb u4 QI "pag")
-
-;move register and direct memory
-(define-pmacro (move12 name insn opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (mem HI op2))
-       ()
-  )
-)
-
-;move register and direct memory
-(define-pmacro (move13 name insn opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op2 op1)
-       (set (mem HI op1) op2)
-       ()
-  )
-)
-(move12 mve12 mov OP1_15 OP2_2 regmem8 memgr8 HI)
-(move13 mve13 mov OP1_15 OP2_6 memgr8 regmem8 HI)
-(move12 mover12 mov OP1_15 OP2_2 reg8 memory HI)
-(move13 mvr13 mov OP1_15 OP2_6 memory reg8 HI)
-(move12 mver12 movb OP1_15 OP2_3 regbmem8 memgr8 QI)
-(move13 mver13 movb OP1_15 OP2_7 memgr8 regbmem8 QI)
-(move12 movr12 movb OP1_15 OP2_3 regb8 memory QI)
-(move13 movr13 movb OP1_15 OP2_7 memory regb8 QI)
-
-; MOVBS Rw,Rb
-(dni movbsrr "mov byte register with sign extension to word register"
-     ((PIPE OS) (IDOC MOVE))
-     "movbs $sr,$drb"
-     (+ OP1_13 OP2_0 drb sr)
-     (sequence ()
-         (if QI (and QI drb (const 128))
-                (set HI sr (or HI (const HI 65280) drb)))
-         (set HI sr (and HI (const HI 255) drb)) 
-     )
-     ()
-)
-
-; MOVBZ Rw,Rb
-(dni movbzrr "mov byte register with zero extension to word register"
-     ((PIPE OS) (IDOC MOVE))
-     "movbz $sr,$drb"
-     (+ OP1_12 OP2_0 drb sr)
-     (set HI sr (and HI (const HI 255) drb))
-     ()
-)
-
-; MOVBS reg,POF mem
-(dni movbsrpofm "mov memory to byte register"
-     ((PIPE OS) (IDOC MOVE))
-     "movbs $regmem8,$pof$upof16"
-     (+ OP1_13 OP2_2 regmem8 upof16)
-     (set QI regmem8 (mem HI upof16))
-     ()
-)
-
-; MOVBS pof,reg
-(dni movbspofmr "mov memory to byte register"
-     ((PIPE OS) (IDOC MOVE))
-     "movbs $pof$upof16,$regbmem8"
-     (+ OP1_13 OP2_5 upof16 regbmem8 )
-     (set QI  (mem HI upof16) regbmem8)
-     ()
-)
-
-; MOVBZ reg,POF mem
-(dni movbzrpofm "mov memory to byte register"
-     ((PIPE OS) (IDOC MOVE))
-     "movbz $reg8,$pof$upof16"
-     (+ OP1_12 OP2_2 reg8 upof16)
-     (set QI reg8 (mem HI upof16))
-     ()
-)
-
-; MOVBZ pof,reg
-(dni movbzpofmr "mov memory to byte register"
-     ((PIPE OS) (IDOC MOVE))
-     "movbz $pof$upof16,$regb8"
-     (+ OP1_12 OP2_5 upof16 regb8 )
-     (set QI  (mem HI upof16) regb8)
-     ()
-)
-
-;move register and direct memory
-(define-pmacro (move14 name insn opc1 opc2 op1 op2 )
-  (dni name 
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set HI op1 (and HI (const HI 255) (mem QI op2)))
-       ()
-  )
-)
-
-;move register and direct memory
-(define-pmacro (move15 name insn opc1 opc2 op1 op2 )
-  (dni name 
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op2 op1)
-       (set HI (mem HI op1) (and HI (const HI 255) op2))
-       ()
-  )
-)
-(move14 movebs14 movbs OP1_13 OP2_2 regmem8 memgr8 )
-(move15 movebs15 movbs OP1_13 OP2_5 memgr8 regbmem8 )
-(move14 moverbs14 movbs OP1_13 OP2_2 reg8 memory )
-(move15 movrbs15 movbs OP1_13 OP2_5 memory regb8 )
-(move14 movebz14 movbz OP1_12 OP2_2 regmem8 memgr8 )
-(move15 movebz15 movbz OP1_12 OP2_5 memgr8 regbmem8 )
-(move14 moverbz14 movbz OP1_12 OP2_2 reg8 memory )
-(move15 movrbz15 movbz OP1_12 OP2_5 memory regb8 )
-
-
-;mov registers
-(define-pmacro (moveb1 name insn opc1 opc2 op1 op2)
-  (dni name 
-       (.str name "move" )
-       ((PIPE OS) (IDOC MOVE))
-       (.str insn " $"op2 ",$"op1)
-       (+ opc1 opc2 op1 op2)
-       (sequence ()
-           (if QI (and QI op1 (const 128))
-                  (set HI op2 (or HI (const HI 65280) op1)))
-           (set HI op2 (and HI (const HI 255) op1)) 
-       )
-       ()
-  )
-)
-(moveb1 movrbs movbs OP1_13 OP2_0 drb sr )
-(moveb1 movrbz movbz OP1_12 OP2_0 drb sr )
-
-
-
-;jump and call insns
-;******************************************************************
-;Absolute conditional jump
-(define-pmacro (jmpabs name insn)
-  (dni name
-     (.str name "Absolute conditional jump" )
-     ((PIPE OS) (IDOC JMP))
-     (.str insn " $extcond,$caddr")
-     (+ OP1_14 OP2_10 extcond (f-op-bitone 0) bitone bit01 caddr)
-     (sequence ((HI tmp1) (HI tmp2))
-        (set tmp1 (mem HI caddr))
-        (set tmp2 (sub HI pc (mem HI caddr)))
-        (if (gt tmp2 (const 0)) (lt tmp2 (const 32)) (eq tmp2 (const 32))
-            (set bitone (const 1)))
-	(if (lt tmp2 (const 0)) (eq tmp2 (const 0)) (gt tmp2 (const 32))
-            (set bitone (const 0)))
-        (if (eq extcond (const 1) (ne extcond cc_Z))
-             (set bit01 (const 0))    
-             (set HI pc (mem HI caddr)))
-	(if (ne extcond (const 1) (eq extcond cc_Z))
-             (set bit01 (const 1))
-             (set HI pc (add HI pc (const 2))))
-     )
-     ()
-  )
-)
-
-(jmpabs jmpa0 jmpa+)
-(jmpabs jmpa1 jmpa)
-
-; JMPA- cc,caddr
-(dni jmpa- "Absolute conditional jump"
-     (COND-CTI (PIPE OS) (IDOC JMP))
-     "jmpa- $extcond,$caddr"
-     (+ OP1_14 OP2_10 extcond (f-op-bitone 0) bitone (f-op-1bit 1) caddr)
-     (sequence ((HI tmp1) (HI tmp2))
-        (set tmp1 (mem HI caddr))
-        (set tmp2 (sub HI pc (mem HI caddr)))
-        (if (gt tmp2 (const 0)) (lt tmp2 (const 32)) (eq tmp2 (const 32))
-            (set bitone (const 1)))
-	(if (lt tmp2 (const 0)) (eq tmp2 (const 0)) (gt tmp2 (const 32))
-            (set bitone (const 0)))
-        (set HI pc (add HI pc (const 2)))
-     )
-     ()
-)
-
-; JMPI cc,[Rwn]
-(dni jmpi "Indirect conditional jump"
-     (COND-CTI (PIPE OS) (IDOC JMP))
-     "jmpi $icond,[$sr]"
-     (+ OP1_9 OP2_12 icond sr)
-     (sequence ()
-        (if (eq icond (const 1))
-             (set HI pc (mem HI sr)))
-             (set HI pc (add HI pc (const 2)))
-     )
-     ()
-)
-
-(define-pmacro (jmprel name insn opc1)
-  (dni name
-       (.str name "conditional" )
-       (COND-CTI (PIPE OS) (IDOC JMP))
-       (.str insn " $cond,$rel")
-       (+ opc1 OP2_13 rel)
-       (sequence ()
-           (if (eq cond (const 1))
-               (sequence ()
-		    (if QI (lt QI rel (const 0))
-                           (sequence ()
-                                (neg QI rel)
-                                (add QI rel (const 1))
-                                (mul QI rel (const 2))
-                                (set HI pc (sub HI pc rel))
-                           ))
-                    (set HI pc (add HI pc (mul QI rel (const 2))))
-               )
-            )
-            (set HI pc pc)
-       )
-       ()
-  )
-)
-
-(jmprel jmpr_nenz jmpr  COND_NE_NZ )
-(jmprel jmpr_sgt jmpr  COND_SGT )
-(jmprel jmpr_z jmpr  COND_Z )
-(jmprel jmpr_v jmpr  COND_V )
-(jmprel jmpr_nv jmpr  COND_NV )
-(jmprel jmpr_n jmpr  COND_N )
-(jmprel jmpr_nn jmpr  COND_NN )
-(jmprel jmpr_c jmpr  COND_C )
-(jmprel jmpr_nc jmpr  COND_NC )
-(jmprel jmpr_eq jmpr  COND_EQ )
-(jmprel jmpr_ne jmpr  COND_NE )
-(jmprel jmpr_ult jmpr  COND_ULT )
-(jmprel jmpr_ule jmpr  COND_ULE )
-(jmprel jmpr_uge jmpr  COND_UGE )
-(jmprel jmpr_ugt jmpr  COND_UGT )
-(jmprel jmpr_sle jmpr  COND_SLE )
-(jmprel jmpr_sge jmpr  COND_SGE )
-(jmprel jmpr_net jmpr  COND_NET )
-(jmprel jmpr_uc jmpr  COND_UC )
-(jmprel jmpr_slt jmpr  COND_SLT )
-
-
-
-
-; JMPS seg,caddr
-(dni jmpseg "absolute inter-segment jump"
-     (UNCOND-CTI(PIPE OS) (IDOC JMP))
-     "jmps $hash$segm$useg8,$hash$sof$usof16"
-     (+ OP1_15 OP2_10 seg usof16)
-     (sequence ()
-          (if QI (eq BI sgtdisbit (const BI 0))
-                 (set QI (reg h-cr 10) useg8))
-                 (nop)
-          (set HI pc usof16)
-     )
-     ()
-)
-
-; JMPS seg,caddr
-(dni jmps "absolute inter-segment jump"
-     (UNCOND-CTI(PIPE OS) (IDOC JMP))
-     "jmps $seg,$caddr"
-     (+ OP1_15 OP2_10 seg caddr)
-     (sequence ()
-          (if QI (eq BI sgtdisbit (const BI 0))
-                 (set QI (reg h-cr 10) seg))
-                 (nop)
-          (set HI pc caddr)
-     )
-     ()
-)
-
-
-;relative jump if bit set
-;JB bitaddrQ.q,rel
-(dni jb "relative jump if bit set"
-     ((PIPE OS) (IDOC JMP))
-     "jb $genreg$dot$qlobit,$relhi"
-     (+ OP1_8 OP2_10 genreg relhi qlobit (f-qhibit 0))
-     (sequence ((HI tmp1) (HI tmp2))
-          (set HI tmp1 genreg)
-          (set HI tmp2 (const 1))
-          (sll HI tmp2 qlobit)
-          (set HI tmp2 (and tmp1 tmp2))
-          (if (eq tmp2 (const 1))
-             (sequence ()
-                (if QI (lt QI relhi (const 0))
-                       (set HI pc (add HI pc (mul QI relhi (const 2)))))
-             ))
-         (set HI pc (add HI pc (const 4))) 
-     )
-     ()
-)
-
-;relative jump if bit set and clear bit
-;JBC bitaddrQ.q,rel
-(dni jbc "relative jump if bit set and clear bit"
-     ((PIPE OS) (IDOC JMP))
-     "jbc $genreg$dot$qlobit,$relhi"
-     (+ OP1_10 OP2_10 genreg relhi qlobit (f-qhibit 0))
-     (sequence ((HI tmp1) (HI tmp2))
-          (set HI tmp1 genreg)
-          (set HI tmp2 (const 1))
-          (sll HI tmp2 qlobit)
-          (set HI tmp2 (and tmp1 tmp2))
-          (if (eq tmp2 (const 1))
-             (sequence ()
-                (if QI (lt QI relhi (const 0))
-                       (set tmp2 (const 1))
-                       (set tmp1 genreg)
-                       (sll tmp2 qlobit)
-                       (inv tmp2)
-                       (set HI tmp1(and tmp1 tmp2))
-                       (set HI genreg tmp1)
-                       (set HI pc (add HI pc (mul QI relhi (const 2)))))
-             ))
-          (set HI pc (add HI pc (const 4)))
-     )
-     ()
-)
-
-;relative jump if bit set
-;JNB bitaddrQ.q,rel
-(dni jnb "relative jump if bit not set"
-     ((PIPE OS) (IDOC JMP))
-     "jnb $genreg$dot$qlobit,$relhi"
-     (+ OP1_9 OP2_10 genreg relhi qlobit (f-qhibit 0))
-     (sequence ((HI tmp1) (HI tmp2))
-          (set HI tmp1 genreg)
-          (set HI tmp2 (const 1))
-          (sll HI tmp2 qlobit)
-          (set HI tmp2 (and tmp1 tmp2))
-          (if (eq tmp2 (const 0))
-             (sequence ()
-                (if QI (lt QI relhi (const 0))
-                       (set HI pc (add HI pc (mul QI relhi (const 2)))))
-             ))
-          (set HI pc (add HI pc (const 4)))
-     )
-     ()
-)
-
-;relative jump if bit not set and set bit
-;JNBS bitaddrQ.q,rel
-(dni jnbs "relative jump if bit not set and set bit"
-     ((PIPE OS) (IDOC JMP))
-     "jnbs $genreg$dot$qlobit,$relhi"
-     (+ OP1_11 OP2_10 genreg relhi qlobit (f-qhibit 0))
-     (sequence ((HI tmp1) (HI tmp2))
-          (set HI tmp1 genreg)
-          (set HI tmp2 (const 1))
-          (sll HI tmp2 qlobit)
-          (set HI tmp2 (and tmp1 tmp2))
-          (if (eq tmp2 (const 0))
-             (sequence ()
-                (if QI (lt QI relhi (const 0))
-                       (set tmp2 (const 1))
-                       (set tmp1 reg8)
-                       (sll tmp2 qbit)
-                       (set BI tmp1(or tmp1 tmp2))
-                       (set HI reg8 tmp1)
-                       (set HI pc (add HI pc (mul QI relhi (const 2)))))
-             ))
-          (set HI pc (add HI pc (const 4)))
-     )
-     ()
-)
-
-
-;Absolute conditional call
-(define-pmacro (callabs name insn)
-  (dni name
-     (.str name "Absolute conditional call" )
-     ((PIPE OS) (IDOC JMP))
-     (.str insn " $extcond,$caddr")
-     (+ OP1_12 OP2_10 extcond (f-op-2bit 0) bit01 caddr)
-     (sequence ()
-        (if (eq extcond (const 1))
-          (set bit01 (const 0))
-          (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-	  (set HI (mem HI (reg h-cr 9)) pc)
-	  (set HI pc (mem HI caddr)))
-        (if (ne extcond (const 1))
-          (set bit01 (const 1))
-          (set HI pc (add HI pc (const 2))))
-     )
-     ()
-  )
-)
-
-(callabs calla0 calla+)
-(callabs calla1 calla)
-
-; CALLA- cc,caddr
-(dni calla- "Absolute conditional call"
-     (COND-CTI (PIPE OS) (IDOC JMP))
-     "calla- $extcond,$caddr"
-     (+ OP1_12 OP2_10 extcond (f-op-bit3 1) caddr)
-     (sequence ()
-        (if (eq extcond (const 1))
-          (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-	  (set HI (mem HI (reg h-cr 9)) pc)
-	  (set HI pc (mem HI caddr)))
-        (set HI pc (add HI pc (const 2)))
-     )
-     ()
-)
-
-; CALLI cc,[Rwn]
-(dni calli "indirect subroutine call"
-     (COND-CTI (PIPE OS) (IDOC JMP))
-     "calli $icond,[$sr]"
-     (+ OP1_10 OP2_11 icond sr)
-     (sequence ()
-         (if (eq icond (const 1))
-             (sequence ()
-	             (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-        	     (set HI (mem HI (reg h-cr 9)) pc)
-        	     (set HI pc (mem HI sr))
-             )
-         )
-         (set HI pc (add HI pc (const 2)))
-     )
-     ()
-)
-
-; CALLR rel
-(dni callr "Call subroutine with PC relative signed 8 bit offset"
-     ( COND-CTI (PIPE OS) (IDOC JMP))
-     "callr $rel"
-     (+ OP1_11 OP2_11 rel)
-     (sequence ()
-          (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-	  (set HI (mem HI (reg h-cr 9)) pc)
-          (sequence ()
-                (if QI (lt QI rel (const 0))
-                       (sequence ()
-                           (neg QI rel)
-                           (add QI rel (const 1))
-                           (mul QI rel (const 2))
-                           (set HI pc (sub HI pc rel))
-                       ))
-                (set HI pc (add HI pc (mul QI rel (const 2))))
-          )
-      )
-      ()
-)
-
-
-; CALLS seg,caddr
-(dni callseg "call inter-segment subroutine"
-     (UNCOND-CTI (PIPE OS) (IDOC JMP))
-     "calls $hash$segm$useg8,$hash$sof$usof16"
-     (+ OP1_13 OP2_10 useg8 usof16)
-     (sequence ()
-          (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-          (set HI (mem HI (reg h-cr 9)) (reg h-cr 10))
-          (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-          (set HI (mem HI (reg h-cr 9)) pc)
-          (if QI (eq BI sgtdisbit (const BI 0))
-                 (set QI (reg h-cr 10) useg8))
-                 (nop)
-          (set HI pc usof16)
-     )
-     ()
-)
-
-; CALLS seg,caddr
-(dni calls "call inter-segment subroutine"
-     (UNCOND-CTI (PIPE OS) (IDOC JMP))
-     "calls $seg,$caddr"
-     (+ OP1_13 OP2_10 seg caddr)
-     (sequence ()
-          (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-          (set HI (mem HI (reg h-cr 9)) (reg h-cr 10))
-          (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-          (set HI (mem HI (reg h-cr 9)) pc)
-          (if QI (eq BI sgtdisbit (const BI 0))
-                 (set QI (reg h-cr 10) seg))
-                 (nop)
-          (set HI pc caddr)
-     )
-     ()
-)
-
-; PCALL reg,caddr
-(dni pcall "push word and call absolute subroutine"
-       (UNCOND-CTI (PIPE OS) (IDOC JMP))
-       "pcall $reg8,$caddr"
-       (+ OP1_14 OP2_2 reg8 caddr)
-       (sequence ((HI tmp1))
-            (set HI tmp1 reg8)
- 	    (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-	    (set HI (mem HI (reg h-cr 9)) tmp1)
- 	    (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-	    (set HI (mem HI (reg h-cr 9)) pc)
-            (set HI pc caddr)
-       )
-       ()
-)
-
-; TRAP #uimm7
-(dni trap "software trap"
-       (UNCOND-CTI (PIPE OS) (IDOC JMP))
-       "trap $hash$uimm7"
-       (+ OP1_9 OP2_11 uimm7 (f-op-1bit 0))
-       (sequence ()
-	    (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-            (set HI (mem HI (reg h-cr 9)) (reg h-cr 4))
-              (if QI (eq BI sgtdisbit (const BI 0))
-                     (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-                     (set HI (mem HI (reg h-cr 9)) (reg h-cr 10) )
-              )
-              (nop)
-            (set HI (reg h-cr 10) (reg h-cr 11))
-            (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))
-            (set HI (mem HI (reg h-cr 9)) pc)
-            (set HI pc (mul QI uimm7 (const 4)))
-       )
-       ()
-)
-
-;Return insns
-; RET
-(dni ret "return from subroutine"
-       (UNCOND-CTI (PIPE OS) (IDOC JMP))
-       "ret"
-       (+ OP1_12 OP2_11 (f-op-bit8 0))
-       (sequence ()
-           (set HI pc (mem HI (reg h-cr 9)))
-           (set (reg h-cr 9) (add HI (reg h-cr 9) (const 2)))
-       )
-       ()
-)
-
-; RETS 
-(dni rets "return from inter-segment sunroutine"
-       (UNCOND-CTI (PIPE OS) (IDOC JMP))
-       "rets"
-       (+ OP1_13 OP2_11 (f-op-bit8 0))
-       (sequence ()
-           (set HI pc (mem HI (reg h-cr 9)))
-           (set (reg h-cr 9) (add HI (reg h-cr 9) (const 2)))
-              (if QI (eq BI sgtdisbit (const BI 0))
-                     (set HI (reg h-cr 10) (mem HI (reg h-cr 9)))
-              )
-              (nop)
-     	   (set (reg h-cr 9) (add HI (reg h-cr 9) (const 2)))
-       )
-       ()
-)
-
-; RETP reg
-(dni retp "return from subroutine and pop word register"
-       (UNCOND-CTI (PIPE OS) (IDOC JMP))
-       "retp $reg8"
-       (+ OP1_14 OP2_11 reg8)
-       (sequence ((HI tmp1))
-            (set HI pc (mem HI (reg h-cr 9)))
-            (set (reg h-cr 9) (add HI (reg h-cr 9) (const 2)))
-	    (set HI tmp1 (mem HI (reg h-cr 9)))
-            (set (reg h-cr 9) (add HI (reg h-cr 9) (const 2)))
-            (set HI reg8 tmp1)
-       )
-       ()
-)
-
-; RETI
-(dni reti "return from ISR"
-       (UNCOND-CTI (PIPE OS) (IDOC JMP))
-       "reti"
-       (+ OP1_15 OP2_11 (f-op-lbit4 8) (f-op-bit4 8))
-       (sequence ()
-           (set HI pc (mem HI (reg h-cr 9)))
-           (set (reg h-cr 9) (add HI (reg h-cr 9) (const 2)))
-              (if QI (eq BI sgtdisbit (const BI 0))
-                  (sequence ()
-                       (set HI (reg h-cr 10) (mem HI (reg h-cr 9)))
-                       (set (reg h-cr 9) (add HI (reg h-cr 9) (const 2)))
-                  )
-              )
-              (nop)
-           (set HI (reg h-cr 4) (mem HI (reg h-cr 9)))
-     	   (set (reg h-cr 9) (add HI (reg h-cr 9) (const 2)))
-       )
-       ()
-)
-
-;stack operation insn
-;******************************************************************
-; POP reg
-(dni pop "restore register from system stack"
-     ((PIPE OS) (IDOC MISC))
-     "pop $reg8"
-     (+ OP1_15 OP2_12 reg8)
-     (sequence ((HI tmp1))
-	   (set HI tmp1 (mem HI (reg h-cr 9)))
-	   (set (reg h-cr 9) (add HI (reg h-cr 9) (const 2)))         
-           (set HI reg8 tmp1)
-     )
-     ()
-)
-
-; PUSH reg
-(dni push "save register on system stack"
-     ((PIPE OS) (IDOC MISC))
-     "push $reg8"
-     (+ OP1_14 OP2_12 reg8)
-     (sequence ((HI tmp1))
-	   (set HI tmp1 reg8)
-	   (set (reg h-cr 9) (sub HI (reg h-cr 9) (const 2)))         
-           (set HI (mem HI (reg h-cr 9)) tmp1)
-     )
-     ()
-)
-
-;context switching insns
-; SCXT reg,#data16
-(dni scxti "Push word register on stack and update same with immediate data"
-     ((PIPE OS) (IDOC MISC))
-     "scxt $reg8,$hash$uimm16"
-     (+ OP1_12 OP2_6 reg8 uimm16)
-     (sequence ((HI tmp1) (HI tmp2))
-         (set HI tmp1 reg8)
-         (set HI tmp2 uimm16)
-         (sub HI (reg HI h-cr 9) (const 2))
-         (set HI (reg HI h-cr 9) tmp1)
-         (set HI reg8 tmp2)
-     )
-     ()
-)
-
-; SCXT reg,POF mem
-(dni scxtrpofm "mov memory to byte register"
-     ((PIPE OS) (IDOC MOVE))
-     "scxt $reg8,$pof$upof16"
-     (+ OP1_13 OP2_6 reg8 upof16)
-     (set QI reg8 (mem HI upof16))
-     ()
-)
-
-; SCXT regmem8,memgr8
-(dni scxtmg "Push word register on stack and update same with direct memory"
-     ((PIPE OS) (IDOC MISC))
-     "scxt $regmem8,$memgr8"
-     (+ OP1_13 OP2_6 regmem8 memgr8)
-     (sequence ((HI tmp1) (HI tmp2))
-         (set HI tmp1 regmem8)
-         (set HI tmp2 memgr8)
-         (sub HI (reg HI h-cr 9) (const 2))
-         (set HI (reg HI h-cr 9) tmp1)
-         (set HI regmem8 tmp2)
-     )
-     ()
-)
-
-; SCXT reg,mem
-(dni scxtm "Push word register on stack and update same with direct memory"
-     ((PIPE OS) (IDOC MISC))
-     "scxt $reg8,$memory"
-     (+ OP1_13 OP2_6 reg8 memory)
-     (sequence ((HI tmp1) (HI tmp2))
-         (set HI tmp1 reg8)
-         (set HI tmp2 memory)
-         (sub HI (reg HI h-cr 9) (const 2))
-         (set HI (reg HI h-cr 9) tmp1)
-         (set HI reg8 tmp2)
-     )
-     ()
-)
-
-;No operation
-; NOP 
-(dni nop "nop"
-     ((PIPE OS) (IDOC MISC))
-     "nop"
-     (+ OP1_12 OP2_12 (f-op-bit8 0))
-     ()
-     ()
-)
-
-;*********system control instructions *********************/
-
-(define-pmacro (sysctrl name insn opc1 opc2 op1 op2 op3)
-  (dni name 
-       (.str name "miscellaneous" )
-       ((PIPE OS) (IDOC MISC))
-       (.str insn )
-       (+ opc1 opc2 (f-op-lbit4 op1) (f-op-bit4 op2) (f-data8 op3) (f-op-bit8 op3))
-       ()
-       ()
-  )
-)
-(sysctrl srstm srst  OP1_11 OP2_7 4 8 183 )
-(sysctrl idlem idle  OP1_8 OP2_7 7 8 135)
-(sysctrl pwrdnm pwrdn  OP1_9 OP2_7 6 8 151)
-(sysctrl diswdtm diswdt  OP1_10 OP2_5 5 10 165)
-(sysctrl enwdtm enwdt  OP1_8 OP2_5 7 10 133)
-(sysctrl einitm einit  OP1_11 OP2_5 4 10 181)
-(sysctrl srvwdtm srvwdt  OP1_10 OP2_7 5 8 167 )
-
-;s/w brk
-; SBRK 
-(dni sbrk "sbrk"
-     ((PIPE OS) (IDOC MISC))
-     "sbrk"
-     (+ OP1_8 OP2_12 (f-op-bit8 0))
-     ()
-     ()
-)
-
-; atomic sequence
-; ATOMIC #irang2
-(dni atomic "begin atomic sequence"
-     ((PIPE OS) (IDOC SYSC))
-     "atomic $hash$uimm2"
-     (+ OP1_13 OP2_1 (f-op-lbit2 0) uimm2 (f-op-bit4 0))
-     (sequence ((HI count))
-	  (set HI count uimm2)
-          (cond HI
-  	    ((ne HI count (const 0))
-	    (sequence ()
-	       (set HI pc (add HI pc (const 2)))
-               (set HI count (sub HI count (const 1)))
-            ))
-          )
-          (set HI count (const 0))
-      )
-      ()
-)
-
-;extended register sequence
-; EXTR #irang2
-(dni extr "begin extended register sequence"
-     ((PIPE OS) (IDOC SYSC))
-     "extr $hash$uimm2"
-     (+ OP1_13 OP2_1 (f-op-lbit2 2) uimm2 (f-op-bit4 0))
-     (sequence ((HI count))
-	  (set HI count uimm2)
-          (cond HI
-  	    ((ne HI count (const 0))
-	    (sequence ()
-	       (set HI pc (add HI pc (const 2)))
-               (set HI count (sub HI count (const 1)))
-            ))
-          )
-          (set HI count (const 0))
-      )
-      ()
-)
-
-;extended page sequence
-; EXTP Rw,#irang2
-(dni extp "begin extended page sequence"
-     ((PIPE OS) (IDOC SYSC))
-     "extp $sr,$hash$uimm2"
-     (+ OP1_13 OP2_12 (f-op-lbit2 1) uimm2 sr)
-     (sequence ((HI count))
-	  (set HI count uimm2)
-          (cond HI
-  	    ((ne HI count (const 0))
-	    (sequence ()
-	       (set HI pc (add HI pc (const 2)))
-               (set HI count (sub HI count (const 1)))
-            ))
-          )
-          (set HI count (const 0))
-      )
-      ()
-)
-
-;extended page sequence
-; EXTP #pag10,#irang2
-(dni extp1 "begin extended page sequence"
-     ((PIPE OS) (IDOC SYSC))
-     "extp $hash$pagenum,$hash$uimm2"
-     (+ OP1_13 OP2_7 (f-op-lbit2 1) uimm2 (f-op-bit4 0) pagenum (f-qlobit 0) (f-qlobit2 0))
-     (sequence ((HI count))
-	  (set HI count uimm2)
-          (cond HI
-  	    ((ne HI count (const 0))
-	    (sequence ()
-	       (set HI pc (add HI pc (const 2)))
-               (set HI count (sub HI count (const 1)))
-            ))
-          )
-          (set HI count (const 0))
-      )
-      ()
-)
-
-; EXTP #pag10,#irang2
-(dni extpg1 "begin extended page sequence"
-     ((PIPE OS) (IDOC SYSC))
-     "extp $hash$pag$upag16,$hash$uimm2"
-     (+ OP1_13 OP2_7 (f-op-lbit2 1) uimm2 (f-op-bit4 0) upag16 )
-     (sequence ((HI count))
-	  (set HI count uimm2)
-          (cond HI
-  	    ((ne HI count (const 0))
-	    (sequence ()
-	       (set HI pc (add HI pc (const 2)))
-               (set HI count (sub HI count (const 1)))
-            ))
-          )
-          (set HI count (const 0))
-      )
-      ()
-)
-
-;extended page and register sequence
-; EXTPR Rw,#irang2
-(dni extpr "begin extended page and register sequence"
-     ((PIPE OS) (IDOC SYSC))
-     "extpr $sr,$hash$uimm2"
-     (+ OP1_13 OP2_12 (f-op-lbit2 3) uimm2 sr)
-     (sequence ((HI count))
-	  (set HI count uimm2)
-          (cond HI
-  	    ((ne HI count (const 0))
-	    (sequence ()
-	       (set HI pc (add HI pc (const 2)))
-               (set HI count (sub HI count (const 1)))
-            ))
-          )
-          (set HI count (const 0))
-      )
-      ()
-)
-
-;extended page and register sequence
-; EXTPR #pag10,#irang2
-(dni extpr1 "begin extended page sequence"
-     ((PIPE OS) (IDOC SYSC))
-     "extpr $hash$pagenum,$hash$uimm2"
-     (+ OP1_13 OP2_7 (f-op-lbit2 3) uimm2 (f-op-bit4 0) pagenum (f-qlobit 0) (f-qlobit2 0))
-     (sequence ((HI count))
-	  (set HI count uimm2)
-          (cond HI
-  	    ((ne HI count (const 0))
-	    (sequence ()
-	       (set HI pc (add HI pc (const 2)))
-               (set HI count (sub HI count (const 1)))
-            ))
-          )
-          (set HI count (const 0))
-      )
-      ()
-)
-
-;extended segment sequence
-; EXTS Rw,#irang2
-(dni exts "begin extended segment sequence"
-     ((PIPE OS) (IDOC SYSC))
-     "exts $sr,$hash$uimm2"
-     (+ OP1_13 OP2_12 (f-op-lbit2 0) uimm2 sr)
-     (sequence ((HI count))
-	  (set HI count uimm2)
-          (cond HI
-  	    ((ne HI count (const 0))
-	    (sequence ()
-	       (set HI pc (add HI pc (const 2)))
-               (set HI count (sub HI count (const 1)))
-            ))
-          )
-          (set HI count (const 0))
-      )
-      ()
-)
-
-;extended segment sequence
-; EXTS #seg8,#irang2
-(dni exts1 "begin extended segment sequence"
-     ((PIPE OS) (IDOC SYSC))
-     "exts $hash$seghi8,$hash$uimm2"
-     (+ OP1_13 OP2_7 (f-op-lbit2 0) uimm2 (f-op-bit4 0) seghi8 (f-op-bit8 0))
-     (sequence ((HI count))
-	  (set HI count uimm2)
-          (cond HI
-  	    ((ne HI count (const 0))
-	    (sequence ()
-	       (set HI pc (add HI pc (const 2)))
-               (set HI count (sub HI count (const 1)))
-            ))
-          )
-          (set HI count (const 0))
-      )
-      ()
-)
-
-;extended segment register sequence
-; EXTSR Rwm,#irang2
-(dni extsr "begin extended segment and register sequence"
-     ((PIPE OS) (IDOC SYSC))
-     "extsr $sr,$hash$uimm2"
-     (+ OP1_13 OP2_12 (f-op-lbit2 2) uimm2 sr)
-     (sequence ((HI count))
-	  (set HI count uimm2)
-          (cond HI
-  	    ((ne HI count (const 0))
-	    (sequence ()
-	       (set HI pc (add HI pc (const 2)))
-               (set HI count (sub HI count (const 1)))
-            ))
-          )
-          (set HI count (const 0))
-      )
-      ()
-)
-
-;extended segment register sequence
-; EXTSR #pag10,#irang2
-(dni extsr1 "begin extended segment and register sequence"
-     ((PIPE OS) (IDOC SYSC))
-     "extsr $hash$seghi8,$hash$uimm2"
-     (+ OP1_13 OP2_7 (f-op-lbit2 2) uimm2 (f-op-bit4 0) seghi8 (f-op-bit8 0))
-     (sequence ((HI count))
-	  (set HI count uimm2)
-          (cond HI
-  	    ((ne HI count (const 0))
-	    (sequence ()
-	       (set HI pc (add HI pc (const 2)))
-               (set HI count (sub HI count (const 1)))
-            ))
-          )
-          (set HI count (const 0))
-      )
-      ()
-)
-
-;prioritize register
-;PRIOR Rwn,Rwm
-(dni prior "add registers"
-     ((PIPE OS) (IDOC ALU))
-     "prior $dr,$sr"
-     (+ OP1_2 OP2_11 dr sr)
-     (sequence ((HI count) (HI tmp1) (HI tmp2))
-	  (set HI count (const 0))
-	  (set HI tmp1 sr)
-	  (set HI tmp2 (and tmp1 (const 32768)))
-          (cond HI
-  	    ((ne HI tmp2 (const 1)) (ne HI sr (const 0))
-	       (sll HI tmp1 (const 1))
-               (set HI tmp2 (and tmp1 (const 32768)))
-               (set HI count (add HI count (const 1)))
-            )
-           )        
-           (set HI dr count)
-      )
-      ()
-)
-
-
-;bit instructions
-;******************************************************************
-;bit clear
-(define-pmacro (bclear name insn opc1)
-  (dni name
-     (.str name "bit clear" )
-     ((PIPE OS) (IDOC ALU))
-     (.str insn " $reg8$dot$qbit")
-     (+ opc1 OP2_14 reg8)
-     (sequence ((HI tmp1) (HI tmp2))
-     (set tmp2 (const 1))
-     (set tmp1 reg8)
-     (sll tmp2 qbit)
-     (inv tmp2)
-     (set BI tmp1(and tmp1 tmp2))
-     (set HI reg8 tmp1))
-     ()
-  )
-)
-
-;clear direct bit
-(dni bclr18 "bit logical MOVN"
-     ((PIPE OS) (IDOC ALU))
-     "bclr $RegNam"
-     (+ OP1_11 OP2_14 RegNam)
-     (sequence ((HI tmp1) (HI tmp2))
-     (set tmp2 (const 1))
-     (set tmp1 reg8)
-     (sll tmp2 qbit)
-     (inv tmp2)
-     (set BI tmp1(and tmp1 tmp2))
-     (set HI reg8 tmp1))
-     ()
-)
-
-
-(bclear bclr0 bclr  QBIT_0 )
-(bclear bclr1 bclr  QBIT_1 )
-(bclear bclr2 bclr  QBIT_2 )
-(bclear bclr3 bclr  QBIT_3 )
-(bclear bclr4 bclr  QBIT_4 )
-(bclear bclr5 bclr  QBIT_5 )
-(bclear bclr6 bclr  QBIT_6 )
-(bclear bclr7 bclr  QBIT_7 )
-(bclear bclr8 bclr  QBIT_8 )
-(bclear bclr9 bclr  QBIT_9 )
-(bclear bclr10 bclr  QBIT_10 )
-(bclear bclr11 bclr  QBIT_11 )
-(bclear bclr12 bclr  QBIT_12 )
-(bclear bclr13 bclr  QBIT_13 )
-(bclear bclr14 bclr  QBIT_14 )
-(bclear bclr15 bclr  QBIT_15 )
-
-;set direct bit
-(dni bset19 "bit logical MOVN"
-     ((PIPE OS) (IDOC ALU))
-     "bset $RegNam"
-     (+ OP1_11 OP2_15 RegNam)
-     (sequence ((HI tmp1) (HI tmp2))
-     (set tmp2 (const 1))
-     (set tmp1 reg8)
-     (sll tmp2 qbit)
-     (set BI tmp1(or tmp1 tmp2))
-     (set HI reg8 tmp1))
-     ()
-)
-
-;bit set
-(define-pmacro (bitset name insn opc1)
-  (dni name
-     (.str name "bit set" )
-     ((PIPE OS) (IDOC ALU))
-     (.str insn " $reg8$dot$qbit")
-     (+ opc1 OP2_15 reg8)
-     (sequence ((HI tmp1) (HI tmp2))
-     (set tmp2 (const 1))
-     (set tmp1 reg8)
-     (sll tmp2 qbit)
-     (set BI tmp1(or tmp1 tmp2))
-     (set HI reg8 tmp1))
-     ()
-  )
-)
-
-
-(bitset bset0 bset  QBIT_0 )
-(bitset bset1 bset  QBIT_1 )
-(bitset bset2 bset  QBIT_2 )
-(bitset bset3 bset  QBIT_3 )
-(bitset bset4 bset  QBIT_4 )
-(bitset bset5 bset  QBIT_5 )
-(bitset bset6 bset  QBIT_6 )
-(bitset bset7 bset  QBIT_7 )
-(bitset bset8 bset  QBIT_8 )
-(bitset bset9 bset  QBIT_9 )
-(bitset bset10 bset  QBIT_10 )
-(bitset bset11 bset  QBIT_11 )
-(bitset bset12 bset  QBIT_12 )
-(bitset bset13 bset  QBIT_13 )
-(bitset bset14 bset  QBIT_14 )
-(bitset bset15 bset  QBIT_15 )
-
-;mov direct bit
-;BMOV bitaddrZ.z,bitaddrQ.q
-(dni bmov "bit logical MOV"
-     ((PIPE OS) (IDOC ALU))
-     "bmov $reghi8$dot$qhibit,$reg8$dot$qlobit"
-     (+ OP1_4 OP2_10 reg8 reghi8 qhibit qlobit)
-     (sequence ((HI tmp1) (HI tmp2) (HI tmp3) (HI tmp4))
-     (set HI tmp1 reghi8)
-     (set HI tmp2 reg8)
-     (set tmp3 (const 1))
-     (set tmp4 (const 1))
-     (sll tmp3 qlobit)
-     (sll tmp4 qhibit)
-     (and tmp1 tmp3)
-     (and tmp2 tmp4)
-     (set BI tmp1 tmp2)
-     (set HI reghi8 tmp1)
-     (set HI reg8 tmp2))
-     ()
-)
-
-;movn direct bit
-;BMOVN bitaddrZ.z,bitaddrQ.q
-(dni bmovn "bit logical MOVN"
-     ((PIPE OS) (IDOC ALU))
-     "bmovn $reghi8$dot$qhibit,$reg8$dot$qlobit"
-     (+ OP1_3 OP2_10 reg8 reghi8 qhibit qlobit)
-     (sequence ((HI tmp1) (HI tmp2) (HI tmp3) (HI tmp4))
-     (set HI tmp1 reghi8)
-     (set HI tmp2 reg8)
-     (set tmp3 (const 1))
-     (set tmp4 (const 1))
-     (sll tmp3 qlobit)
-     (sll tmp4 qhibit)
-     (and tmp1 tmp3)
-     (and tmp2 tmp4)
-     (inv HI tmp2)
-     (set BI tmp1 tmp2)
-     (set HI reghi8 tmp1)
-     (set HI reg8 tmp2))
-     ()
-)
-
-;and direct bit
-;BAND bitaddrZ.z,bitaddrQ.q
-(dni band "bit logical AND"
-     ((PIPE OS) (IDOC ALU))
-     "band $reghi8$dot$qhibit,$reg8$dot$qlobit"
-     (+ OP1_6 OP2_10 reg8 reghi8 qhibit qlobit)
-     (sequence ((HI tmp1) (HI tmp2) (HI tmp3) (HI tmp4))
-     (set HI tmp1 reghi8)
-     (set HI tmp2 reg8)
-     (set tmp3 (const 1))
-     (set tmp4 (const 1))
-     (sll tmp3 qlobit)
-     (sll tmp4 qhibit)
-     (and tmp1 tmp3)
-     (and tmp2 tmp4)
-     (set BI tmp1(and tmp1 tmp2))
-     (set HI reghi8 tmp1)
-     (set HI reg8 tmp2))
-     ()
-)
-
-;or direct bit
-;BOR bitaddrZ.z,bitaddrQ.q
-(dni bor "bit logical OR"
-     ((PIPE OS) (IDOC ALU))
-     "bor $reghi8$dot$qhibit,$reg8$dot$qlobit"
-     (+ OP1_5 OP2_10 reg8 reghi8 qhibit qlobit)
-     (sequence ((HI tmp1) (HI tmp2) (HI tmp3) (HI tmp4))
-     (set HI tmp1 reghi8)
-     (set HI tmp2 reg8)
-     (set tmp3 (const 1))
-     (set tmp4 (const 1))
-     (sll tmp3 qlobit)
-     (sll tmp4 qhibit)
-     (and tmp1 tmp3)
-     (and tmp2 tmp4)
-     (set BI tmp1(or tmp1 tmp2))
-     (set HI reghi8 tmp1)
-     (set HI reg8 tmp2))
-     ()
-)
-
-;xor direct bit
-;BXOR bitaddrZ.z,bitaddrQ.q
-(dni bxor "bit logical XOR"
-     ((PIPE OS) (IDOC ALU))
-     "bxor $reghi8$dot$qhibit,$reg8$dot$qlobit"
-     (+ OP1_7 OP2_10 reg8 reghi8 qhibit qlobit)
-     (sequence ((HI tmp1) (HI tmp2) (HI tmp3) (HI tmp4))
-     (set HI tmp1 reghi8)
-     (set HI tmp2 reg8)
-     (set tmp3 (const 1))
-     (set tmp4 (const 1))
-     (sll tmp3 qlobit)
-     (sll tmp4 qhibit)
-     (and tmp1 tmp3)
-     (and tmp2 tmp4)
-     (set BI tmp1(xor tmp1 tmp2))
-     (set HI reghi8 tmp1)
-     (set HI reg8 tmp2))
-     ()
-)
-
-;cmp direct bit to bit
-;BCMP bitaddrZ.z,bitaddrQ.q
-(dni bcmp "bit to bit compare"
-     ((PIPE OS) (IDOC ALU))
-     "bcmp $reghi8$dot$qhibit,$reg8$dot$qlobit"
-     (+ OP1_2 OP2_10 reg8 reghi8 qhibit qlobit)
-     (sequence ((HI tmp1) (HI tmp2) (HI tmp3) (HI tmp4))
-     (set HI tmp1 reghi8)
-     (set HI tmp2 reg8)
-     (set tmp3 (const 1))
-     (set tmp4 (const 1))
-     (sll tmp3 qlobit)
-     (sll tmp4 qhibit)
-     (and tmp1 tmp3)
-     (and tmp2 tmp4)
-     (set BI tmp1(xor tmp1 tmp2))
-     (set HI reghi8 tmp1)
-     (set HI reg8 tmp2))
-     ()
-)
-
-;bit field low byte
-;BFLDL op1,op2,op3
-(dni bfldl "bit field low byte"
-     ((PIPE OS) (IDOC MOVE))
-     "bfldl $reg8,$hash$mask8,$hash$datahi8"
-     (+ OP1_0 OP2_10 reg8 mask8 datahi8)
-     (sequence ((HI tmp1) (QI tmp2) (QI tmp3))
-     (set HI tmp1 reg8)
-     (set QI tmp2 mask8)
-     (set QI tmp3 datahi8)
-     (inv QI tmp2)
-     (set HI tmp1 (and tmp1 tmp2))
-     (set HI tmp1 (or tmp1 tmp3))
-     (set HI reg8 tmp1)
-     )
-     ()
-)
-
-;bit field high byte
-;BFLDH op1,op2,op3
-(dni bfldh "bit field high byte"
-     ((PIPE OS) (IDOC MOVE))
-     "bfldh $reg8,$hash$masklo8,$hash$data8"
-     (+ OP1_1 OP2_10 reg8 masklo8 data8)
-     (sequence ((HI tmp1) (HI tmp2) (HI tmp3))
-     	     (set HI tmp1 reg8)
-	     (set QI tmp2 masklo8)
-	     (set HI tmp3 data8)
-	     (sll tmp2 (const 8))
-	     (inv HI tmp2)
-	     (sll tmp3 (const 8))
-	     (set HI tmp1 (and tmp1 tmp2))
-	     (set HI tmp1 (or tmp1 tmp3))
-	     (set HI reg8 tmp1)
-     )
-     ()
-)
-
-;/**********compare instructions******************
-
-;Compare register
-;CMP Rwn,Rwm
-(dni cmpr "compare two registers"
-     ((PIPE OS) (IDOC CMP))
-     "cmp $src1,$src2"
-     (+ OP1_4 OP2_0 src1 src2)
-     (set condbit (lt HI src1 src2))
-     ()
-)
-
-;Compare byte register
-;CMPB Rbn,Rbm
-(dni cmpbr "compare two byte registers"
-     ((PIPE OS) (IDOC CMP))
-     "cmpb $drb,$srb"
-     (+ OP1_4 OP2_1 drb srb)
-     (set condbit (lt QI drb srb))
-     ()
-)
-
-(define-pmacro (cmp1 name insn opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "compare" )
-       ((PIPE OS) (IDOC CMP))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op1 (f-op-bit1 0) op2)
-       (set condbit (lt mode op1 op2))
-       ()
-  )
-)
-(cmp1 cmpri cmp OP1_4 OP2_8 src1 uimm3 HI)
-(cmp1 cmpbri cmpb OP1_4 OP2_9 drb uimm3 QI)
-
-; CMP Rwn,#data16
-(dni cmpi "compare"
-     ((PIPE OS) (IDOC CMP))
-     "cmp $reg8,$hash$uimm16"
-     (+ OP1_4 OP2_6 reg8 uimm16)
-     (set condbit (lt HI reg8 uimm16))
-     ()
-)
-
-; CMPB reg,#data8
-(dni cmpbi "compare"
-     ((PIPE OS) (IDOC CMP))
-     "cmpb $regb8,$hash$uimm8"
-     (+ OP1_4 OP2_7 regb8 uimm8 (f-op-bit8 0))
-     (set condbit (lt QI regb8 uimm8))
-     ()
-)
-
-;compare reg and indirect memory
-(define-pmacro (cmp2 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "compare" )
-       ((PIPE OS) (IDOC CMP))
-       (.str insn " $"op1 ",[$"op2"]")
-       (+ opc1 opc2 op1 (f-op-bit2 2) op2)
-       (set condbit (lt mode op1 op2))
-       ()
-  )
-)
-(cmp2 cmpr2 cmp OP1_4 OP2_8 dr sr2 HI)
-(cmp2 cmpbr2 cmpb OP1_4 OP2_9 drb sr2 QI)
-
-;compare register and indirect memory post increment
-(define-pmacro (cmp3 name insn opc1 opc2 op1 op2 mode)
-  (dni name
-       (.str name "compare" )
-       ((PIPE OS) (IDOC CMP))
-       (.str insn " $"op1 ",[$"op2"+]")
-       (+ opc1 opc2 op1 (f-op-bit2 3) op2)
-       (sequence ()
-          (set condbit (lt mode op1 op2))
-   	  (set HI op2 (add HI op2 (const 2)))
-       )
-       ()
-  )
-)
-(cmp3 cmp2i cmp OP1_4 OP2_8 dr sr2 HI)
-(cmp3 cmpb2i cmpb OP1_4 OP2_9 drb sr2 QI)
-
-;compare register and direct memory
-(define-pmacro (cmp4 name insn opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "compare" )
-       ((PIPE OS) (IDOC CMP))
-       (.str insn " $"op1 ",$pof$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set condbit (lt HI op1 (mem HI op2)))
-       ()
-  )
-)
-(cmp4 cmp04 cmp OP1_4 OP2_2 reg8 upof16 HI)
-(cmp4 cmpb4 cmpb OP1_4 OP2_3 regb8 upof16 QI)
-
-;compare register and direct memory
-(define-pmacro (cmp4 name insn opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "compare" )
-       ((PIPE OS) (IDOC CMP))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set condbit (lt HI op1 (mem HI op2)))
-       ()
-  )
-)
-(cmp4 cmp004 cmp OP1_4 OP2_2 regmem8 memgr8 HI)
-(cmp4 cmp0004 cmp OP1_4 OP2_2 reg8 memory HI)
-(cmp4 cmpb04 cmpb OP1_4 OP2_3 regbmem8 memgr8 QI)
-(cmp4 cmpb004 cmpb OP1_4 OP2_3 regb8 memory QI)
-
-;compare register and immediate
-(define-pmacro (cmp5 name insn opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "compare" )
-       ((PIPE OS) (IDOC CMP))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op2 op1)
-       (sequence ()
-            (set condbit (lt HI op1 op2))
-	    (set mode op1 (sub HI op1 (const 1)))
-       )     
-       ()
-  )
-)
-(cmp5 cmpd1ri cmpd1  OP1_10 OP2_0 sr uimm4 HI)
-(cmp5 cmpd2ri cmpd2  OP1_11 OP2_0 sr uimm4 HI)
-(cmp5 cmpi1ri cmpi1  OP1_8 OP2_0 sr uimm4 HI)
-(cmp5 cmpi2ri cmpi2  OP1_9 OP2_0 sr uimm4 HI)
-(cmp5 cmpd1rim cmpd1  OP1_10 OP2_6 reg8 uimm16 HI)
-(cmp5 cmpd2rim cmpd2  OP1_11 OP2_6 reg8 uimm16 HI)
-(cmp5 cmpi1rim cmpi1  OP1_8 OP2_6 reg8 uimm16 HI)
-(cmp5 cmpi2rim cmpi2  OP1_9 OP2_6 reg8 uimm16 HI)
-
-;compare register and direct memory
-(define-pmacro (cmp6 name insn opc1 opc2 op1 op2 mode )
-  (dni name 
-       (.str name "compare" )
-       ((PIPE OS) (IDOC CMP))
-       (.str insn " $"op1 ",$pof$"op2)
-       (+ opc1 opc2 op1 op2)
-       (sequence ()
-            (set condbit (lt HI op1 (mem HI op2)))
-	    (set mode op1 (sub HI op1 (const 1)))
-       )    
-       ()
-  )
-)
-(cmp6 cmpd1rp cmpd1  OP1_10 OP2_2 reg8 upof16 HI )
-(cmp6 cmpd2rp cmpd2  OP1_11 OP2_2 reg8 upof16 HI )
-(cmp6 cmpi1rp cmpi1  OP1_8 OP2_2 reg8 upof16 HI )
-(cmp6 cmpi2rp cmpi2  OP1_9 OP2_2 reg8 upof16 HI )
-
-;compare register and direct memory
-(define-pmacro (cmp7 name insn opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "compare" )
-       ((PIPE OS) (IDOC CMP))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (sequence ()
-            (set condbit (lt HI op1 (mem HI op2)))
-	    (set mode op1 (sub HI op1 (const 1)))
-       )    
-       ()
-  )
-)
-(cmp7 cmpd1rm cmpd1  OP1_10 OP2_2 regmem8 memgr8 HI)
-(cmp7 cmpd2rm cmpd2  OP1_11 OP2_2 regmem8 memgr8 HI)
-(cmp7 cmpi1rm cmpi1  OP1_8 OP2_2 regmem8 memgr8 HI)
-(cmp7 cmpi2rm cmpi2  OP1_9 OP2_2 regmem8 memgr8 HI)
-(cmp7 cmpd1rmi cmpd1  OP1_10 OP2_2 reg8 memory HI)
-(cmp7 cmpd2rmi cmpd2  OP1_11 OP2_2 reg8 memory HI)
-(cmp7 cmpi1rmi cmpi1  OP1_8 OP2_2 reg8 memory HI)
-(cmp7 cmpi2rmi cmpi2  OP1_9 OP2_2 reg8 memory HI)
-
-
-;Shift and rotate insns
-;****************************************************************
-(define-pmacro (shift name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "shift" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$"op2)
-       (+ opc1 opc2 op1 op2)
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-(shift shlr shl sll OP1_4 OP2_12 dr sr HI)
-(shift shrr shr srl OP1_6 OP2_12 dr sr HI)
-(shift rolr rol rol OP1_0 OP2_12 dr sr HI)
-(shift rorr ror ror OP1_2 OP2_12 dr sr HI)
-(shift ashrr ashr sra OP1_10 OP2_12 dr sr HI)
-
-(define-pmacro (shift1 name insn insn1 opc1 opc2 op1 op2 mode)
-  (dni name 
-       (.str name "shift" )
-       ((PIPE OS) (IDOC ALU))
-       (.str insn " $"op1 ",$hash$"op2)
-       (+ opc1 opc2 op2 op1)
-       (set mode op1 (insn1 mode op1 op2))
-       ()
-  )
-)
-(shift1 shlri shl sll OP1_5 OP2_12 sr uimm4 HI)
-(shift1 shrri shr srl OP1_7 OP2_12 sr uimm4 HI)
-(shift1 rolri rol rol OP1_1 OP2_12 sr uimm4 HI)
-(shift1 rorri ror ror OP1_3 OP2_12 sr uimm4 HI)
-(shift1 ashrri ashr sra OP1_11 OP2_12 sr uimm4 HI)
diff -rupN binutils-2.19.1-original/cgen/cpu/xc16x.opc binutils-2.19.1/cgen/cpu/xc16x.opc
--- binutils-2.19.1-original/cgen/cpu/xc16x.opc	2007-07-05 05:49:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/xc16x.opc	1969-12-31 19:00:00.000000000 -0500
@@ -1,245 +0,0 @@
-/* XC16X opcode support.  -*- C -*-
-
-   Copyright 2006, 2007 Free Software Foundation, Inc.
-
-   Contributed by KPIT Cummins Infosystems Ltd.; developed under contract 
-   from Infineon Systems, GMBH , Germany.
-
-   This file is part of the GNU Binutils.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
-   02110-1301, USA.  */
-
-
-/* This file is an addendum to xc16x.cpu.  Heavy use of C code isn't
-   appropriate in .cpu files, so it resides here.  This especially applies
-   to assembly/disassembly where parsing/printing can be quite involved.
-   Such things aren't really part of the specification of the cpu, per se,
-   so .cpu files provide the general framework and .opc files handle the
-   nitty-gritty details as necessary.
-
-   Each section is delimited with start and end markers.
-
-   <arch>-opc.h additions use: "-- opc.h"
-   <arch>-opc.c additions use: "-- opc.c"
-   <arch>-asm.c additions use: "-- asm.c"
-   <arch>-dis.c additions use: "-- dis.c"
-   <arch>-ibd.h additions use: "-- ibd.h"  */
-
-/* -- opc.h */
-
-#define CGEN_DIS_HASH_SIZE 8
-#define CGEN_DIS_HASH(buf,value) (((* (unsigned char*) (buf)) >> 3) % CGEN_DIS_HASH_SIZE)
-
-/* -- */
-
-/* -- opc.c */
-                                                                                
-/* -- */
-
-/* -- asm.c */
-/* Handle '#' prefixes (i.e. skip over them).  */
-
-static const char *
-parse_hash (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	    const char **strp,
-	    int opindex ATTRIBUTE_UNUSED,
-	    long *valuep ATTRIBUTE_UNUSED)
-{
-  if (**strp == '#')
-    {
-      ++*strp;
-      return NULL;
-    }
-  return _("Missing '#' prefix");
-}
-
-/* Handle '.' prefixes (i.e. skip over them).  */
-
-static const char *
-parse_dot (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	   const char **strp,
-	   int opindex ATTRIBUTE_UNUSED,
-	   long *valuep ATTRIBUTE_UNUSED)
-{
-  if (**strp == '.')
-    {
-      ++*strp;
-      return NULL;
-    }
-  return _("Missing '.' prefix");
-}
-
-/* Handle 'pof:' prefixes (i.e. skip over them).  */
-
-static const char *
-parse_pof (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	   const char **strp,
-	   int opindex ATTRIBUTE_UNUSED,
-	   long *valuep ATTRIBUTE_UNUSED)
-{
-  if (strncasecmp (*strp, "pof:", 4) == 0)
-    {
-      *strp += 4;
-      return NULL;
-    }
-  return _("Missing 'pof:' prefix");  
-}
-
-/* Handle 'pag:' prefixes (i.e. skip over them).  */
-
-static const char *
-parse_pag (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	   const char **strp,
-	   int opindex ATTRIBUTE_UNUSED,
-	   long *valuep ATTRIBUTE_UNUSED)
-{
-  if (strncasecmp (*strp, "pag:", 4) == 0)
-    {
-      *strp += 4;
-      return NULL;
-    }
-  return _("Missing 'pag:' prefix");
-}
-
-/* Handle 'sof' prefixes (i.e. skip over them).  */
-
-static const char *
-parse_sof (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	   const char **strp,
-	   int opindex ATTRIBUTE_UNUSED,
-	   long *valuep ATTRIBUTE_UNUSED)
-{
-  if (strncasecmp (*strp, "sof:", 4) == 0)
-    {
-      *strp += 4;
-      return NULL;
-    }
-  return _("Missing 'sof:' prefix");
-}
-
-/* Handle 'seg' prefixes (i.e. skip over them).  */
-
-static const char *
-parse_seg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	   const char **strp,
-	   int opindex ATTRIBUTE_UNUSED,
-	   long *valuep ATTRIBUTE_UNUSED)
-{
-  if (strncasecmp (*strp, "seg:", 4) == 0)
-    {
-      *strp += 4;
-      return NULL;
-    }
-  return _("Missing 'seg:' prefix");
-}
-/* -- */
-
-/* -- dis.c */
-
-#define CGEN_PRINT_NORMAL(cd, info, value, attrs, pc, length)	\
-  do								\
-    {								\
-      if (CGEN_BOOL_ATTR ((attrs), CGEN_OPERAND_DOT_PREFIX))	\
-        info->fprintf_func (info->stream, ".");			\
-      if (CGEN_BOOL_ATTR ((attrs), CGEN_OPERAND_POF_PREFIX))	\
-        info->fprintf_func (info->stream, "#pof:");		\
-      if (CGEN_BOOL_ATTR ((attrs), CGEN_OPERAND_PAG_PREFIX))	\
-        info->fprintf_func (info->stream, "#pag:");		\
-    }								\
-  while (0)
-
-/* Print a 'pof:' prefix to an operand.  */
-
-static void
-print_pof (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	   void * dis_info ATTRIBUTE_UNUSED,
-	   long value ATTRIBUTE_UNUSED,
-	   unsigned int attrs ATTRIBUTE_UNUSED,
-	   bfd_vma pc ATTRIBUTE_UNUSED,
-	   int length ATTRIBUTE_UNUSED)
-{
-}
-
-/* Print a 'pag:' prefix to an operand.  */
-
-static void
-print_pag (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	   void * dis_info ATTRIBUTE_UNUSED,
-	   long value ATTRIBUTE_UNUSED,
-	   unsigned int attrs ATTRIBUTE_UNUSED,
-	   bfd_vma pc ATTRIBUTE_UNUSED,
-	   int length ATTRIBUTE_UNUSED)
-{
-}
-
-/* Print a 'sof:' prefix to an operand.  */
-
-static void
-print_sof (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	   void * dis_info,
-	   long value ATTRIBUTE_UNUSED,
-	   unsigned int attrs ATTRIBUTE_UNUSED,
-	   bfd_vma pc ATTRIBUTE_UNUSED,
-	   int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  info->fprintf_func (info->stream, "sof:");
-}
-
-/* Print a 'seg:' prefix to an operand.  */
-
-static void
-print_seg (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	   void * dis_info,
-	   long value ATTRIBUTE_UNUSED,
-	   unsigned int attrs ATTRIBUTE_UNUSED,
-	   bfd_vma pc ATTRIBUTE_UNUSED,
-	   int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  info->fprintf_func (info->stream, "seg:");
-}
-
-/* Print a '#' prefix to an operand.  */
-
-static void
-print_hash (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	    void * dis_info,
-	    long value ATTRIBUTE_UNUSED,
-	    unsigned int attrs ATTRIBUTE_UNUSED,
-	    bfd_vma pc ATTRIBUTE_UNUSED,
-	    int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  info->fprintf_func (info->stream, "#");
-}
-
-/* Print a '.' prefix to an operand.  */
-
-static void
-print_dot (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	   void * dis_info ATTRIBUTE_UNUSED,
-	   long value ATTRIBUTE_UNUSED,
-	   unsigned int attrs ATTRIBUTE_UNUSED,
-	   bfd_vma pc ATTRIBUTE_UNUSED,
-	   int length ATTRIBUTE_UNUSED)
-{
-}
-
-/* -- */
diff -rupN binutils-2.19.1-original/cgen/cpu/xstormy16.cpu binutils-2.19.1/cgen/cpu/xstormy16.cpu
--- binutils-2.19.1-original/cgen/cpu/xstormy16.cpu	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/xstormy16.cpu	1969-12-31 19:00:00.000000000 -0500
@@ -1,1944 +0,0 @@
-
-; -*- Scheme -*-
-; Copyright 2011 Free Software Foundation, Inc.
-;
-; Contributed by Red Hat Inc;
-;
-; This file is part of the GNU Binutils.
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 3 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-; MA 02110-1301, USA.
-
-(include "simplify.inc")
-
-(define-arch
-  (name xstormy16)
-  (comment "Xstormy16 architecture")
-  (insn-lsb0? #f)
-  (machs xstormy16)
-  (isas xstormy16)
-)
-
-(define-isa
-  (name xstormy16)
-  (comment "Xstormy16 instruction set")
-  (default-insn-word-bitsize 32)
-  (default-insn-bitsize 32)
-  ; FIXME base-insn-bitsize should be 16 too, but at present CGEN has
-  ; no support for instruction sets with opcode bits past
-  ; base-insn-bitsize, so we must set it to at least 20.
-  (base-insn-bitsize 32)
-)
-
-(define-cpu
-  (name xstormy16)
-  (comment "Xstormy16 CPU core")
-  (endian little)
-  (insn-endian little)
-  (insn-chunk-bitsize 16)
-  (word-bitsize 32)
-)
-
-(define-mach
-  (name xstormy16)
-  (comment "Xstormy16 CPU core")
-  (cpu xstormy16)
-  (isas xstormy16)
-)
-
-(define-model
-  (name xstormy16)
-  (comment "Xstormy16 CPU core")
-  (unit u-exec "Execution Unit" ()
-	1 1 ; issue done
-	() () () ())
-)
-
-; IDOC attribute for instruction documentation.
-
-(define-attr
-  (for insn)
-  (type enum)
-  (name IDOC)
-  (comment "insn kind for documentation")
-  (attrs META)
-  (values
-   (MEM - () "Memory")
-   (ALU - () "ALU")
-   (FPU - () "FPU")
-   (BR - () "Branch")
-   (PRIV - () "Priviledged")
-   (MISC - () "Miscellaneous")
-  )
-)
-
-; Hardware elements.
-
-(define-hardware
-  (name h-pc)
-  (comment "program counter")
-  (attrs PC)
-  (type pc)
-  (set (newval) (c-call "h_pc_set_handler" newval))
-)
-
-(define-keyword
-  (name gr-names)
-  (print-name h-gr)
-  (values (r0 0) (r1 1) (r2 2) (r3 3)
-	  (r4 4) (r5 5) (r6 6) (r7 7)
-	  (r8 8) (r9 9) (r10 10) (r11 11)
-	  (r12 12) (r13 13) (r14 14) (r15 15)
-	  (psw 14) (sp 15)))
-
-(define-keyword
-  (name gr-Rb-names)
-  (print-name h-Rbj)
-  (values (r8 0) (r9 1) (r10 2) (r11 3)
-	  (r12 4) (r13 5) (r14 6) (r15 7)
-	  (psw 6) (sp 7)))
-
-(define-hardware
-  (name h-gr)
-  (comment "registers")
-  (type register WI (16))
-  (indices extern-keyword gr-names)
-  (get (index) (and #xFFFF (raw-reg h-gr index)))
-  (set (index newval) (c-call "h_gr_set_handler" index newval))
-)
-
-(define-hardware
-  (name h-Rb)
-  (comment "Rb registers")
-  (attrs VIRTUAL)
-  (type register SI(8))
-  (indices extern-keyword gr-Rb-names)
-  (get (index) (reg h-gr (add index 8)))
-  (set (index newval) (set (reg h-gr (add index 8)) newval))
-)
-
-(define-hardware
-  (name h-Rbj)
-  (comment "Rbj registers")
-  (attrs VIRTUAL)
-  (type register SI(2))
-  (indices extern-keyword gr-Rb-names)
-  (get (index) (reg h-gr (add index 8)))
-  (set (index newval) (set (reg h-gr (add index 8)) newval))
-)
-
-(define-hardware
-  (name h-Rpsw)
-  (comment "Register number field of the PSW")
-  (attrs VIRTUAL)
-  (type register WI)
-  (get () (and #xF (srl psw 12)))
-  (set (newval) (set psw (or (and psw #xFFF)
-			     (sll HI newval 12)))))
-
-(define-pmacro (define-psw-field fnam hnam index)
-  (define-hardware
-    (name hnam)
-    (attrs VIRTUAL)
-    (type register SI)
-    (get () (and 1 (srl psw index)))
-    (set (newval) (set psw (or (and psw (inv (sll HI 1 index)))
-			       (sll HI newval index)))))
-  ;(dnop fnam "" (SEM-ONLY) hnam f-nil)
-)
-(define-psw-field psw-z8  h-z8   0)
-(dnop psw-z8 "" (SEM-ONLY) h-z8 f-nil)
-(define-psw-field psw-z16 h-z16  1)
-(dnop psw-z16 "" (SEM-ONLY) h-z16 f-nil)
-(define-psw-field psw-cy  h-cy   2)
-(dnop psw-cy "" (SEM-ONLY) h-cy f-nil)
-(define-psw-field psw-hc  h-hc   3)
-(dnop psw-hc "" (SEM-ONLY) h-hc f-nil)
-(define-psw-field psw-ov  h-ov   4)
-(dnop psw-ov "" (SEM-ONLY) h-ov f-nil)
-(define-psw-field psw-pt  h-pt   5)
-(dnop psw-pt "" (SEM-ONLY) h-pt f-nil)
-(define-psw-field psw-s   h-s    6)
-(dnop psw-s  "" (SEM-ONLY) h-s  f-nil)
-
-(define-hardware
-  (name h-branchcond)
-  (comment "Condition of a branch instruction")
-  (type immediate (UINT 4))
-  (values keyword "" 
-	  (("ge" 0) ("nc" 1) ("lt" 2) ("c" 3)
-	   ("gt" 4) ("hi" 5) ("le" 6) ("ls" 7)
-	   ("pl" 8) ("nv" 9) ("mi" 10) ("v" 11)
-	   ("nz.b" 12) ("nz" 13) ("z.b" 14) ("z" 15)))
-)
-
-(define-hardware
-  (name h-wordsize)
-  (comment "Data size")
-  (type immediate (UINT 1))
-  (values keyword "" ((".b" 0) (".w" 1) ("" 1)))
-)
-	
-
-; Instruction fields, and the corresponding operands.
-; Register fields
-
-(dnf f-Rd "general register destination" ()  12 4)
-(dnop Rd "general register destination" ()  h-gr f-Rd)
-
-(dnf f-Rdm "general register destination" ()  13 3)
-(dnop Rdm "general register destination" ()  h-gr f-Rdm)
-
-(dnf f-Rm "general register for memory" ()  4 3)
-(dnop Rm "general register for memory" ()  h-gr f-Rm)
-
-(dnf f-Rs  "general register source" ()  8 4)
-(dnop Rs "general register source" ()  h-gr f-Rs)
-
-(dnf f-Rb  "base register" ()  17 3)
-(dnop Rb "base register" ()  h-Rb f-Rb)
-
-(dnf f-Rbj "base register for jump" () 11 1)
-(dnop Rbj "base register for jump" () h-Rbj f-Rbj)
-
-; Main opcodes in 4 bit chunks
-
-(dnf f-op1 "opcode" ()  0 4)
-(define-normal-insn-enum insn-op1 "insn op enums" () OP1_ f-op1
- ( "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" ))
-
-(dnf f-op2 "opcode" ()  4 4)
-(define-normal-insn-enum insn-op2 "insn op enums" () OP2_ f-op2
- ( "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" ))
-(dnop bcond2 "branch condition opcode" () h-branchcond f-op2)
-
-(dnf f-op2a "opcode" ()  4 3)
-(define-normal-insn-enum insn-op2a "insn op enums" () OP2A_ f-op2a
- ( "0" "2" "4" "6" "8" "A" "C" "E" ))
-
-(dnf f-op2m "opcode" ()  7 1)
-(define-normal-insn-enum insn-op2m "insn op enums" () OP2M_ f-op2m
- ( "0" "1" ))
-(dnop ws2 "word size opcode" () h-wordsize f-op2m)
-
-(dnf f-op3 "opcode" ()  8 4)
-(define-normal-insn-enum insn-op3 "insn op enums" () OP3_ f-op3
- ( "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" ))
-
-(dnf f-op3a "opcode" ()  8 2)
-(define-normal-insn-enum insn-op3a "insn op enums" () OP3A_ f-op3a
- ( "0" "1" "2" "3" ))
-
-(dnf f-op3b "opcode" ()  8 3)
-(define-normal-insn-enum insn-op3b "insn op enums" () OP3B_ f-op3b
- ( "0" "2" "4" "6" "8" "A" "C" "E" ))
-
-(dnf f-op4 "opcode" ()  12 4)
-(define-normal-insn-enum insn-op4 "insn op enums" () OP4_ f-op4
- ( "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" ))
-
-(dnf f-op4m "opcode" () 12 1)
-(define-normal-insn-enum insn-op4m "insn op enums" () OP4M_ f-op4m
- ( "0" "1" ))
-
-(dnf f-op4b "opcode" () 15 1)
-(define-normal-insn-enum insn-op4b "insn op enums" () OP4B_ f-op4b
- ( "0" "1" ))
-
-(dnf f-op5 "opcode" ()  16 4)
-(define-normal-insn-enum insn-op5 "insn op enums" () OP5_ f-op5
- ( "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" ))
-(dnop bcond5 "branch condition opcode" () h-branchcond f-op5)
-
-(dnf f-op5a "opcode" ()  16 1)
-(define-normal-insn-enum insn-op5a "insn op enums" () OP5A_ f-op5a
- ( "0" "1" ))
-
-; The whole first word
-(dnf f-op "opcode" () 0 16)
-
-; Immediate fields
-
-(dnf f-imm2  "2 bit unsigned" () 10 2)
-(dnop imm2 "2 bit unsigned immediate" () h-uint f-imm2)
-
-(dnf f-imm3  "3 bit unsigned" () 4 3)
-(dnop imm3 "3 bit unsigned immediate" () h-uint f-imm3)
-(dnf f-imm3b  "3 bit unsigned for bit tests" () 17 3)
-(dnop imm3b "3 bit unsigned immediate for bit tests" () h-uint f-imm3b)
-
-(dnf f-imm4  "4 bit unsigned" () 8 4)
-(define-operand 
-  (name imm4)
-  (comment "4 bit unsigned immediate")
-  (attrs)
-  (type h-uint)
-  (index f-imm4)
-  (handlers (parse "small_immediate"))
-)
-
-(dnf f-imm8  "8 bit unsigned" () 8 8)
-(dnop imm8 "8 bit unsigned immediate" () h-uint f-imm8)
-(define-operand 
-  (name imm8small)
-  (comment "8 bit unsigned immediate")
-  (attrs)
-  (type h-uint)
-  (index f-imm8)
-  (handlers (parse "small_immediate"))
-)
-
-(define-ifield
-  (name f-imm12)
-  (comment "12 bit signed")
-  (attrs)
-  (start 20)
-  (length 12)
-  (mode INT)
-)
-(dnop imm12 "12 bit signed immediate" () h-sint f-imm12)
-
-(dnf f-imm16 "16 bit" (SIGN-OPT) 16 16)
-(define-operand
-  (name imm16)
-  (comment "16 bit immediate")
-  (attrs)
-  (type h-uint)
-  (index f-imm16)
-  (handlers (parse "immediate16"))
-)
-
-(dnf f-lmem8  "8 bit unsigned low memory" (ABS-ADDR) 8 8)
-(define-operand 
-  (name lmem8)
-  (comment "8 bit unsigned immediate low memory")
-  (attrs)
-  (type h-uint)
-  (index f-lmem8)
-  (handlers (parse "mem8"))
-)
-(define-ifield 
-  (name f-hmem8)
-  (comment "8 bit unsigned high memory")
-  (attrs ABS-ADDR) 
-  (start 8)
-  (length 8)
-  (mode UINT)
-  (encode (value pc) (sub HI value #x7F00))
-  (decode (value pc) (add HI value #x7F00))
-)
-(define-operand 
-  (name hmem8)
-  (comment "8 bit unsigned immediate high memory")
-  (attrs)
-  (type h-uint)
-  (index f-hmem8)
-  (handlers (parse "mem8"))
-)
-
-(define-ifield
-  (name f-rel8-2)
-  (comment "8 bit relative address for 2-byte instruction")
-  (attrs PCREL-ADDR)
-  (start 8)
-  (length 8)
-  (mode INT)
-  (encode (value pc) (sub SI value (add SI pc 2)))
-  (decode (value pc) (add SI value (add SI pc 2)))
-)
-(dnop rel8-2 "8 bit relative address" () h-uint f-rel8-2)
-
-(define-ifield
-  (name f-rel8-4)
-  (comment "8 bit relative address for 4-byte instruction")
-  (attrs PCREL-ADDR)
-  (start 8)
-  (length 8)
-  (mode INT)
-  (encode (value pc) (sub SI value (add SI pc 4)))
-  (decode (value pc) (add SI value (add SI pc 4)))
-)
-(dnop rel8-4 "8 bit relative address" () h-uint f-rel8-4)
-
-(define-ifield
-  (name f-rel12)
-  (comment "12 bit relative address")
-  (attrs PCREL-ADDR)
-  (start 20)
-  (length 12)
-  (mode INT)
-  (encode (value pc) (sub SI value (add SI pc 4)))
-  (decode (value pc) (add SI value (add SI pc 4)))
-)
-(dnop rel12 "12 bit relative address" () h-uint f-rel12)
-
-(define-ifield
-  (name f-rel12a)
-  (comment "12 bit relative address")
-  (attrs PCREL-ADDR)
-  (start 4)
-  (length 11)
-  (mode INT)
-  (encode (value pc) (sra SI (sub SI value (add SI pc 2)) 1))
-  (decode (value pc) (add SI (sll value 1) (add SI pc 2)))
-)
-(dnop rel12a "12 bit relative address" () h-uint f-rel12a)
-
-(dnf f-abs24-1  "abs24 low part" () 8 8)
-(dnf f-abs24-2  "abs24 high part" () 16 16)
-(define-multi-ifield
-  (name f-abs24)
-  (comment "Absolute address for jmpf instruction")
-  (attrs ABS-ADDR)
-  (mode UINT)
-  (subfields f-abs24-1 f-abs24-2)
-  (insert (sequence ()
-		    (set (ifield f-abs24-1) (and (ifield f-abs24) #xFF))
-		    (set (ifield f-abs24-2) (srl (ifield f-abs24) 8))))
-  (extract (set (ifield f-abs24) (or (sll (ifield f-abs24-2) 8) f-abs24-1)))
-)
-(dnop abs24 "24 bit absolute address" () h-uint f-abs24)
-
-; Names for registers
-(dnop psw "program status word" (SEM-ONLY) h-gr 14)
-(dnop Rpsw "N0-N3 of the program status word" (SEM-ONLY) h-Rpsw f-nil)
-(dnop sp "stack pointer" (SEM-ONLY) h-gr 15)
-(dnop R0 "R0" (SEM-ONLY) h-gr 0)
-(dnop R1 "R1" (SEM-ONLY) h-gr 1)
-(dnop R2 "R2" (SEM-ONLY) h-gr 2)
-(dnop R8 "R8" (SEM-ONLY) h-gr 8)
-
-; Useful macros.
-
-; THe Z8, Z16, PT, and S flags of the PSW.
-(define-pmacro (basic-psw value ws)
-  (or (or (zflag (and value #xFF))
-	  (sll HI (zflag HI value) 1))
-      (or (sll HI (c-call BI "parity" value) 5)
-	  (sll HI (nflag QI (srl value (mul ws 8))) 6))))
-
-
-; Update the PSW for destination register Rd, set Rd to value.
-(define-pmacro (set-psw Rd index value ws)
-  (sequence ((HI nvalue))
-    (set nvalue value)
-    (set (reg HI h-gr index) nvalue)
-    (set psw (or (and psw #x0F9C)
-		 (or (sll index 12)
-		     (basic-psw nvalue ws))))))
-
-; Update the PSW for destination register Rd.
-(define-pmacro (set-psw-nowrite index value ws)
-  (sequence ((HI nvalue))
-    (set nvalue value)
-    (set psw (or (and psw #x0F9C)
-		 (or (sll index 12)
-		     (basic-psw nvalue ws))))))
-
-; Update the PSW for destination non-register dest, set dest to value.
-(define-pmacro (set-mem-psw dest value ws)
-  (sequence ((HI nvalue))
-    (set nvalue value)
-    (set psw (or (and psw #xFF9C)
-		 (basic-psw nvalue ws)))
-    (set dest nvalue)))
-
-; Update the PSW as with set-psw, but also set the carry flag.
-(define-pmacro (set-psw-carry Rd index value carry ws)
-  (sequence ((HI nvalue) (HI newpsw))
-    (set nvalue value)
-    (set newpsw (or (or (and psw #x0F98)
-		     (sll (and carry #x1) 2))
-		 (or (sll index 12)
-		     (basic-psw nvalue ws))))
-    (set (reg HI h-gr index) nvalue)
-    (set psw newpsw)
-    ))
-
-; The all-purpose addition operation.
-(define-pmacro (set-psw-add Rd index a b c)
-  (sequence ((HI value) (HI newpsw))
-    (set value (addc a b c))
-    (set newpsw (or (or (and psw #x0F80)
-			(basic-psw value 1))
-		    (or (or (sll HI (add-oflag HI a b c) 4)
-			    (sll HI (add-cflag HI a b c) 2))
-			(or (and (srl HI (addc HI (and a #xF) (and b #xF) c) 
-				      1) #x8)
-			    (sll index 12)))))
-    (set (reg HI h-gr index) value)
-    (set psw newpsw)
-    ))
-
-; Set the PSW for a subtraction of a-b into Rd, but don't actually
-; do the subtract.
-(define-pmacro (set-psw-cmp Rd index a b)
-  (sequence ((HI value))
-    (set value (sub a b))
-    (set psw (or (or (and psw #x0F80)
-		     (basic-psw value 1))
-		 (or (or (sll HI (sub-oflag HI a b 0) 4)
-			 (sll HI (sub-cflag HI a b 0) 2))
-		     (or (and (srl HI (sub HI (and a #xF) (and b #xF))
-				   1) #x8)
-			 (sll index 12)))))))
-
-; Likewise, for subtraction
-; (this chip has a borrow for subtraction, rather than
-; just using a carry for both).
-(define-pmacro (set-psw-sub Rd index a b c)
-  (sequence ((HI value) (HI newpsw))
-    (set value (subc a b c))
-    (set newpsw (or (or (and psw #x0F80)
-		     (basic-psw value 1))
-		 (or (or (sll HI (sub-oflag HI a b c) 4)
-			 (sll HI (sub-cflag HI a b c) 2))
-		     (or (and (srl HI (subc HI (and a #xF) (and b #xF) c)
-				   1) #x8)
-			 (sll index 12)))))
-    (set (reg HI h-gr index) value)
-    (set psw newpsw)
-    ))
-
-; A 17-bit rotate-left operation
-(define-pmacro (set-psw-rotate17 Rd index src c rot)
-  (sequence ((SI tmpfoo))
-    (set tmpfoo (or (or (and (sll SI src 15) #x7FFE0000) 
-		     src)
-		 (or (sll SI c 31)
-		     (sll SI c 16))))
-    (set tmpfoo (rol tmpfoo (and rot #x1F)))
-    (set-psw-carry (reg HI h-gr index) index (trunc HI tmpfoo) (and (srl tmpfoo 16) 1) 1)))
-
-; A 17-bit rotate-right operation
-(define-pmacro (set-psw-rrotate17 Rd index src c rot)
-  (sequence ((SI tmpfoo))
-    (set tmpfoo (or (or (and (sll SI src 17) #xFFFE0000) 
-		     src)
-		 (sll SI c 16)))
-    (set tmpfoo (ror tmpfoo (and rot #x0F)))
-    (set-psw-carry (reg HI h-gr index) index (trunc HI tmpfoo) (and (srl tmpfoo 16) 1) 1)))
-
-
-; Move Operations
-
-(define-pmacro (alignfix-mem where)
-  (mem HI (and where #xFFFE)))
-
-(define-pmacro (set-alignfix-mem where what)
-  (set (mem HI (and where #xFFFE)) what))
-
-(dni movlmemimm
-     "Move immediate to low memory"
-     ()
-     ("mov$ws2 $lmem8,#$imm16")
-     (+ OP1_7 OP2A_8 ws2 lmem8 imm16)
-     (if ws2
-	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) imm16 ws2)
-	 (set-mem-psw (mem QI lmem8) (and imm16 #xFF) ws2))
-     ()
-)
-(dni movhmemimm
-     "Move immediate to high memory"
-     ()
-     ("mov$ws2 $hmem8,#$imm16")
-     (+ OP1_7 OP2A_A ws2 hmem8 imm16)
-     (if ws2
-	 (set-mem-psw (mem HI (and hmem8 #xFFFE)) imm16 ws2)
-	 (set-mem-psw (mem QI hmem8) (and imm16 #xFF) ws2))
-     ()
-)
-
-(dni movlgrmem
-     "Move low memory to register"
-     ()
-     ("mov$ws2 $Rm,$lmem8")
-     (+ OP1_8 Rm ws2 lmem8)
-     (if ws2 
-	 (set-psw Rm (index-of Rm) (alignfix-mem lmem8) ws2)
-	 (set-psw Rm (index-of Rm) (mem QI lmem8) ws2))
-     ()
-)
-(dni movhgrmem
-     "Move high memory to register"
-     ()
-     ("mov$ws2 $Rm,$hmem8")
-     (+ OP1_A Rm ws2 hmem8)
-     (if ws2 
-	 (set-psw Rm (index-of Rm) (alignfix-mem hmem8) ws2)
-	 (set-psw Rm (index-of Rm) (mem QI hmem8) ws2))
-     ()
-)
-
-(dni movlmemgr
-     "Move low memory register to byte"
-     ()
-     ("mov$ws2 $lmem8,$Rm")
-     (+ OP1_9 Rm ws2 lmem8)
-     (if ws2 
-	 (set-mem-psw (mem HI (and lmem8 #xFFFE)) Rm ws2)
-	 (set-mem-psw (mem QI lmem8) Rm ws2))
-     ()
-)
-(dni movhmemgr
-     "Move high memory register to byte"
-     ()
-     ("mov$ws2 $hmem8,$Rm")
-     (+ OP1_B Rm ws2 hmem8)
-     (if ws2 
-	 (set-mem-psw (mem HI (and hmem8 #xFFFE)) Rm ws2)
-	 (set-mem-psw (mem QI hmem8) Rm ws2))
-     ()
-)
-
-(dni movgrgri
-     "Move memory addressed by register to register"
-     ()
-     ("mov$ws2 $Rdm,($Rs)")
-     (+ OP1_7 OP2A_0 ws2 Rs OP4M_0 Rdm)
-     (if ws2
-	 (set-psw Rdm (index-of Rdm) (alignfix-mem Rs) ws2)
-	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)) ws2))
-     ()
-)
-
-(dni movgrgripostinc
-     "Move memory addressed by postincrement register to register"
-     ()
-     ("mov$ws2 $Rdm,($Rs++)")
-     (+ OP1_6 OP2A_0 ws2 Rs OP4M_0 Rdm)
-     (sequence ()
-	       (if ws2
-		   (set-psw Rdm (index-of Rdm) (alignfix-mem Rs) ws2)
-		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)) ws2))
-	       (set Rs (add Rs (add 1 ws2))))
-     ()
-)
-
-(dni movgrgripredec
-     "Move memory addressed by predecrement register to register"
-     ()
-     ("mov$ws2 $Rdm,(--$Rs)")
-     (+ OP1_6 OP2A_8 ws2 Rs OP4M_0 Rdm)
-     (sequence ()
-	       (set Rs (sub Rs (add 1 ws2)))
-	       (if ws2
-		   (set-psw Rdm (index-of Rdm) (alignfix-mem Rs) ws2)
-		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI Rs)) ws2)))
-     ()
-)
-
-(dni movgrigr
-     "Move register to memory addressed by register"
-     ()
-     ("mov$ws2 ($Rs),$Rdm")
-     (+ OP1_7 OP2A_2 ws2 Rs OP4M_0 Rdm)
-     (sequence ()
-	       (if ws2
-		   (set-alignfix-mem Rs Rdm)
-		   (set (mem QI Rs) Rdm))
-	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
-     ()
-)
-
-(dni movgripostincgr
-     "Move register to memory addressed by postincrement register"
-     ()
-     ("mov$ws2 ($Rs++),$Rdm")
-     (+ OP1_6 OP2A_2 ws2 Rs OP4M_0 Rdm)
-     (sequence ()
-	       (if ws2
-		   (set-alignfix-mem Rs Rdm)
-		   (set (mem QI Rs) Rdm))
-	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
-	       (set Rs (add Rs (add ws2 1))))
-     ()
-)
-
-(dni movgripredecgr
-     "Move register to memory addressed by predecrement register"
-     ()
-     ("mov$ws2 (--$Rs),$Rdm")
-     (+ OP1_6 OP2A_A ws2 Rs OP4M_0 Rdm)
-     (sequence ()
-	       (set Rs (sub Rs (add ws2 1)))
-	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
-	       (if ws2
-		   (set-alignfix-mem Rs Rdm)
-		   (set (mem QI Rs) Rdm)))
-     ()
-)
-
-(dni movgrgrii
-     "Move memory addressed by indexed register to register"
-     ()
-     ("mov$ws2 $Rdm,($Rs,$imm12)")
-     (+ OP1_7 OP2A_0 ws2 Rs OP4M_1 Rdm OP5_0 imm12)
-     (if ws2
-	 (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)) ws2)
-	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))) ws2))
-     ()
-)
-
-(dni movgrgriipostinc
-     "Move memory addressed by indexed register postincrement to register"
-     ()
-     ("mov$ws2 $Rdm,($Rs++,$imm12)")
-     (+ OP1_6 OP2A_0 ws2 Rs OP4M_1 Rdm OP5_0 imm12)
-     (sequence ()
-	       (if ws2
-		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)) ws2)
-		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))) ws2))
-	       (set Rs (add Rs (add ws2 1))))
-     ()
-)
-
-(dni movgrgriipredec
-     "Move memory addressed by indexed register predecrement to register"
-     ()
-     ("mov$ws2 $Rdm,(--$Rs,$imm12)")
-     (+ OP1_6 OP2A_8 ws2 Rs OP4M_1 Rdm OP5_0 imm12)
-     (sequence ()
-	       (set Rs (sub Rs (add ws2 1)))
-	       (if ws2
-		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add Rs imm12)) ws2)
-		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add Rs imm12))) ws2)))
-     ()
-)
-
-(dni movgriigr
-     "Move register to memory addressed by indexed register"
-     ()
-     ("mov$ws2 ($Rs,$imm12),$Rdm")
-     (+ OP1_7 OP2A_2 ws2 Rs OP4M_1 Rdm OP5_0 imm12)
-     (sequence ()
-	       (if ws2
-		   (set-alignfix-mem (add Rs imm12) Rdm)
-		   (set (mem QI (add Rs imm12)) Rdm))
-	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
-     ()
-)
-
-(dni movgriipostincgr
-     "Move register to memory addressed by indexed register postincrement"
-     ()
-     ("mov$ws2 ($Rs++,$imm12),$Rdm")
-     (+ OP1_6 OP2A_2 ws2 Rs OP4M_1 Rdm OP5_0 imm12)
-     (sequence ()
-	       (if ws2
-		   (set-alignfix-mem (add Rs imm12) Rdm)
-		   (set (mem QI (add Rs imm12)) Rdm))
-	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
-	       (set Rs (add Rs 1)))
-     ()
-)
-
-(dni movgriipredecgr
-     "Move register to memory addressed by indexed register predecrement"
-     ()
-     ("mov$ws2 (--$Rs,$imm12),$Rdm")
-     (+ OP1_6 OP2A_A ws2 Rs OP4M_1 Rdm OP5_0 imm12)
-     (sequence ()
-	       (set Rs (sub Rs 1))
-	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
-	       (if ws2
-		   (set-alignfix-mem (add Rs imm12) Rdm)
-		   (set (mem QI (add Rs imm12)) Rdm)))
-     ()
-)
-
-(dni movgrgr
-     "Move general register to general register"
-     ()
-     ("mov $Rd,$Rs")
-     (+ OP1_4 OP2_6 Rs Rd)
-     (set-psw Rd (index-of Rd) Rs 1)
-     ()
-)
-
-(dnmi movimm8
-     "Move 8-bit immediate"
-     ()
-     ("mov Rx,#$imm8")
-     (emit movwimm8 imm8)
-)
-
-(dni movwimm8
-     "Move 8-bit immediate"
-     ()
-     ("mov.w Rx,#$imm8")
-     (+ OP1_4 OP2_7 imm8)
-     (set-psw (reg HI h-gr Rpsw) Rpsw imm8 1)
-     ()
-)
-
-(dnmi movgrimm8
-     "Move 8-bit immediate to general register"
-     ()
-     ("mov $Rm,#$imm8small")
-     (emit movwgrimm8 Rm imm8small)
-)
-
-(dni movwgrimm8
-     "Move 8-bit immediate to general register"
-     ()
-     ("mov.w $Rm,#$imm8small")
-     (+ OP1_2 Rm OP2M_1 imm8small)
-     (set-psw Rm (index-of Rm) imm8small 1)
-     ()
-)
-
-(dnmi movgrimm16
-     "Move 16-bit immediate to general register"
-     ()
-     ("mov $Rd,#$imm16")
-     (emit movwgrimm16 Rd imm16)
-)
-
-(dni movwgrimm16
-     "Move 16-bit immediate to general register"
-     ()
-     ("mov.w $Rd,#$imm16")
-     (+ OP1_3 OP2_1 OP3_3 Rd imm16)
-     (set-psw Rd (index-of Rd) imm16 1)
-     ()
-)
-
-(dni movlowgr
-     "Move 8 low bits to general register"
-     ()
-     ("mov.b $Rd,RxL")
-     (+ OP1_3 OP2_0 OP3_C Rd)
-     (set-psw Rd (index-of Rd) (or (and Rd #xFF00) (and (reg HI h-gr Rpsw) #xFF)) 0)
-     ()
-)
-
-(dni movhighgr
-     "Move 8 high bits to general register"
-     ()
-     ("mov.b $Rd,RxH")
-     (+ OP1_3 OP2_0 OP3_D Rd)
-     (set-psw Rd (index-of Rd) (or (and Rd #x00FF) (and (reg HI h-gr Rpsw) #xFF00)) 1)
-     ()
-)
-
-(dni movfgrgri
-     "Move far memory addressed by register to register"
-     ()
-     ("movf$ws2 $Rdm,($Rs)")
-     (+ OP1_7 OP2A_4 ws2 Rs OP4M_0 Rdm)
-     (if ws2
-	 (set-psw Rdm (index-of Rdm) (alignfix-mem (or (sll SI R8 16) Rs)) ws2)
-	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (or (sll SI R8 16) Rs))) ws2))
-     ()
-)
-
-(dni movfgrgripostinc
-     "Move far memory addressed by postincrement register to register"
-     ()
-     ("movf$ws2 $Rdm,($Rs++)")
-     (+ OP1_6 OP2A_4 ws2 Rs OP4M_0 Rdm)
-     (sequence ()
-	       (if ws2
-		   (set-psw Rdm (index-of Rdm) (alignfix-mem (join SI HI R8 Rs)) ws2)
-		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (join SI HI R8 Rs))) ws2))
-	       (set Rs (add Rs (add ws2 1))))
-     ()
-)
-
-(dni movfgrgripredec
-     "Move far memory addressed by predecrement register to register"
-     ()
-     ("movf$ws2 $Rdm,(--$Rs)")
-     (+ OP1_6 OP2A_C ws2 Rs OP4M_0 Rdm)
-     (sequence ()
-	       (set Rs (sub Rs (add ws2 1)))
-	       (if ws2
-		   (set-psw Rdm (index-of Rdm) (alignfix-mem (join SI HI R8 Rs)) ws2)
-		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (join SI HI R8 Rs))) ws2)))
-     ()
-)
-
-(dni movfgrigr
-     "Move far register to memory addressed by register"
-     ()
-     ("movf$ws2 ($Rs),$Rdm")
-     (+ OP1_7 OP2A_6 ws2 Rs OP4M_0 Rdm)
-     (sequence ()
-	       (if ws2
-		   (set-alignfix-mem (join SI HI R8 Rs) Rdm)
-		   (set (mem QI (join SI HI R8 Rs)) Rdm))
-	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
-     ()
-)
-
-(dni movfgripostincgr
-     "Move far register to memory addressed by postincrement register"
-     ()
-     ("movf$ws2 ($Rs++),$Rdm")
-     (+ OP1_6 OP2A_6 ws2 Rs OP4M_0 Rdm)
-     (sequence ()
-	       (if ws2
-		   (set-alignfix-mem (join SI HI R8 Rs) Rdm)
-		   (set (mem QI (join SI HI R8 Rs)) Rdm))
-	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
-	       (set Rs (add Rs (add ws2 1))))
-     ()
-)
-
-(dni movfgripredecgr
-     "Move far register to memory addressed by predecrement register"
-     ()
-     ("movf$ws2 (--$Rs),$Rdm")
-     (+ OP1_6 OP2A_E ws2 Rs OP4M_0 Rdm)
-     (sequence ()
-	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
-	       (set Rs (sub Rs (add ws2 1)))
-	       (if ws2
-		   (set-alignfix-mem (join SI HI R8 Rs) Rdm)
-		   (set (mem QI (join SI HI R8 Rs)) Rdm)))
-     ()
-)
-
-(dni movfgrgrii
-     "Move far memory addressed by indexed register to register"
-     ()
-     ("movf$ws2 $Rdm,($Rb,$Rs,$imm12)")
-     (+ OP1_7 OP2A_4 ws2 Rs OP4M_1 Rdm OP5A_0 Rb imm12)
-     (if ws2
-	 (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)) ws2)
-	 (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))) ws2))
-     ()
-)
-
-(dni movfgrgriipostinc
- "Move far memory addressed by indexed register postincrement to register"
-     ()
-     ("movf$ws2 $Rdm,($Rb,$Rs++,$imm12)")
-     (+ OP1_6 OP2A_4 ws2 Rs OP4M_1 Rdm OP5A_0 Rb imm12)
-     (sequence ()
-	       (if ws2
-		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)) ws2)
-		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))) ws2))
-	       (set Rs (add Rs (add ws2 1))))
-     ()
-)
-
-(dni movfgrgriipredec
- "Move far memory addressed by indexed register predecrement to register"
-     ()
-     ("movf$ws2 $Rdm,($Rb,--$Rs,$imm12)")
-     (+ OP1_6 OP2A_C ws2 Rs OP4M_1 Rdm OP5A_0 Rb imm12)
-     (sequence ()
-	       (set Rs (sub Rs (add ws2 1)))
-	       (if ws2
-		   (set-psw Rdm (index-of Rdm) (alignfix-mem (add (join SI HI Rb Rs) imm12)) ws2)
-		   (set-psw Rdm (index-of Rdm) (and #xFF (mem QI (add (join SI HI Rb Rs) imm12))) ws2)))
-     ()
-)
-
-(dni movfgriigr
-     "Move far register to memory addressed by indexed register"
-     ()
-     ("movf$ws2 ($Rb,$Rs,$imm12),$Rdm")
-     (+ OP1_7 OP2A_6 ws2 Rs OP4M_1 Rdm OP5A_0 Rb imm12)
-     (sequence ()
-	       (if ws2
-		   (set (mem HI (and (add (join SI HI Rb Rs) imm12) #xFFFFFFFE))
-			Rdm)
-		   (set (mem QI (add (join SI HI Rb Rs) imm12)) Rdm))
-	       (set-psw-nowrite (index-of Rdm) Rdm ws2))
-     ()
-)
-
-
-(dni movfgriipostincgr
-     "Move far register to memory addressed by indexed register postincrement"
-     ()
-     ("movf$ws2 ($Rb,$Rs++,$imm12),$Rdm")
-     (+ OP1_6 OP2A_6 ws2 Rs OP4M_1 Rdm OP5A_0 Rb imm12)
-     (sequence ()
-	       (if ws2
-		   (set (mem HI (and (add (join SI HI Rb Rs) imm12) #xFFFFFFFE)) Rdm)
-		   (set (mem QI (add (join SI HI Rb Rs) imm12)) Rdm))
-	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
-	       (set Rs (add Rs (add ws2 1))))
-     ()
-)
-
-(dni movfgriipredecgr
-  "Move far register to memory addressed by indexed register predecrement"
-     ()
-     ("movf$ws2 ($Rb,--$Rs,$imm12),$Rdm")
-     (+ OP1_6 OP2A_E ws2 Rs OP4M_1 Rdm OP5A_0 Rb imm12)
-     (sequence ()
-	       (set Rs (sub Rs 1))
-	       (set-psw-nowrite (index-of Rdm) Rdm ws2)
-	       (if ws2
-		   (set (mem HI (and (add (join SI HI Rb Rs) imm12) #xFFFFFFFE)) Rdm)
-		   (set (mem QI (add (join SI HI Rb Rs) imm12)) Rdm)))
-     ()
-)
-
-(dni maskgrgr
-     "Mask insert controlled by general register"
-     ()
-     ("mask $Rd,$Rs")
-     (+ OP1_3 OP2_3 Rs Rd)
-     (set-psw Rd (index-of Rd) (or HI (and HI Rd (inv HI Rs)) (and (reg HI h-gr Rpsw) Rs)) 1)
-     ()
-)
-
-(dni maskgrimm16
-     "Mask insert controlled by immediate value"
-     ()
-     ("mask $Rd,#$imm16")
-     (+ OP1_3 OP2_0 OP3_E Rd imm16)
-     (set-psw Rd (index-of Rd) (or (and Rd (inv imm16)) (and (reg HI h-gr Rpsw) imm16)) 1)
-     ()
-)
-
-; Push, Pop
-(dni pushgr
-     "Push register"
-     ()
-     ("push $Rd")
-     (+ OP1_0 OP2_0 OP3_8 Rd)
-     (sequence ()
-	       (set (mem HI sp) Rd)
-	       (set sp (add sp 2)))
-     ()
-)
-
-(dni popgr
-     "Pop into a register"
-     ()
-     ("pop $Rd")
-     (+ OP1_0 OP2_0 OP3_9 Rd)
-     (sequence ()
-	       (set sp (add sp -2))
-	       (set Rd (mem HI sp)))
-     ()
-)
-
-; Swap
-(dni swpn
-     "Swap low nibbles"
-     ()
-     ("swpn $Rd")
-     (+ OP1_3 OP2_0 OP3_9 Rd)
-     (set-psw Rd (index-of Rd) (or (or (and (sll Rd 4) #xF0)
-			 (and (srl Rd 4) #x0F))
-		     (and Rd #xFF00)) 0)
-     ()
-)
-
-(dni swpb
-     "Swap bytes"
-     ()
-     ("swpb $Rd")
-     (+ OP1_3 OP2_0 OP3_8 Rd)
-     (set-psw Rd (index-of Rd) (or (sll Rd 8) (srl Rd 8)) 1)
-     ()
-)
-
-(dni swpw
-     "Swap words"
-     ()
-     ("swpw $Rd,$Rs")
-     (+ OP1_3 OP2_2 Rs Rd)
-     (sequence ((HI foo))
-	       (set foo Rs)
-	       (set Rs Rd)
-	       (set-psw Rd (index-of Rd) foo 1))
-     ()
-)
-
-; Logical Operations
-(dni andgrgr
-     "AND general register with general register"
-     ()
-     ("and $Rd,$Rs")
-     (+ OP1_4 OP2_0 Rs Rd)
-     (set-psw Rd (index-of Rd) (and Rd Rs) 1)
-     ()
-)
-
-(dni andimm8
-     "AND with 8-bit immediate"
-     ()
-     ("and Rx,#$imm8")
-     (+ OP1_4 OP2_1 imm8)
-     (set-psw (reg HI h-gr Rpsw) Rpsw (and (reg HI h-gr Rpsw) imm8) 1)
-     ()
-)
-
-(dni andgrimm16
-     "AND general register with 16-bit immediate"
-     ()
-     ("and $Rd,#$imm16")
-     (+ OP1_3 OP2_1 OP3_0 Rd imm16)
-     (set-psw Rd (index-of Rd) (and Rd imm16) 1)
-     ()
-)
-
-(dni orgrgr
-     "OR general register with general register"
-     ()
-     ("or $Rd,$Rs")
-     (+ OP1_4 OP2_2 Rs Rd)
-     (set-psw Rd (index-of Rd) (or Rd Rs) 1)
-     ()
-)
-
-(dni orimm8
-     "OR with 8-bit immediate"
-     ()
-     ("or Rx,#$imm8")
-     (+ OP1_4 OP2_3 imm8)
-     (set-psw (reg HI h-gr Rpsw) Rpsw (or (reg HI h-gr Rpsw) imm8) 1)
-     ()
-)
-
-(dni orgrimm16
-     "OR general register with 16-bit immediate"
-     ()
-     ("or $Rd,#$imm16")
-     (+ OP1_3 OP2_1 OP3_1 Rd imm16)
-     (set-psw Rd (index-of Rd) (or Rd imm16) 1)
-     ()
-)
-
-(dni xorgrgr
-     "XOR general register with general register"
-     ()
-     ("xor $Rd,$Rs")
-     (+ OP1_4 OP2_4 Rs Rd)
-     (set-psw Rd (index-of Rd) (xor Rd Rs) 1)
-     ()
-)
-
-(dni xorimm8
-     "XOR with 8-bit immediate"
-     ()
-     ("xor Rx,#$imm8")
-     (+ OP1_4 OP2_5 imm8)
-     (set-psw (reg HI h-gr Rpsw) Rpsw (xor (reg HI h-gr Rpsw) imm8) 1)
-     ()
-)
-
-(dni xorgrimm16
-     "XOR general register with 16-bit immediate"
-     ()
-     ("xor $Rd,#$imm16")
-     (+ OP1_3 OP2_1 OP3_2 Rd imm16)
-     (set-psw Rd (index-of Rd) (xor Rd imm16) 1)
-     ()
-)
-
-(dni notgr
-     "NOT general register"
-     ()
-     ("not $Rd")
-     (+ OP1_3 OP2_0 OP3_B Rd)
-     (set-psw Rd (index-of Rd) (inv Rd) 1)
-     ()
-)
-
-; Arithmetic operations
-(dni addgrgr
-     "ADD general register to general register"
-     ()
-     ("add $Rd,$Rs")
-     (+ OP1_4 OP2_9 Rs Rd)
-     (set-psw-add Rd (index-of Rd) Rd Rs 0)
-     ()
-)
-
-(dni addgrimm4
-     "ADD 4-bit immediate to general register"
-     ()
-     ("add $Rd,#$imm4")
-     (+ OP1_5 OP2_1 imm4 Rd)
-     (set-psw-add Rd (index-of Rd) Rd imm4 0)
-     ()
-)
-
-(dni addimm8
-     "ADD 8-bit immediate"
-     ()
-     ("add Rx,#$imm8")
-     (+ OP1_5 OP2_9 imm8)
-     (set-psw-add (reg HI h-gr Rpsw) Rpsw (reg HI h-gr Rpsw) imm8 0)
-     ()
-)
-
-(dni addgrimm16
-     "ADD 16-bit immediate to general register"
-     ()
-     ("add $Rd,#$imm16")
-     (+ OP1_3 OP2_1 OP3_4 Rd imm16)
-     (set-psw-add Rd (index-of Rd) Rd imm16 0)
-     ()
-)
-
-(dni adcgrgr
-     "ADD carry and general register to general register"
-     ()
-     ("adc $Rd,$Rs")
-     (+ OP1_4 OP2_B Rs Rd)
-     (set-psw-add Rd (index-of Rd) Rd Rs psw-cy)
-     ()
-)
-
-(dni adcgrimm4
-     "ADD carry and 4-bit immediate to general register"
-     ()
-     ("adc $Rd,#$imm4")
-     (+ OP1_5 OP2_3 imm4 Rd)
-     (set-psw-add Rd (index-of Rd) Rd imm4 psw-cy)
-     ()
-)
-
-(dni adcimm8
-     "ADD carry and 8-bit immediate"
-     ()
-     ("adc Rx,#$imm8")
-     (+ OP1_5 OP2_B imm8)
-     (set-psw-add (reg HI h-gr Rpsw) Rpsw (reg HI h-gr Rpsw) imm8 psw-cy)
-     ()
-)
-
-(dni adcgrimm16
-     "ADD carry and 16-bit immediate to general register"
-     ()
-     ("adc $Rd,#$imm16")
-     (+ OP1_3 OP2_1 OP3_5 Rd imm16)
-     (set-psw-add Rd (index-of Rd) Rd imm16 psw-cy)
-     ()
-)
-
-(dni subgrgr
-     "SUB general register from general register"
-     ()
-     ("sub $Rd,$Rs")
-     (+ OP1_4 OP2_D Rs Rd)
-     (set-psw-sub Rd (index-of Rd) Rd Rs 0)
-     ()
-)
-
-(dni subgrimm4
-     "SUB 4-bit immediate from general register"
-     ()
-     ("sub $Rd,#$imm4")
-     (+ OP1_5 OP2_5 imm4 Rd)
-     (set-psw-sub Rd (index-of Rd) Rd imm4 0)
-     ()
-)
-
-(dni subimm8
-     "SUB 8-bit immediate"
-     ()
-     ("sub Rx,#$imm8")
-     (+ OP1_5 OP2_D imm8)
-     (set-psw-sub (reg HI h-gr Rpsw) Rpsw (reg HI h-gr Rpsw) imm8 0)
-     ()
-)
-
-(dni subgrimm16
-     "SUB 16-bit immediate from general register"
-     ()
-     ("sub $Rd,#$imm16")
-     (+ OP1_3 OP2_1 OP3_6 Rd imm16)
-     (set-psw-sub Rd (index-of Rd) Rd imm16 0)
-     ()
-)
-
-(dni sbcgrgr
-     "SUB carry and general register from general register"
-     ()
-     ("sbc $Rd,$Rs")
-     (+ OP1_4 OP2_F Rs Rd)
-     (set-psw-sub Rd (index-of Rd) Rd Rs psw-cy)
-     ()
-)
-
-(dni sbcgrimm4
-     "SUB carry and 4-bit immediate from general register"
-     ()
-     ("sbc $Rd,#$imm4")
-     (+ OP1_5 OP2_7 imm4 Rd)
-     (set-psw-sub Rd (index-of Rd) Rd imm4 psw-cy)
-     ()
-)
-
-(dni sbcgrimm8
-     "SUB carry and 8-bit immediate"
-     ()
-     ("sbc Rx,#$imm8")
-     (+ OP1_5 OP2_F imm8)
-     (set-psw-sub (reg HI h-gr Rpsw) Rpsw (reg HI h-gr Rpsw) imm8 psw-cy)
-     ()
-)
-
-(dni sbcgrimm16
-     "SUB carry and 16-bit immediate from general register"
-     ()
-     ("sbc $Rd,#$imm16")
-     (+ OP1_3 OP2_1 OP3_7 Rd imm16)
-     (set-psw-sub Rd (index-of Rd) Rd imm16 psw-cy)
-     ()
-)
-
-(dnmi incgr
-     "Increment general register"
-     ()
-     ("inc $Rd")
-     (emit incgrimm2 Rd (imm2 0))
-)
-
-(dni incgrimm2
-     "Increment general register by 2-bit immediate"
-     ()
-     ("inc $Rd,#$imm2")
-     (+ OP1_3 OP2_0 OP3A_0 imm2 Rd)
-     (set-psw Rd (index-of Rd) (add Rd (add imm2 1)) 1)
-     ()
-)
-
-(dnmi decgr
-     "Decrement general register"
-     ()
-     ("dec $Rd")
-     (emit decgrimm2 Rd (imm2 0))
-)
-
-(dni decgrimm2
-     "Decrement general register by 2-bit immediate"
-     ()
-     ("dec $Rd,#$imm2")
-     (+ OP1_3 OP2_0 OP3A_1 imm2 Rd)
-     (set-psw Rd (index-of Rd) (sub Rd (add imm2 1)) 1)
-     ()
-)
-
-; Logical Shift
-(dni rrcgrgr
-     "Rotate right general register by general register"
-     ()
-     ("rrc $Rd,$Rs")
-     (+ OP1_3 OP2_8 Rs Rd)
-     (set-psw-rrotate17 Rd (index-of Rd) Rd psw-cy Rs)
-     ()
-)
-
-(dni rrcgrimm4
-     "Rotate right general register by immediate"
-     ()
-     ("rrc $Rd,#$imm4")
-     (+ OP1_3 OP2_9 imm4 Rd)
-     (set-psw-rrotate17 Rd (index-of Rd) Rd psw-cy imm4)
-     ()
-)
-
-(dni rlcgrgr
-     "Rotate left general register by general register"
-     ()
-     ("rlc $Rd,$Rs")
-     (+ OP1_3 OP2_A Rs Rd)
-     (set-psw-rotate17 Rd (index-of Rd) Rd psw-cy (and Rs #xF))
-     ()
-)
-
-(dni rlcgrimm4
-     "Rotate left general register by immediate"
-     ()
-     ("rlc $Rd,#$imm4")
-     (+ OP1_3 OP2_B imm4 Rd)
-     (set-psw-rotate17 Rd (index-of Rd) Rd psw-cy imm4)
-     ()
-)
-
-(dni shrgrgr
-     "Shift right general register by general register"
-     ()
-     ("shr $Rd,$Rs")
-     (+ OP1_3 OP2_C Rs Rd)
-     (set-psw-carry Rd (index-of Rd) 
-		    (srl Rd (and Rs #xF)) 
-		    (and SI (if SI (eq (and Rs #xF) 0)
-			     psw-cy
-			     (srl Rd (sub (and Rs #xF) 1)))
-			 1) 1)
-     ()
-)
-
-(dni shrgrimm
-     "Shift right general register by immediate"
-     ()
-     ("shr $Rd,#$imm4")
-     (+ OP1_3 OP2_D imm4 Rd)
-     (set-psw-carry Rd (index-of Rd) 
-		    (srl Rd imm4) 
-		    (and SI (if SI (eq imm4 0)
-			     psw-cy
-			     (srl Rd (sub imm4 1)))
-			 1) 1)
-     ()
-)
-
-(dni shlgrgr
-     "Shift left general register by general register"
-     ()
-     ("shl $Rd,$Rs")
-     (+ OP1_3 OP2_E Rs Rd)
-     (set-psw-carry Rd (index-of Rd) 
-		    (sll Rd (and Rs #xF)) 
-		    (srl SI (if SI (eq (and Rs #xF) 0)
-			     (sll psw-cy 15)
-			     (sll Rd (sub (and Rs #xF) 1)))
-			 15) 1)
-     ()
-)
-
-(dni shlgrimm
-     "Shift left general register by immediate"
-     ()
-     ("shl $Rd,#$imm4")
-     (+ OP1_3 OP2_F imm4 Rd)
-     (set-psw-carry Rd (index-of Rd) 
-		    (sll Rd imm4) 
-		    (srl SI (if SI (eq imm4 0)
-			     (sll psw-cy 15)
-			     (sll Rd (sub imm4 1)))
-			 15) 1)
-     ()
-)
-
-(dni asrgrgr
-     "Arithmetic shift right general register by general register"
-     ()
-     ("asr $Rd,$Rs")
-     (+ OP1_3 OP2_6 Rs Rd)
-     (set-psw-carry Rd (index-of Rd) 
-		    (sra HI Rd (and Rs #xF)) 
-		    (and SI (if SI (eq (and Rs #xF) 0)
-			     psw-cy
-			     (srl Rd (sub (and Rs #xF) 1)))
-			 1) 1)
-     ()
-)
-
-(dni asrgrimm
-     "Arithmetic shift right general register by immediate"
-     ()
-     ("asr $Rd,#$imm4")
-     (+ OP1_3 OP2_7 imm4 Rd)
-     (set-psw-carry Rd (index-of Rd) 
-		    (sra HI Rd imm4) 
-		    (and SI (if SI (eq imm4 0)
-			     psw-cy
-			     (srl Rd (sub imm4 1)))
-			 1) 1)
-     ()
-)
-
-; Bitwise operations
-(dni set1grimm
-     "Set bit in general register by immediate"
-     ()
-     ("set1 $Rd,#$imm4")
-     (+ OP1_0 OP2_9 imm4 Rd)
-     (set-psw Rd (index-of Rd) (or Rd (sll 1 imm4)) 1)
-     ()
-)
-
-(dni set1grgr
-     "Set bit in general register by general register"
-     ()
-     ("set1 $Rd,$Rs")
-     (+ OP1_0 OP2_B Rs Rd)
-     (set-psw Rd (index-of Rd) (or Rd (sll 1 (and Rs #xF))) 1)
-     ()
-)
-
-(dni set1lmemimm
-     "Set bit in low memory by immediate"
-     ()
-     ("set1 $lmem8,#$imm3")
-     (+ OP1_E imm3 OP2M_1 lmem8)
-     (set-mem-psw (mem QI lmem8) (or (mem QI lmem8) (sll 1 imm3)) 0)
-     ()
-)
-(dni set1hmemimm
-     "Set bit in high memory by immediate"
-     ()
-     ("set1 $hmem8,#$imm3")
-     (+ OP1_F imm3 OP2M_1 hmem8)
-     (set-mem-psw (mem QI hmem8) (or (mem QI hmem8) (sll 1 imm3)) 0)
-     ()
-)
-
-(dni clr1grimm
-     "Clear bit in general register by immediate"
-     ()
-     ("clr1 $Rd,#$imm4")
-     (+ OP1_0 OP2_8 imm4 Rd)
-     (set-psw Rd (index-of Rd) (and Rd (inv (sll 1 imm4))) 1)
-     ()
-)
-
-(dni clr1grgr
-     "Clear bit in general register by general register"
-     ()
-     ("clr1 $Rd,$Rs")
-     (+ OP1_0 OP2_A Rs Rd)
-     (set-psw Rd (index-of Rd) (and Rd (inv (sll 1 (and Rs #xF)))) 1)
-     ()
-)
-
-(dni clr1lmemimm
-     "Clear bit in low memory"
-     ()
-     ("clr1 $lmem8,#$imm3")
-     (+ OP1_E imm3 OP2M_0 lmem8)
-     (set-mem-psw (mem QI lmem8) (and (mem QI lmem8) (inv (sll 1 imm3))) 0)
-     ()
-)
-(dni clr1hmemimm
-     "Clear bit in high memory"
-     ()
-     ("clr1 $hmem8,#$imm3")
-     (+ OP1_F imm3 OP2M_0 hmem8)
-     (set-mem-psw (mem QI hmem8) (and (mem QI hmem8) (inv (sll 1 imm3))) 0)
-     ()
-)
-
-; Data conversion
-
-(dni cbwgr
-     "Sign-extend byte in general register"
-     ()
-     ("cbw $Rd")
-     (+ OP1_3 OP2_0 OP3_A Rd)
-     (set-psw Rd (index-of Rd) (ext HI (trunc QI Rd)) 1)
-     ()
-)
-
-(dni revgr
-     "Reverse bit pattern in general register"
-     ()
-     ("rev $Rd")
-     (+ OP1_3 OP2_0 OP3_F Rd)
-     (set-psw Rd (index-of Rd)
-       (or (sll (and Rd #x0001) 15)
-       (or (sll (and Rd #x0002) 13)
-       (or (sll (and Rd #x0004) 11)
-       (or (sll (and Rd #x0008) 9)
-       (or (sll (and Rd #x0010) 7)
-       (or (sll (and Rd #x0020) 5)
-       (or (sll (and Rd #x0040) 3)
-       (or (sll (and Rd #x0080) 1)
-       (or (srl (and Rd #x0100) 1)
-       (or (srl (and Rd #x0200) 3)
-       (or (srl (and Rd #x0400) 5)
-       (or (srl (and Rd #x0800) 7)
-       (or (srl (and Rd #x1000) 9)
-       (or (srl (and Rd #x2000) 11)
-       (or (srl (and Rd #x4000) 13)
-           (srl (and Rd #x8000) 15))))))))))))))))
-       1)
-     ()
-)
-
-; Conditional Branches
-
-(define-pmacro (cbranch cond dest)
-  (sequence ((BI tmp))
-	    (case cond
-	      ((0)  (set tmp (not (xor psw-s psw-ov))))			; ge
-	      ((1)  (set tmp (not psw-cy)))				; nc
-	      ((2)  (set tmp (xor psw-s psw-ov)))			; lt
-	      ((3)  (set tmp psw-cy))					; c
-	      ((4)  (set tmp (not (or (xor psw-s psw-ov) psw-z16))))	; gt
-	      ((5)  (set tmp (not (or psw-cy psw-z16))))		; hi
-	      ((6)  (set tmp (or (xor psw-s psw-ov) psw-z16)))		; le
-	      ((7)  (set tmp (or psw-cy psw-z16)))			; ls
-	      ((8)  (set tmp (not psw-s)))				; pl
-	      ((9)  (set tmp (not psw-ov)))				; nv
-	      ((10) (set tmp psw-s))					; mi
-	      ((11) (set tmp psw-ov))					; v
-	      ((12) (set tmp (not psw-z8)))				; nz.b
-	      ((13) (set tmp (not psw-z16)))				; nz
-	      ((14) (set tmp psw-z8))					; z.b
-	      ((15) (set tmp psw-z16)))					; z
-	    (if tmp (set pc dest)))
-)
-
-(dni bccgrgr
-     "Conditional branch comparing general register with general register"
-     ()
-     ("b$bcond5 $Rd,$Rs,$rel12")
-     (+ OP1_0 OP2_D Rs Rd bcond5 rel12)
-     (sequence ()
-	       (set-psw-cmp Rd (index-of Rd) Rd Rs)
-	       (cbranch bcond5 rel12))
-     ()
-)
-
-; 4 bytes
-(dni bccgrimm8
-     "Conditional branch comparing general register with 8-bit immediate"
-     ()
-     ("b$bcond5 $Rm,#$imm8,$rel12")
-     (+ OP1_2 OP2M_0 Rm imm8 bcond5 rel12)
-     (sequence ()
-	       (set-psw-cmp Rm (index-of Rm) Rm imm8)
-	       (cbranch bcond5 rel12))
-     ()
-)
-
-; 4 bytes
-(dni bccimm16
-     "Conditional branch comparing general register with 16-bit immediate"
-     ()
-     ("b$bcond2 Rx,#$imm16,${rel8-4}")
-     (+ OP1_C bcond2 rel8-4 imm16)
-     (sequence ()
-	       (set-psw-cmp (reg HI h-gr Rpsw) Rpsw (reg HI h-gr Rpsw) imm16)
-	       (cbranch bcond2 rel8-4))
-     ()
-)
-
-(dni bngrimm4
-     "Test bit in general register by immediate and branch if 0"
-     ()
-     ("bn $Rd,#$imm4,$rel12")
-     (+ OP1_0 OP2_4 imm4 Rd OP5_0 rel12)
-     (sequence ()
-	       (set Rpsw (index-of Rd))
-	       (if (eq (and Rd (sll 1 imm4)) 0)
-		   (set pc rel12)))
-     ()
-)
-
-(dni bngrgr
-     "Test bit in general register by general register and branch if 0"
-     ()
-     ("bn $Rd,$Rs,$rel12")
-     (+ OP1_0 OP2_6 Rs Rd OP5_0 rel12)
-     (sequence ()
-	       (set Rpsw (index-of Rd))
-	       (if (eq (and Rd (sll 1 Rs)) 0)
-		   (set pc rel12)))
-     ()
-)
-
-(dni bnlmemimm
-     "Test bit in memory by immediate and branch if 0"
-     ()
-     ("bn $lmem8,#$imm3b,$rel12")
-     (+ OP1_7 OP2_C lmem8 OP5A_0 imm3b rel12)
-     (if (eq (and (mem QI lmem8) (sll 1 imm3b)) 0)
-	 (set pc rel12))
-     ()
-)
-
-(dni bnhmemimm
-     "Test bit in memory by immediate and branch if 0"
-     ()
-     ("bn $hmem8,#$imm3b,$rel12")
-     (+ OP1_7 OP2_E hmem8 OP5A_0 imm3b rel12)
-     (if (eq (and (mem QI hmem8) (sll 1 imm3b)) 0)
-	 (set pc rel12))
-     ()
-)
-
-(dni bpgrimm4
-     "Test bit in general register by immediate and branch if 1"
-     ()
-     ("bp $Rd,#$imm4,$rel12")
-     (+ OP1_0 OP2_5 imm4 Rd OP5_0 rel12)
-     (sequence ()
-	       (set Rpsw (index-of Rd))
-	       (if (ne (and Rd (sll 1 imm4)) 0)
-		   (set pc rel12)))
-     ()
-)
-
-(dni bpgrgr
-     "Test bit in general register by general register and branch if 1"
-     ()
-     ("bp $Rd,$Rs,$rel12")
-     (+ OP1_0 OP2_7 Rs Rd OP5_0 rel12)
-     (sequence ()
-	       (set Rpsw (index-of Rd))
-	       (if (ne (and Rd (sll 1 Rs)) 0)
-		   (set pc rel12)))
-     ()
-)
-
-(dni bplmemimm
-     "Test bit in memory by immediate and branch if 1"
-     ()
-     ("bp $lmem8,#$imm3b,$rel12")
-     (+ OP1_7 OP2_D lmem8 OP5A_0 imm3b rel12)
-     (if (ne (and (mem QI lmem8) (sll 1 imm3b)) 0)
-	 (set pc rel12))
-     ()
-)
-
-(dni bphmemimm
-     "Test bit in memory by immediate and branch if 1"
-     ()
-     ("bp $hmem8,#$imm3b,$rel12")
-     (+ OP1_7 OP2_F hmem8 OP5A_0 imm3b rel12)
-     (if (ne (and (mem QI hmem8) (sll 1 imm3b)) 0)
-	 (set pc rel12))
-     ()
-)
-
-(dni bcc
-     "Conditional branch on flag registers"
-     ()
-     ("b$bcond2 ${rel8-2}")
-     (+ OP1_D bcond2 rel8-2)
-     (cbranch bcond2 rel8-2)
-     ()
-)
-
-; Unconditional Branching
-
-(dni bgr
-     "Branch to register"
-     ()
-     ("br $Rd")
-     (+ OP1_0 OP2_0 OP3_2 Rd)
-     (set pc (add (add pc 2) Rd))
-     ()
-)
-
-(dni br
-     "Branch"
-     ()
-     ("br $rel12a")
-     (+ OP1_1 rel12a OP4B_0)
-     (set pc rel12a)
-     ()
-)
-
-(dni jmp
-     "Jump"
-     ()
-     ("jmp $Rbj,$Rd")
-     (+ OP1_0 OP2_0 OP3B_4 Rbj Rd)
-     (set pc (join SI HI Rbj Rd))
-     ()
-)
-
-(dni jmpf
-     "Jump far"
-     ()
-     ("jmpf $abs24")
-     (+ OP1_0 OP2_2 abs24)
-     (set pc abs24)
-     ()
-)
-
-; Call instructions
-(define-pmacro (do-call dest ilen)
-  (sequence ()
-	    (set (mem SI sp) (add pc ilen))
-	    (set sp (add sp 4))
-	    (set pc dest)))
-
-(dni callrgr
-     "Call relative to general register"
-     ()
-     ("callr $Rd")
-     (+ OP1_0 OP2_0 OP3_1 Rd)
-     (do-call (add Rd (add pc 2)) 2)
-     ()
-)
-
-(dni callrimm
-     "Call relative to immediate address"
-     ()
-     ("callr $rel12a")
-     (+ OP1_1 rel12a OP4B_1)
-     (do-call rel12a 2)
-     ()
-)
-
-(dni callgr
-     "Call to general registers"
-     ()
-     ("call $Rbj,$Rd")
-     (+ OP1_0 OP2_0 OP3B_A Rbj Rd)
-     (do-call (join SI HI Rbj Rd) 2)
-     ()
-)
-
-(dni callfimm
-     "Call far to absolute address"
-     ()
-     ("callf $abs24")
-     (+ OP1_0 OP2_1 abs24)
-     (do-call abs24 4)
-     ()
-)
-
-(define-pmacro (do-calli dest ilen)
-  (sequence ()
-	    (set (mem SI sp) (add pc ilen))
-	    (set (mem HI (add sp 4)) psw)
-	    (set sp (add sp 6))
-	    (set pc dest)))
-
-(dni icallrgr
-     "Call interrupt to general registers pc-relative"
-     ()
-     ("icallr $Rd")
-     (+ OP1_0 OP2_0 OP3_3 Rd)
-     (do-calli (add Rd (add pc 2)) 2)
-     ()
-)
-
-(dni icallgr
-     "Call interrupt to general registers"
-     ()
-     ("icall $Rbj,$Rd")
-     (+ OP1_0 OP2_0 OP3B_6 Rbj Rd)
-     (do-calli (join SI HI Rbj Rd) 2)
-     ()
-)
-
-(dni icallfimm
-     "Call interrupt far to absolute address"
-     ()
-     ("icallf $abs24")
-     (+ OP1_0 OP2_3 abs24)
-     (do-calli abs24 4)
-     ()
-)
-
-; Return instructions
-(dni iret
-     "Return from interrupt"
-     ()
-     ("iret")
-     (+ (f-op #x0002))
-     (sequence ()
-	       (set sp (sub sp 6))
-	       (set pc (mem SI sp))
-	       (set psw (mem HI (add sp 4))))
-     ()
-)
-
-(dni ret
-     "Return"
-     ()
-     ("ret")
-     (+ (f-op #x0003))
-     (sequence ()
-	       (set sp (sub sp 4))
-	       (set pc (mem SI sp)))
-     ()
-)
-
-; Multiply and Divide instructions
-
-(dni mul
-     "Multiply"
-     ()
-     ("mul")
-     (+ (f-op #x00D0))
-     (sequence ((SI value))
-	       (set value (mul SI (and SI R0 #xFFFF) (and SI R2 #xFFFF)))
-	       (set psw (or (and psw #xFF9C)
-			    (basic-psw (trunc HI value) 1)))
-	       (set R0 (trunc HI value))
-	       (set R1 (trunc HI (srl value 16))))
-     ()
-)
-(dni div
-     "Divide"
-     ()
-     ("div")
-     (+ (f-op #x00C0))
-     (sequence ()
-	       (set R1 (umod R0 R2))
-	       (set-mem-psw R0 (udiv R0 R2) 1))
-     ()
-)
-(dni sdiv
-     "Signed Divide"
-     ()
-     ("sdiv")
-     (+ (f-op #x00C8))
-     (sequence ()
-	       (set R1 (mod HI R0 R2))
-	       (set-mem-psw R0 (div HI R0 R2) 1))
-     ()
-)
-(dni sdivlh
-     "Divide 32/16"
-     ()
-     ("sdivlh")
-     (+ (f-op #x00E8))
-     (sequence ((SI value))
-	       (set value (add SI (sll SI (and SI R1 #xffff) #x10) (and SI R0 #xffff)))
-	       (set R1 (mod SI value (ext SI (trunc HI R2))))
-	       (set-mem-psw R0 (div SI value (ext SI (trunc HI R2))) 1))
-     ()
-)
-(dni divlh
-     "Divide 32/16"
-     ()
-     ("divlh")
-     (+ (f-op #x00E0))
-     (sequence ((SI value))
-	       (set value (add SI (sll SI (and SI R1 #xffff) #x10) (and SI R0 #xffff)))
-	       (set R1 (umod SI value R2))
-	       (set-mem-psw R0 (udiv SI value R2) 1))
-     ()
-)
-
-; System Control
-
-; added per sanyo's req -- eq to nop for the moment, but can 
-; add function later
-(dni reset "reset" () ("reset") (+ (f-op #x000f)) (nop) ())
-
-(dni nop "nop" () ("nop") (+ (f-op #x0000)) (nop) ())
-
-(dni halt "halt" () ("halt") (+ (f-op #x0008)) (c-call VOID "do_halt") ())
-
-(dni hold "hold" () ("hold") (+ (f-op #x000A)) (c-call VOID "do_hold") ())
-
-(dni holdx "holdx" () ("holdx") (+ (f-op #x000B)) (c-call VOID "do_holdx") ())
-
-(dni brk "brk" () ("brk") (+ (f-op #x0005)) (c-call VOID "do_brk") ())
-
-; An instruction for test instrumentation.
-; Using a reserved opcode.
-(dni syscall
-  "simulator system call"
-  ()
-  ("--unused--")
-  (+ (f-op #x0001))
-  (c-call VOID "syscall")
-  ()
-)
diff -rupN binutils-2.19.1-original/cgen/cpu/xstormy16.opc binutils-2.19.1/cgen/cpu/xstormy16.opc
--- binutils-2.19.1-original/cgen/cpu/xstormy16.opc	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/cgen/cpu/xstormy16.opc	1969-12-31 19:00:00.000000000 -0500
@@ -1,169 +0,0 @@
-
-/* -*- C -*-
-   Copyright 2011 Free Software Foundation, Inc.
-
-   Contributed by Red Hat Inc;
-
-   This file is part of the GNU Binutils.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-/* This file is an addendum to xstormy16.cpu.  Heavy use of C code isn't
-   appropriate in .cpu files, so it resides here.  This especially applies
-   to assembly/disassembly where parsing/printing can be quite involved.
-   Such things aren't really part of the specification of the cpu, per se,
-   so .cpu files provide the general framework and .opc files handle the
-   nitty-gritty details as necessary.
-
-   Each section is delimited with start and end markers.
-
-   <arch>-opc.h additions use: "-- opc.h"
-   <arch>-opc.c additions use: "-- opc.c"
-   <arch>-asm.c additions use: "-- asm.c"
-   <arch>-dis.c additions use: "-- dis.c"
-   <arch>-ibd.h additions use: "-- ibd.h".  */
-
-/* -- opc.h */
-
-/* Allows reason codes to be output when assembler errors occur.  */
-#define CGEN_VERBOSE_ASSEMBLER_ERRORS
-
-/* We can't use the default hash size because many bits are used by
-   operands.  */
-#define CGEN_DIS_HASH_SIZE 1
-#define CGEN_DIS_HASH(buf, value) 0
-/* -- */
-
-/* -- asm.c */
-
-/* The machine-independent code doesn't know how to disambiguate
-     mov (foo),r3
-   and
-     mov (r2),r3
-   where 'foo' is a label.  This helps it out. */
-
-static const char *
-parse_mem8 (CGEN_CPU_DESC cd,
-	    const char **strp,
-	    int opindex,
-	    unsigned long *valuep)
-{
-  if (**strp == '(')
-    {
-      const char *s = *strp;
-      
-      if (s[1] == '-' && s[2] == '-')
-	return _("Bad register in preincrement");
-
-      while (ISALNUM (*++s))
-	;
-      if (s[0] == '+' && s[1] == '+' && (s[2] == ')' || s[2] == ','))
-	return _("Bad register in postincrement");
-      if (s[0] == ',' || s[0] == ')')
-	return _("Bad register name");
-    }
-  else if (cgen_parse_keyword (cd, strp, & xstormy16_cgen_opval_gr_names, 
-			       (long *) valuep) == NULL)
-    return _("Label conflicts with register name");
-  else if (strncasecmp (*strp, "rx,", 3) == 0
-	   || strncasecmp (*strp, "rxl,", 3) == 0
-	   || strncasecmp (*strp, "rxh,", 3) == 0)
-    return _("Label conflicts with `Rx'");
-  else if (**strp == '#')
-    return _("Bad immediate expression");
-  
-  return cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
-}
-
-/* For the add and subtract instructions, there are two immediate forms,
-   one for small operands and one for large ones.  We want to use
-   the small one when possible, but we do not want to generate relocs
-   of the small size.  This is somewhat tricky.  */
-   
-static const char *
-parse_small_immediate (CGEN_CPU_DESC cd,
-		       const char **strp,
-		       int opindex,
-		       unsigned long *valuep)
-{
-  bfd_vma value;
-  enum cgen_parse_operand_result result;
-  const char *errmsg;
-
-  if (**strp == '@')
-    return _("No relocation for small immediate");
-
-  errmsg = (* cd->parse_operand_fn)
-    (cd, CGEN_PARSE_OPERAND_INTEGER, strp, opindex, BFD_RELOC_NONE,
-     & result, & value);
-  
-  if (errmsg)
-    return errmsg;
-
-  if (result != CGEN_PARSE_OPERAND_RESULT_NUMBER)
-    return _("Small operand was not an immediate number");
-
-  *valuep = value;
-  return NULL;
-}
-
-/* Literal scan be either a normal literal, a @hi() or @lo relocation.  */
-   
-static const char *
-parse_immediate16 (CGEN_CPU_DESC cd,
-		   const char **strp,
-		   int opindex,
-		   unsigned long *valuep)
-{
-  const char *errmsg;
-  enum cgen_parse_operand_result result;
-  bfd_reloc_code_real_type code = BFD_RELOC_NONE;
-  bfd_vma value;
-
-  if (strncmp (*strp, "@hi(", 4) == 0)
-    {
-      *strp += 4;
-      code = BFD_RELOC_HI16;
-    }
-  else
-  if (strncmp (*strp, "@lo(", 4) == 0)
-    {
-      *strp += 4;
-      code = BFD_RELOC_LO16;
-    }
-
-  if (code == BFD_RELOC_NONE)
-    errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
-  else
-    {
-      errmsg = cgen_parse_address (cd, strp, opindex, code, &result, &value);
-      if ((errmsg == NULL) &&
-	  (result != CGEN_PARSE_OPERAND_RESULT_QUEUED))
-	errmsg = _("Operand is not a symbol");
-
-      *valuep = value;
-      if ((code == BFD_RELOC_HI16 || code == BFD_RELOC_LO16)
-	  && **strp == ')')        
-	*strp += 1;
-      else
-        {
-	  errmsg = _("Syntax error: No trailing ')'");
-	  return errmsg;
-	}
-    }
-  return errmsg;
-}
-/* -- */
diff -rupN binutils-2.19.1-original/config.sub binutils-2.19.1/config.sub
--- binutils-2.19.1-original/config.sub	2008-04-14 05:28:35.000000000 -0400
+++ binutils-2.19.1/config.sub	2024-03-11 22:39:46.872433180 -0400
@@ -148,7 +148,7 @@ case $os in
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray)
+	-apple | -axis | -knuth | -cray | -tms9900)
 		os=
 		basic_machine=$1
 		;;
@@ -284,7 +284,7 @@ case $basic_machine in
 	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
 	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
 	| spu | strongarm \
-	| tahoe | thumb | tic4x | tic80 | tron \
+	| tahoe | thumb | tic4x | tic80 | tron | tms9900 \
 	| v850 | v850e \
 	| we32k \
 	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
diff -rupN binutils-2.19.1-original/gas/config/tc-tms9900.c binutils-2.19.1/gas/config/tc-tms9900.c
--- binutils-2.19.1-original/gas/config/tc-tms9900.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.19.1/gas/config/tc-tms9900.c	2024-03-11 22:39:48.132416982 -0400
@@ -0,0 +1,1276 @@
+/* tc-tms9900.c -- Assemble code for the Texas Instruments TMS9900
+   Copyright 2009 Eric Welser
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "as.h"
+#include "safe-ctype.h"
+#include "subsegs.h"
+
+
+/* Exported constants.  */
+const char line_separator_chars[] = "\0";
+const char EXP_CHARS[] = "eE\0";
+const char FLT_CHARS[] = "RrFf\0";
+const char line_comment_chars[] = "#\0";
+
+/* The TMS9900 assembly format specifies "*" for the start of comments.
+   Unfortunately, that character is also used in register expressions.
+   So we have to manually handle comments here, and cannot rely on GAS's
+   normal comment parsing */
+const char tms9900_comment_chars[] = "#;\0";
+
+/* List of chars besides those in app.c:symbol_chars that can start an
+   operand.  Used to prevent the scrubber eating vital white-space.
+   We use this to determine if the asterisk is the start of a comment */
+const char tms9900_symbol_chars[] = "+*\0";
+
+/* For machine specific options.  */
+const char * md_shortopts = ""; /* None yet.  */
+
+struct option md_longopts[] =
+{
+  { NULL, no_argument, NULL, 0 }
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+
+extern int coff_flags;
+
+
+int
+md_parse_option (int c, char* arg ATTRIBUTE_UNUSED)
+{
+  switch (c)
+    {
+    default:
+      return 0;
+    }
+}
+
+
+void
+md_show_usage (FILE * f)
+{
+  fprintf(f,"\n");
+}
+
+static symbolS * zero;
+
+
+void
+md_begin (void)
+{
+  expressionS nul;
+  char * p;
+
+  p = input_line_pointer;
+  input_line_pointer = "0";
+  nul.X_md=0;
+  expression (& nul);
+  input_line_pointer = p;
+  zero = make_expr_symbol (& nul);
+  /* We do not use relaxation (yet).  */
+  linkrelax = 0;
+}
+
+
+void
+tms9900_md_end (void)
+{
+  bfd_set_arch_mach (stdoutput, TARGET_ARCH, bfd_mach_tms9900);
+}
+
+
+static const char *
+skip_space (const char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    ++s;
+  return s;
+}
+
+
+symbolS *
+md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
+{
+  return NULL;
+}
+
+
+char *
+md_atof (int type ATTRIBUTE_UNUSED, char *litP ATTRIBUTE_UNUSED,
+	 int *sizeP ATTRIBUTE_UNUSED)
+{
+  return _("floating point numbers are not implemented");
+}
+
+
+valueT
+md_section_align (segT seg ATTRIBUTE_UNUSED, valueT size)
+{
+  return size;
+}
+
+
+long
+md_pcrel_from (fixS * fixp)
+{
+  return fixp->fx_where +
+    fixp->fx_frag->fr_address + 1;
+}
+
+
+/* Compares the key for structs that start with a char * to the key.  */
+static int
+key_cmp (const void * a, const void * b)
+{
+  const char *str_a, *str_b;
+
+  str_a = *((const char**)a);
+  str_b = *((const char**)b);
+  return strcmp (str_a, str_b);
+}
+
+
+static int
+key_regcmp (const void * a, const void * b)
+{
+  const char *str_a, *str_b;
+
+  str_a = *((const char**)a);
+  str_b = *((const char**)b);
+  return strncasecmp (str_a, str_b, strlen(str_b));
+}
+
+
+#define BUFLEN 8 /* Large enough for any keyword.  */
+
+char buf[BUFLEN];
+const char *key = buf;
+
+static const struct reg_entry
+{
+  char* name;
+  int number;
+} regtable[] =
+{
+  {"cb",  12 },  /* CRU base */
+  {"lp",  14 },  /* Old Program Counter register after BLWP */
+  {"lr",  11 },  /* Return address after BL */
+  {"ls",  15 },  /* Old Status Register after BLWP */
+  {"lw",  13 },  /* Old Workspace Register after BLWP */
+  {"r0",   0 },
+  {"r1",   1 },
+  {"r10", 10 },
+  {"r11", 11 },
+  {"r12", 12 },
+  {"r13", 13 },
+  {"r14", 14 },
+  {"r15", 15 },
+  {"r2",   2 },
+  {"r3",   3 },
+  {"r4",   4 },
+  {"r5",   5 },
+  {"r6",   6 },
+  {"r7",   7 },
+  {"r8",   8 },
+  {"r9",   9 },
+  {"sp",  10 }   /* Stack pointer */
+} ;
+
+/* Prevent an error on a line from also generating
+   a "junk at end of line" error message.  */
+static char err_flag;
+
+static void tms9900_bss (int unused ATTRIBUTE_UNUSED);
+
+
+int
+tms9900_start_line_hook (void)
+{
+  /* Elements of code grammar */
+  enum
+    {
+      ST_START,         /* Start of line */
+      ST_LABEL,         /* Code label */
+      ST_PRE_DIRECTIVE, /* Space before directive or mnemonic*/
+      ST_DIRECTIVE,     /* Assembly directive */
+      ST_PRE_OPTION,    /* Space before directive option */
+      ST_OPTION,        /* Directive option */
+      ST_MNEMONIC,      /* Opcode mnemonic */
+      ST_PRE_ARGUMENT,  /* Space before argument */
+      ST_ARGUMENT,      /* Non-string argument */
+      ST_POST_ARGUMENT, /* Space or comma after argument */
+      ST_TI_STRING,     /* TI-style string */
+      ST_GAS_STRING,    /* GAS-style string */
+      ST_POST_STRING,   /* Space or comma after string */
+      ST_COMMENT        /* Comment at end of line */
+    };
+  int state = ST_START;
+  char *p;
+
+  for (p = input_line_pointer; *p && *p != '\n'; ++p)
+    {
+      switch(state)
+        {
+          case ST_START:
+          if(strchr(" \t",*p)) state = ST_PRE_DIRECTIVE;
+          else if(*p == '*') state = ST_COMMENT;
+          else state = ST_LABEL;
+          p--;
+          break;
+
+          case ST_LABEL:
+          if(strchr(" \t",p[1])) state = ST_PRE_DIRECTIVE;
+          break;
+
+          case ST_PRE_DIRECTIVE:
+          if(strchr(" \t",p[1]) == NULL)
+            {
+              if(p[1] == '.') state = ST_DIRECTIVE;
+              else if(p[1] == '*') state = ST_COMMENT;
+              else state = ST_MNEMONIC;
+            }
+          break;
+
+          case ST_DIRECTIVE:
+          if(strchr(" \t",p[1])) state = ST_PRE_OPTION;
+          break;
+
+          case ST_PRE_OPTION:
+          if(strchr(" \t",p[1]) == NULL) state = ST_OPTION;
+          break;
+
+          case ST_OPTION:
+          if(strchr(" \t",p[1])) state = ST_OPTION;
+          if(p[0] == '*') {p--; state = ST_COMMENT;}
+          break;
+
+          case ST_MNEMONIC:
+          if(strchr(" \t",p[1])) state = ST_PRE_ARGUMENT;
+          break;
+
+          case ST_PRE_ARGUMENT:
+          if(strchr(" \t",p[0]) == NULL)
+            {
+              if(p[0] == '\'') state = ST_TI_STRING;
+              else if(p[0] == '"') state = ST_GAS_STRING;              
+              else {state = ST_ARGUMENT; p--;}
+            }
+          break;
+
+          case ST_ARGUMENT:
+          if(p[0] == '>' && strchr("0123456789abcdefABCDEF",p[1])) p[0] = '$';
+          if(strchr(" \t,",p[1]))
+            {
+              if(p[0] == '*') {p--; state = ST_COMMENT;}
+              else state = ST_POST_ARGUMENT;
+            }
+          break;
+
+          case ST_POST_ARGUMENT:
+          if(strchr(" \t",p[0]) == NULL)
+            {
+              if(p[0] == ',') state = ST_PRE_ARGUMENT;
+              else {p--; state = ST_COMMENT;}
+            }
+          break;
+
+          case ST_TI_STRING:
+          if(p[0] == '\'' && p[1] == '\'') p++;  /* Skip escaped quote */
+          else if(p[0] == '\'') state = ST_POST_STRING;
+          break;
+
+          case ST_GAS_STRING:
+          if(p[0] == '\\' && p[1] == '"') p++;  /* Skip escaped quote */
+          else if(p[0] == '"') state = ST_POST_STRING;
+          break;
+
+          case ST_POST_STRING:
+          if(strchr(" \t",*p) == NULL)
+            {
+              if(*p == ',') state = ST_PRE_ARGUMENT;
+              else {p--; state = ST_COMMENT;}
+            }
+          break;
+
+          case ST_COMMENT:
+          memset(p, ' ', strcspn(p,"\n"));
+          state = ST_PRE_ARGUMENT;
+          break;
+        }
+    }
+  /* Remove trailing whitespace */
+  p = input_line_pointer;
+  p += strcspn(p,"\n");
+  char *line_end = p;
+  while(p > input_line_pointer && strchr(" \t\n",p[0])) p--;
+  if(p > input_line_pointer)
+    {
+      /* Remove characters occupied by trailing whitespace */
+      p++;
+      memmove(p,line_end,strlen(line_end)+1);
+      memset(&p[strlen(p)],0,line_end-p);
+    }
+
+  /* Check for <label>[:] [.](EQU|BES) <value>.  */
+  if (is_name_beginner (*input_line_pointer))
+    {
+      char c, *rest, *line_start;
+      int code;
+      int len = 3;  /* Length of directive */
+      symbolS * symbolP;
+
+      line_start = input_line_pointer;
+      LISTING_NEWLINE ();
+      if (ignore_input ())
+	return 0;
+
+      c = get_symbol_end ();
+      rest = input_line_pointer + 1;
+
+      if (*rest == ':')
+	++rest;
+      if (*rest == ' ' || *rest == '\t')
+	++rest;
+      if (*rest == '.')
+	++rest;
+      if (strncasecmp (rest, "EQU", 3) == 0)
+	code = 1;
+      else if (strncasecmp (rest, "BES", 3) == 0)
+        code = 2;
+      else
+	code = 0;
+
+      if (code && (rest[len] == ' ' || rest[len] == '\t'))
+	{
+          if ( code == 1)
+            {
+              /* This is an EQU operative */
+              /* Handle assignment here.  */
+              input_line_pointer = rest + len;
+              if (line_start[-1] == '\n')
+                bump_line_counters ();
+              /* Make sure we don't redefine an existing equate */
+              if ((symbolP = symbol_find (line_start)) != NULL) 
+                {
+                  if (S_IS_DEFINED (symbolP) || symbol_equated_p (symbolP))
+                    as_bad (_("symbol `%s' is already defined"), line_start);
+                }
+              equals (line_start, 1);
+              return 1;
+            }
+          else if ( code == 2)
+            {
+              /* This is a BES operative */
+              /* Allocate space */
+              input_line_pointer = rest + 3;
+              tms9900_bss(0);
+              /* Move label to after allocation */
+              while(rest-- > line_start)
+                {
+                  (input_line_pointer--)[-1] = rest[-1];
+                }
+            }
+	}
+      else
+	{
+	  /* Restore line and pointer.  */
+	  *input_line_pointer = c;
+	  input_line_pointer = line_start;
+	}
+    }
+  return 0;
+}
+
+
+int tms9900_parse_name(const char* name, struct expressionS* expr)
+{
+    struct reg_entry* regp;
+    regp = bsearch (&name, regtable, ARRAY_SIZE (regtable),
+                    sizeof (regtable[0]), key_regcmp);
+    if(regp && strcmp(name, regp->name)==0)
+    {
+      expr->X_op = O_register;
+      expr->X_add_number = regp->number;
+      input_line_pointer = (char*)name + strlen(regp->name);
+      return(1); 
+    }
+  return(0);
+}
+
+
+static char* assemble_mode(const char *line, short* opcode, expressionS* exp)
+{
+/*
+ Encodings for the Ts field of the opcode
+ 00 -  REG
+ 01 - *REG
+ 11 - *REG+
+ 10 - @EXP      reg=0
+ 10 - @EXP(REG)
+*/
+  char *p = (char*)line;
+  int open = 0;  /* No open paren around register */
+  int maybe_increment = 0;
+  *opcode = 0;
+  exp->X_op = O_absent;
+
+  if(*p == '*')
+    {
+      /* Indirect by register */
+      *opcode = 0x10;
+      maybe_increment = 1;
+      p++;
+    }
+  else if(*p == '@')
+    {
+      /* Indirect by expression */
+      *opcode = 0x20;
+      /* This is an expression, parse it */
+      input_line_pointer = ++p;
+      expression(exp);
+      p=input_line_pointer;
+      if(*p == '(')
+        {
+          open = 1;
+          p++;
+        }
+    }
+
+  if(*p != '*' &&
+     *p != ',' &&
+     *p != 0)
+    {
+      /* This term uses a register, let's find out which one */
+      struct reg_entry* regp;
+      regp = bsearch (&p, regtable, ARRAY_SIZE (regtable),
+                      sizeof (regtable[0]), key_regcmp);
+      if(regp)
+        {
+          *opcode |= regp->number;
+          p += strlen(regp->name);
+        }
+      else
+        {
+          /* Handle registers in numeric format */
+          unsigned int regnum=256;
+          if(sscanf(p,"%u", &regnum) && regnum < 16)
+            {
+              p++;
+              if(regnum > 9) p++;
+              *opcode |= regnum;
+            }
+          else
+            {
+              printf("Invalid register starting at \"%s\"\n",p);
+            }
+        }
+    }
+
+  /* Do we have register post increment? */
+  if(maybe_increment == 1 && *p == '+')
+    {
+      *opcode |= 0x20;
+      p++;
+    }
+  
+  /* Cleanup end of parameter */
+  if(open == 1)
+    {
+      if(*p == ')')  p++;
+        else printf("Unclosed paren around register\n");
+    }
+
+  input_line_pointer = p;        
+  return(p);
+}
+
+
+void tms9900_cons_fix_new (fragS *frag_p, int offset, int nbytes, expressionS *exp)
+{
+  bfd_reloc_code_real_type type = BFD_RELOC_16;
+  int pcrel = 0;
+  switch(nbytes)
+    {
+      case 1:
+        type = BFD_RELOC_8_PCREL;
+        pcrel = 1;
+      case 2:
+        fix_new_exp (frag_p, offset, nbytes, exp, pcrel, type);
+        break;
+
+      case 4:
+        /* Place relocation into low word. Leave high word as zero */
+        fix_new_exp (frag_p, offset+2, nbytes, exp, 0, type);
+        break;
+
+      default:
+        as_bad (_("unsupported BFD relocation size %u"), nbytes);
+    }
+}
+
+
+enum
+{
+  TEXT_DATAONLY = -1,
+  TEXT_PRESIZE  = -2,
+  TEXT_ZEROTERM = -3
+};
+
+
+static void
+tms9900_data (int size)
+{
+  const char *p;
+  char *u, quote;
+  int cnt;
+  expressionS exp;
+
+  if (is_it_end_of_statement ())
+    {
+      /* Handle instructions which only allocate space */
+      demand_empty_rest_of_line ();
+      if(size > 0)
+        {
+          u = frag_more (size);
+          memset (u, 0, size);
+        }
+      return;
+    }
+
+  /* Skip to data value */  
+  p = skip_space (input_line_pointer);
+
+  do
+    {
+      if (*p == '\"' || *p == '\'')
+	{
+          /* String constant, remove escape codes from string */
+          char q[1024];
+          char *out = q;
+          quote = *p++;
+          if(quote == '\'')
+          {
+            /* TI-style quote, only handle escaped quote character */
+            while(p[0] && (p[0] != '\'' || (p[0] == '\'' && p[1] == '\'')))
+              {
+                if(p[0] == '\'' && p[1] == '\'') p++;
+                *out++ = *p++;
+              }
+            if(p[0] == '\'') p++;
+          }
+          else
+          {
+             /* GAS-style quote, handle standard escape sequences */
+             int c;
+             input_line_pointer = p;
+             while (is_a_char (c = next_char_of_string ()))
+             {
+               *out++ = c;
+             }
+             p = input_line_pointer;
+          }
+          *out = 0;
+          cnt = out - q;
+
+          /* Check for length and validity */
+          if(size > 0)
+            {
+              if(cnt > size)
+                {
+                  as_warn(_("string constant too long"));
+                  cnt = size;
+                }
+              u = frag_more (size);
+              if(size == 2 && cnt == 1) u[1] = q[0];
+                else  memcpy (u, q, cnt);
+            }
+          else if(size == TEXT_DATAONLY)
+            {
+              u = frag_more (cnt);
+              memcpy (u, q, cnt);
+            }
+          else if(size == TEXT_PRESIZE)
+            {
+              if(cnt > 255)
+                {
+                  as_warn(_("string constant too long"));
+                  cnt = 255;
+                }
+              u = frag_more (cnt+1);
+              *u = cnt;             
+              memcpy (u + 1, q, cnt);
+            }
+          else if(size == TEXT_ZEROTERM)
+            {
+              u = frag_more (cnt + 1);
+              memcpy (u, q, cnt);
+              u[cnt] = 0;
+            }
+          if (!*p)
+            as_warn (_("unterminated string"));
+	}
+      else
+	{
+          /* This is a non-string value */
+          input_line_pointer = (char*)p;
+	  expression(&exp);
+          p = (const char*)input_line_pointer;
+	  if (exp.X_op == O_register)
+	    {
+	      break;
+	    }
+	  if (exp.X_op == O_constant)
+            {
+              int max;
+              int val = exp.X_add_number;
+              if(size < 0)
+                {
+                  break;
+                }
+              max = (1 << (size * 8)) - 1;
+              if(val > max || val < -max)
+                {
+                  as_warn(_("constant too big"));
+                  val = val & ((1 << (size * 8)) - 1);
+                }
+              u = frag_more (size);
+              if(size == 1)
+                {
+                  u[0] = val & 0xFF;
+                }
+              else
+                {
+                  u[0] = (val >> 8) & 0xFF;
+                  u[1] = val & 0xFF;
+                }
+            }
+          else if(exp.X_op == O_symbol &&
+                  size == 2)
+            {
+              u = frag_more(2);
+              fix_new_exp (frag_now,
+                           u - frag_now->fr_literal,
+                           2, &exp, 0,
+                           BFD_RELOC_16);
+
+            }
+	}
+       p = skip_space (p);
+    }
+  while (*p++ == ',');
+  input_line_pointer = (char *)(p-1);
+}
+
+static void
+tms9900_even (int unused ATTRIBUTE_UNUSED)
+{
+  /* Align to 16 bit boundary, fill with zeroes */
+  s_align_ptwo(1);
+}
+
+static void
+tms9900_bss (int unused ATTRIBUTE_UNUSED)
+{
+  expressionS exp;
+  expression(&exp);
+  if(exp.X_op == O_constant)
+    {
+      char* p = frag_more(exp.X_add_number);
+      memset(p, 0, exp.X_add_number);      
+    }
+  else
+    {
+      as_bad (_("junk at end of line, first unrecognized character is `%c'"),
+              *input_line_pointer);
+    }
+}
+
+static void
+tms9900_seg_bss (int unused ATTRIBUTE_UNUSED)
+{
+  subseg_set (bss_section,  now_subseg);
+  demand_empty_rest_of_line ();
+}
+
+static void
+tms9900_seg_data (int unused ATTRIBUTE_UNUSED)
+{
+  subseg_set (data_section,  now_subseg);
+  demand_empty_rest_of_line ();
+}
+
+static void
+tms9900_seg_text (int unused ATTRIBUTE_UNUSED)
+{
+  subseg_set (text_section,  now_subseg);
+  demand_empty_rest_of_line ();
+}
+
+/* Port specific pseudo ops.  */
+const pseudo_typeS md_pseudo_table[] =
+{
+  { ".bss",  tms9900_seg_bss, 0},
+  { ".data", tms9900_seg_data, 0},
+  { ".text", tms9900_seg_text, 0},
+
+
+  /* AORG is a commonly-used directive, but we will have to handle that
+     in the linker, since we can't assign a value for the target address
+     from within GAS. */
+  { "aorg",  s_ignore, 0},
+
+  /* TI convention for segments */
+  { "pseg",  tms9900_seg_text, 0},
+  { "pend",  s_ignore, 0},
+  { "cseg",  tms9900_seg_bss, 0},
+  { "cend",  tms9900_seg_text, 0},
+  { "dseg",  tms9900_seg_data, 0},
+  { "dend",  tms9900_seg_text, 0},
+
+  /* Reservation for data values */
+  { "bes",   tms9900_bss, 0},
+  { "bss",   tms9900_bss, 0},
+  { "byte",  tms9900_data, 1},
+  { "data",  tms9900_data, 2}, 
+  { "end",   s_ignore, 0},
+  { "def",   s_globl, 0},
+  { "even",  tms9900_even, 0},
+  { "ref",   s_ignore, 0},
+  
+  /* The SYM directive displays a list of all symbols, and their values */
+  { "sym",   s_ignore, 0},
+  { "ntext", tms9900_data, TEXT_PRESIZE},
+  { "text",  tms9900_data, TEXT_DATAONLY},
+  { "textz", tms9900_data, TEXT_ZEROTERM},
+
+  /* Aliases for the text drirectives */
+  { "nstring", tms9900_data, TEXT_PRESIZE},
+  { "string",  tms9900_data, TEXT_DATAONLY},
+  { "stringz", tms9900_data, TEXT_ZEROTERM},
+
+  { NULL, 0, 0 }
+} ;
+
+enum
+{
+  ARG_NONE,       /* No argument            */
+  ARG_MODE,       /* Addressing mode        */
+  ARG_OFFSET,     /* Branch offset          */
+  ARG_REGISTER,   /* Register number        */
+  ARG_IMMEDIATE,  /* 16-bit immediate value */
+  ARG_SHIFT,      /* Bit shift count        */
+  ARG_CRU_COUNT,  /* CRU bit count          */
+  ARG_CRU_DISP    /* CRU displacement       */
+};
+
+typedef struct _table_t
+{
+  char* name;
+  short opcode;
+  int arg[2];
+} table_t;
+
+static table_t instab[] =
+{
+  { "a",    0xA000, {ARG_MODE,      ARG_MODE}},
+  { "ab",   0xB000, {ARG_MODE,      ARG_MODE}},
+  { "abs",  0x0740, {ARG_MODE,      ARG_NONE}},
+  { "ai",   0x0220, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "andi", 0x0240, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "b",    0x0440, {ARG_MODE,      ARG_NONE}},
+  { "bl",   0x0680, {ARG_MODE,      ARG_NONE}},
+  { "blwp", 0x0400, {ARG_MODE,      ARG_NONE}},
+  { "c",    0x8000, {ARG_MODE,      ARG_MODE}},
+  { "cb",   0x9000, {ARG_MODE,      ARG_MODE}},
+  { "ci",   0x0280, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "ckof", 0x03C0, {ARG_NONE,      ARG_NONE}},
+  { "ckon", 0x03A0, {ARG_NONE,      ARG_NONE}},
+  { "clr",  0x04C0, {ARG_MODE,      ARG_NONE}},
+  { "coc",  0x2000, {ARG_MODE,      ARG_REGISTER}},
+  { "czc",  0x2400, {ARG_MODE,      ARG_REGISTER}},
+  { "dec",  0x0600, {ARG_MODE,      ARG_NONE}},
+  { "dect", 0x0640, {ARG_MODE,      ARG_NONE}},
+  { "div",  0x3C00, {ARG_MODE,      ARG_REGISTER}},
+  { "idle", 0x0340, {ARG_NONE,      ARG_NONE}},
+  { "inc",  0x0580, {ARG_MODE,      ARG_NONE}},
+  { "inct", 0x05C0, {ARG_MODE,      ARG_NONE}},
+  { "inv",  0x0540, {ARG_MODE,      ARG_NONE}},
+  { "jeq",  0x1300, {ARG_OFFSET,    ARG_NONE}},
+  { "jgt",  0x1500, {ARG_OFFSET,    ARG_NONE}},
+  { "jh",   0x1B00, {ARG_OFFSET,    ARG_NONE}},
+  { "jhe",  0x1400, {ARG_OFFSET,    ARG_NONE}},
+  { "jl",   0x1A00, {ARG_OFFSET,    ARG_NONE}},
+  { "jle",  0x1200, {ARG_OFFSET,    ARG_NONE}},
+  { "jlt",  0x1100, {ARG_OFFSET,    ARG_NONE}},
+  { "jmp",  0x1000, {ARG_OFFSET,    ARG_NONE}},
+  { "jnc",  0x1700, {ARG_OFFSET,    ARG_NONE}},
+  { "jne",  0x1600, {ARG_OFFSET,    ARG_NONE}},
+  { "jno",  0x1900, {ARG_OFFSET,    ARG_NONE}},
+  { "joc",  0x1800, {ARG_OFFSET,    ARG_NONE}},
+  { "jop",  0x1C00, {ARG_OFFSET,    ARG_NONE}},
+  { "ldcr", 0x3000, {ARG_MODE,      ARG_CRU_COUNT}},
+  { "li",   0x0200, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "limi", 0x0300, {ARG_IMMEDIATE, ARG_NONE}},
+  { "lrex", 0x03E0, {ARG_NONE,      ARG_NONE}},
+  { "lwpi", 0x02E0, {ARG_IMMEDIATE, ARG_NONE}},
+  { "mov",  0xC000, {ARG_MODE,      ARG_MODE}},
+  { "movb", 0xD000, {ARG_MODE,      ARG_MODE}},
+  { "mpy",  0x3800, {ARG_MODE,      ARG_REGISTER}},
+  { "neg",  0x0500, {ARG_MODE,      ARG_NONE}},
+  { "nop",  0x1000, {ARG_NONE,      ARG_NONE}},  /* Encoded as "jmp 0"  */
+  { "or",   0xE000, {ARG_MODE,      ARG_MODE}},  /* Encoded as "soc"    */
+  { "orb",  0xF000, {ARG_MODE,      ARG_MODE}},  /* Encoded as "socb"   */
+  { "ori",  0x0260, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "rset", 0x0360, {ARG_NONE,      ARG_NONE}},
+  { "rt",   0x045B, {ARG_NONE,      ARG_NONE}},  /* Encoded as "b *r11" */
+  { "rtwp", 0x0380, {ARG_NONE,      ARG_NONE}},
+  { "s",    0x6000, {ARG_MODE,      ARG_MODE}},
+  { "sb",   0x7000, {ARG_MODE,      ARG_MODE}},
+  { "sbo",  0x1D00, {ARG_CRU_DISP,  ARG_NONE}},
+  { "sbz",  0x1E00, {ARG_CRU_DISP,  ARG_NONE}},
+  { "seto", 0x0700, {ARG_MODE,      ARG_NONE}},
+  { "sla",  0x0A00, {ARG_REGISTER,  ARG_SHIFT}},
+  { "soc",  0xE000, {ARG_MODE,      ARG_MODE}},
+  { "socb", 0xF000, {ARG_MODE,      ARG_MODE}},
+  { "sra",  0x0800, {ARG_REGISTER,  ARG_SHIFT}},
+  { "src",  0x0B00, {ARG_REGISTER,  ARG_SHIFT}},
+  { "srl",  0x0900, {ARG_REGISTER,  ARG_SHIFT}},
+  { "stcr", 0x3400, {ARG_MODE,      ARG_CRU_COUNT}},
+  { "stst", 0x02C0, {ARG_REGISTER,  ARG_NONE}},
+  { "stwp", 0x02A0, {ARG_REGISTER,  ARG_NONE}},
+  { "swpb", 0x06C0, {ARG_MODE,      ARG_NONE}},
+  { "szc",  0x4000, {ARG_MODE,      ARG_MODE}},
+  { "szcb", 0x5000, {ARG_MODE,      ARG_MODE}},
+  { "tb",   0x1F00, {ARG_CRU_DISP,  ARG_NONE}},
+  { "x",    0x0480, {ARG_MODE,      ARG_NONE}},
+  { "xop",  0x2C00, {ARG_MODE,      ARG_REGISTER}},
+  { "xor",  0x2800, {ARG_MODE,      ARG_REGISTER}}
+};
+
+static int
+assemble_arg(int argtype, short *opcode, int *op_size, expressionS *exp)
+{
+  /* argtype - type of argument to parse
+     opcode  - bits to insert into opcode
+     op_size - size of opcode bits
+     expr    - expression for branch target or immediate value
+  */
+
+  char *start = input_line_pointer;
+
+  exp->X_op = O_absent;
+  *opcode = 0;
+  *op_size = 0;  
+  int valid = 0;
+
+  if(argtype == ARG_MODE)
+    {
+      assemble_mode(input_line_pointer, opcode, exp);
+      *op_size = 6;
+      valid = 1;
+    }
+  else if(argtype != ARG_NONE)
+    {
+      char *ptr = input_line_pointer;
+      expression(exp);
+      switch(argtype)
+        {
+          /* Branch offset */
+          case ARG_OFFSET:     
+            if(exp->X_op == O_constant ||
+               exp->X_op == O_symbol)
+              {
+                valid = 1;
+              }
+            if(exp->X_op == O_constant)
+              {
+                *opcode = (exp->X_add_number >> 1) & 0xFF;
+                *op_size = 8;
+                exp->X_op = O_absent;
+              }
+            break;
+
+          /* Register number */
+          case ARG_REGISTER:
+            if(exp->X_op == O_register ||
+               /* The expression parser cannot handle numeric registers.
+                  Instructions like "mov 1,2" must be handled here
+               */
+               (exp->X_op == O_constant &&
+                  (unsigned int)exp->X_add_number < 16))
+              {
+                *opcode = exp->X_add_number;
+                *op_size = 4;
+                exp->X_op = O_absent;
+                valid = 1;
+              }
+            else
+              {
+                as_bad (_("not a register '%s'"), start);
+              }
+            break;
+
+          /* 16-bit immediate value */
+          case ARG_IMMEDIATE:
+            if(exp->X_op == O_constant && *ptr++ == '\'')
+              {
+                /* Could be a constant like 'a' or 'ab'
+                   These values can be no longer than two characters.
+                   Since TI escapes the single quote by duplication,
+                   the code below is uglier than it needs to be.
+
+                   Expected translations:
+                     ''     -> 0x0027
+                     ''''   -> 0x0027
+                     '''''' -> 0x2727
+                */
+                int i, val = 0;
+                for(i = 0; i < 2; i++)
+                  {
+                    if(*ptr == '\'' && ptr[1] == '\'') ptr++;
+                    val = (val << 8) | *ptr++;
+                    if((*ptr == '\'' && ptr[1]!='\'') ||
+                       *ptr == 0    ||
+                       *ptr == '\n') break;
+                  }
+                if(*ptr == '\n' ||
+                   *ptr == 0) as_warn(_("unterminated string"));
+                else if(*ptr != '\'' ||
+                        (*ptr == '\'' && ptr[1] == '\''))
+                  {
+                    as_warn(_("constant too big"));
+                  }
+
+                /* Use the value we found */
+                exp->X_add_number = val;
+                valid = 1;
+              }
+            else if(exp->X_op == O_constant ||
+                    exp->X_op == O_symbol)
+              {
+                valid = 1;
+              }
+            else
+              {
+                as_bad (_("not a constant expression '%s'"), start);
+              }
+            break;
+
+          /* Bit shift count */
+          case ARG_SHIFT:
+            if(exp->X_op == O_constant ||
+               (exp->X_op == O_register && exp->X_add_number == 0))
+              {
+                *opcode = exp->X_add_number;
+                *op_size = 4;
+                exp->X_op = O_absent;
+                valid = 1;
+              }
+            break;
+
+          /* CRU bit count */
+          case ARG_CRU_COUNT:
+            if(exp->X_op == O_constant)
+              {
+                *opcode = exp->X_add_number;
+                *op_size = 4;
+                exp->X_op = O_absent;
+                valid = 1;
+              }
+            else
+              {
+                as_bad (_("not a constant expression '%s'"), input_line_pointer);
+              }
+            break;
+
+          /* CRU displacement */
+          case ARG_CRU_DISP:
+            if(exp->X_op == O_constant)
+              {
+                *opcode = exp->X_add_number;
+                *op_size = 8;
+                exp->X_op = O_absent;
+                valid = 1;
+              }
+            else
+              {
+                as_bad (_("not a constant expression '%s'"), input_line_pointer);
+              }
+            break;
+        }
+    }
+
+  if(input_line_pointer == start)
+    {
+      as_bad (_("missing argument"));
+      return(0);
+    }
+
+  /* If we found an invalid argument, revert everything done here */
+  if(valid == 0)
+    {
+      exp->X_op = O_absent;
+      input_line_pointer = start;
+    }
+  return(valid);
+}
+
+void
+md_assemble (char* str)
+{
+  const char *p;
+  char * old_ptr;
+  int i;
+  table_t *insp;
+  short opcode[2];
+  int op_size[2];
+  expressionS exp[2];              
+  char *out;
+  short insn;
+  int check_unex = 0;
+
+  err_flag = 0;
+  old_ptr = input_line_pointer;
+  p = skip_space (str);
+
+  /* Convert opcode to lowercase */
+  for (i = 0; (i < BUFLEN) && (ISALPHA (*p));)
+    buf[i++] = TOLOWER (*p++);
+
+  if (i == BUFLEN)
+    {
+      /* Opcode too long */
+      buf[BUFLEN-3] = buf[BUFLEN-2] = '.'; /* Mark opcode as abbreviated.  */
+      buf[BUFLEN-1] = 0;
+      as_bad (_("unknown instruction '%s'"), buf);
+    }
+  else if ((*p) && (!ISSPACE (*p)))
+    as_bad (_("syntax error"));
+  else 
+    {
+      /* Check for valid opcode */
+      buf[i] = 0;
+      p = skip_space (p);
+      key = buf;
+      
+      insp = bsearch (&key, instab, ARRAY_SIZE (instab),
+		    sizeof (instab[0]), key_cmp);
+      if (!insp)
+	as_bad (_("unknown instruction '%s'"), buf);
+      else
+	{
+          /* Skip to start of arguments, if we have any */
+          input_line_pointer = str + strlen(insp->name);
+          input_line_pointer = (char*)skip_space (input_line_pointer);
+
+          /* Initialize arguments */
+          for(i=0;i<2;i++)
+            {
+              exp[i].X_op = O_absent;
+              op_size[i] = 0;
+              opcode[i] = 0;
+            }
+
+          /* Parse arguments */
+          if(insp->arg[0] != ARG_NONE)
+            {
+              /* Parse first argument */
+              if(assemble_arg(insp->arg[0], &opcode[0], &op_size[0], &exp[0]) != 0)
+                {
+                  check_unex = 1;
+                  if(insp->arg[1] != ARG_NONE)
+                    {
+                      /* Parse second argument */
+                      if(*input_line_pointer != ',')
+                        {
+                          if(*input_line_pointer == 0)
+                            {
+                              as_bad(_("unexpected end of line"));
+                              check_unex = 0;
+                            }
+                          else
+                            {
+                              char str[64];
+                              sprintf(str, "unexpected character at \"%s\"",
+                                      input_line_pointer);
+                              as_bad(str);
+                              check_unex = 0;
+                            }
+                        }
+                      else
+                        {
+                          input_line_pointer++;
+                          if(assemble_arg(insp->arg[1], &opcode[1], &op_size[1], &exp[1]))
+                              /* Second argument is valid, rest is comment */
+                              check_unex = 0;
+                        }
+                    }
+                }           
+            }
+
+          /* Check for unexpected characters */
+          if(check_unex != 0 && 
+             *input_line_pointer != 0 && 
+             strspn(input_line_pointer, " *") == 0)
+            {
+              char str[64];
+              sprintf(str, "unexpected character at \"%s\"", input_line_pointer);
+              as_bad(str);
+            }
+
+          /* Make output instruction */
+          insn = insp->opcode | 
+                 opcode[0]    |
+                 (opcode[1] << op_size[0]);
+
+          out = frag_more(2);
+          *out++ = ((insn >> 8) & 0xFF);
+          *out   =  (insn       & 0xFF);
+
+          /* Insert extra words and fixups */
+          for(i=0; i<2; i++)
+            {
+              if(exp[i].X_op != O_absent)
+                {
+                  /* Assume no fixup required */
+                  int reloc_type = BFD_RELOC_NONE;
+                  int fix_size = 0;
+
+                  if(insp->arg[i] == ARG_OFFSET)
+                    {
+                      /* 8-bit PC-relative offset, stored in instruction */
+                      reloc_type = BFD_RELOC_8_PCREL;
+                      fix_size = 1;
+                    }
+                  else
+                    {
+                      /* 16-bit constant value, stored after instruction */
+                      unsigned short val = 0;
+                      out = frag_more(2);
+                      reloc_type = BFD_RELOC_16;
+                      fix_size = 2;
+                      if(exp[i].X_op == O_constant)
+                        {
+                          val = (exp[i].X_add_number & 0xFFFF);
+                          fix_size = 0;
+                        }
+                      out[0] = ((val >> 8) & 0xFF);
+                      out[1] =  (val       & 0xFF);      
+                    }
+
+                  if(fix_size != 0)
+                    {
+                      /* Fixup used for this instruction, configure it */
+                      fix_new_exp (frag_now,
+                                   out - frag_now->fr_literal,
+                                   fix_size,
+                                   &exp[i],
+                                   0,
+                                   reloc_type);
+                    }
+                }
+            }
+        }
+    }
+
+  input_line_pointer = old_ptr;
+}
+
+
+void
+md_operand (expressionS* exp ATTRIBUTE_UNUSED)
+{
+  printf("Unrecognized expression: \"%s\"\n", input_line_pointer);
+}
+
+
+void
+md_apply_fix (fixS * fixP, valueT* valP, segT seg ATTRIBUTE_UNUSED)
+{
+  long val = * (long *) valP;
+  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
+
+  switch (fixP->fx_r_type)
+    {
+    case BFD_RELOC_8_PCREL:
+      if (fixP->fx_addsy)
+        {
+          fixP->fx_no_overflow = 1;
+          fixP->fx_done = 0;
+        }
+      else
+        {
+	  fixP->fx_no_overflow = (-128 <= val && val < 128);
+	  if (!fixP->fx_no_overflow)
+            as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("relative jump out of range"));
+	  *buf++ = val;
+          fixP->fx_done = 1;
+        }
+      break;
+
+    case BFD_RELOC_16:
+      *buf++ = (val >> 8);
+      *buf++ = val;
+      fixP->fx_no_overflow = 1; 
+      if (fixP->fx_addsy == NULL)
+	fixP->fx_done = 1;
+      break;
+
+    default:
+      printf (_("md_apply_fix: unknown r_type 0x%x\n"), fixP->fx_r_type);
+      abort ();
+    }
+}
+
+/* GAS will call this to generate a reloc.  GAS will pass the
+   resulting reloc to `bfd_install_relocation'.  This currently works
+   poorly, as `bfd_install_relocation' often does the wrong thing, and
+   instances of `tc_gen_reloc' have been written to work around the
+   problems, which in turns makes it difficult to fix
+   `bfd_install_relocation'.  */
+
+/* If while processing a fixup, a reloc really
+   needs to be created then it is done here.  */
+
+arelent *
+tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED , fixS *fixp)
+{
+  arelent *reloc;
+
+  if (! bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type))
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("reloc %d not supported by object file format"),
+		    (int) fixp->fx_r_type);
+      return NULL;
+    }
+
+  reloc               = xmalloc (sizeof (arelent));
+  reloc->sym_ptr_ptr  = xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address      = fixp->fx_frag->fr_address + fixp->fx_where;
+  reloc->howto        = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+  reloc->addend       = fixp->fx_offset;
+
+  return reloc;
+}
+
diff -rupN binutils-2.19.1-original/gas/config/tc-tms9900.h binutils-2.19.1/gas/config/tc-tms9900.h
--- binutils-2.19.1-original/gas/config/tc-tms9900.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.19.1/gas/config/tc-tms9900.h	2024-03-11 22:39:48.168416528 -0400
@@ -0,0 +1,118 @@
+/* this is tc-tms9900.h
+   Copyright 2009 Eric Welser
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of .the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#ifndef TC_TMS9900
+#define TC_TMS9900
+
+#define TARGET_ARCH   bfd_arch_tms9900
+#define BFD_ARCH      TARGET_ARCH
+#define COFF_MAGIC    0x5A80
+#define TARGET_MACH   bfd_mach_tms9900
+#define TARGET_BYTES_BIG_ENDIAN  0
+#define LABELS_WITHOUT_COLONS 1
+
+
+#define TARGET_FORMAT "elf32-tms9900"
+
+/* If you define this macro, GAS will warn about the
+   use of nonstandard escape sequences in a string.  */
+#define ONLY_STANDARD_ESCAPES
+
+/* This should just call either `number_to_chars_bigendian' or
+   `number_to_chars_littleendian', whichever is appropriate.  On
+   targets like the MIPS which support options to change the
+   endianness, which function to call is a runtime decision.  On
+   other targets, `md_number_to_chars' can be a simple macro.  */
+#define md_number_to_chars number_to_chars_littleendian
+
+/* This is called when an unrecognized symbol is encountered while
+   parsing an expression. */
+#define md_parse_name(name, exp, mode, c) tms9900_parse_name (name, exp)
+
+/* This macro permits the processor to specify all characters which
+   may appears in an operand.  This will prevent the scrubber from
+   discarding meaningful whitespace in certain cases. */
+extern const char tms9900_symbol_chars[];
+#define tc_symbol_chars tms9900_symbol_chars
+
+extern const char tms9900_comment_chars[];
+#define tc_comment_chars tms9900_comment_chars
+
+
+#define TC_COUNT_RELOC(x) 1
+
+#define TC_COFF_FIX2RTYPE(fixP) tc_coff_fix2rtype (fixP)
+#define md_convert_frag(b,s,f)   as_fatal ("convert_frag called\n")
+#define md_estimate_size_before_relax(f,s) \
+  (as_fatal (_("estimate_size_before_relax called")), 1)
+
+/* Define some functions to be called by generic code.  */
+#define md_end               tms9900_md_end
+#define md_start_line_hook() { if (tms9900_start_line_hook ()) continue; }
+#define TC_CONS_FIX_NEW tms9900_cons_fix_new
+
+extern void tms9900_md_end (void);
+extern int tms9900_start_line_hook (void);
+extern void tms9900_cons_fix_new (fragS *, int, int, expressionS *);
+extern int tms9900_parse_name(const char *, struct expressionS *);
+
+/* We don't need to handle a broken .word directive. */
+#define WORKING_DOT_WORD
+
+/* If you define this macro, it means that `tc_gen_reloc' may return
+   multiple relocation entries for a single fixup.  In this case, the
+   return value of `tc_gen_reloc' is a pointer to a null terminated
+   array.  */
+#undef RELOC_EXPANSION_POSSIBLE
+
+/* No shared lib support, so we don't need to ensure
+   externally visible symbols can be overridden.  */
+#define EXTERN_FORCE_RELOC 0
+
+/* Values passed to md_apply_fix3 don't include the symbol value.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+
+#define LISTING_WORD_SIZE 2
+
+/* A single '=' is accepted as a comparison operator.  */
+#define O_SINGLE_EQ O_eq
+
+/* A '$' is used to refer to the current location or as a hex. prefix.  */
+#define DOLLAR_DOT
+#define DOLLAR_AMBIGU                1
+#define LOCAL_LABELS_FB              1
+#define LITERAL_PREFIXPERCENT_BIN
+#define NUMBERS_WITH_SUFFIX          1
+#define NO_PSEUDO_DOT                1
+/* We allow single quotes to delimit character constants as
+   well, but it is cleaner to handle that in tc-tms9900.c.  */
+#define SINGLE_QUOTE_STRINGS
+#define ONLY_STANDARD_ESCAPES
+
+/* An `.lcomm' directive with no explicit alignment parameter will
+   use this macro to set P2VAR to the alignment that a request for
+   SIZE bytes will have.  The alignment is expressed as a power of
+   two.  If no alignment should take place, the macro definition
+   should do nothing.  Some targets define a `.bss' directive that is
+   also affected by this macro.  The default definition will set
+   P2VAR to the truncated power of two of sizes up to eight bytes.  */
+#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR) (P2VAR) = 0
+
+#endif
diff -rupN binutils-2.19.1-original/gas/configure.tgt binutils-2.19.1/gas/configure.tgt
--- binutils-2.19.1-original/gas/configure.tgt	2008-10-02 04:07:17.000000000 -0400
+++ binutils-2.19.1/gas/configure.tgt	2024-03-11 22:39:48.084417588 -0400
@@ -81,6 +81,7 @@ case ${cpu} in
   strongarm*be)		cpu_type=arm endian=big ;;
   strongarm*b)		cpu_type=arm endian=big ;;
   strongarm*)		cpu_type=arm endian=little ;;
+  tsm9900*)             cpu_type=tms9900 endian=big ;;
   v850*)		cpu_type=v850 ;;
   x86_64*)		cpu_type=i386 arch=x86_64;;
   xscale*be|xscale*b)	cpu_type=arm endian=big ;;
@@ -384,6 +385,8 @@ case ${generic_target} in
   tic4x-*-* | c4x-*-*)			fmt=coff bfd_gas=yes ;;
   tic54x-*-* | c54x*-*-*)		fmt=coff bfd_gas=yes need_libm=yes;;
 
+  tms9900-*-*)				fmt=elf ;;
+
   v850-*-*)				fmt=elf ;;
   v850e-*-*)				fmt=elf ;;
   v850ea-*-*)				fmt=elf ;;
diff -rupN binutils-2.19.1-original/gas/doc/as.1 binutils-2.19.1/gas/doc/as.1
--- binutils-2.19.1-original/gas/doc/as.1	2008-10-02 04:28:57.000000000 -0400
+++ binutils-2.19.1/gas/doc/as.1	2024-03-11 22:39:48.116417184 -0400
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -46,23 +38,36 @@
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.    nr % 0
-.    rr F
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -128,7 +133,11 @@
 .\" ========================================================================
 .\"
 .IX Title "AS 1"
-.TH AS 1 "2008-10-02" "binutils-2.18.92" "GNU Development Tools"
+.TH AS 1 "2015-07-10" "binutils-2.19.1" "GNU Development Tools"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 AS \- the portable GNU assembler.
 .SH "SYNOPSIS"
@@ -185,7 +194,7 @@ as [\fB\-a\fR[\fBcdghlns\fR][=\fIfile\fR
 .PP
 \&\fITarget i386 options:\fR
    [\fB\-\-32\fR|\fB\-\-64\fR] [\fB\-n\fR]
-   [\fB\-march\fR=\fI\s-1CPU\s0\fR[+\fI\s-1EXTENSION\s0\fR...]] [\fB\-mtune\fR=\fI\s-1CPU\s0\fR] 
+   [\fB\-march\fR=\fI\s-1CPU\s0\fR[+\fI\s-1EXTENSION\s0\fR...]] [\fB\-mtune\fR=\fI\s-1CPU\s0\fR]
 .PP
 \&\fITarget i960 options:\fR
    [\fB\-ACA\fR|\fB\-ACA_A\fR|\fB\-ACB\fR|\fB\-ACC\fR|\fB\-AKA\fR|\fB\-AKB\fR|
@@ -256,7 +265,7 @@ as [\fB\-a\fR[\fBcdghlns\fR][=\fIfile\fR
 \&\fITarget \s-1PDP11\s0 options:\fR
    [\fB\-mpic\fR|\fB\-mno\-pic\fR] [\fB\-mall\fR] [\fB\-mno\-extensions\fR]
    [\fB\-m\fR\fIextension\fR|\fB\-mno\-\fR\fIextension\fR]
-   [\fB\-m\fR\fIcpu\fR] [\fB\-m\fR\fImachine\fR]  
+   [\fB\-m\fR\fIcpu\fR] [\fB\-m\fR\fImachine\fR]
 .PP
 \&\fITarget picoJava options:\fR
    [\fB\-mb\fR|\fB\-me\fR]
@@ -297,7 +306,7 @@ as [\fB\-a\fR[\fBcdghlns\fR][=\fIfile\fR
  [\fB\-\-rename\-section\fR \fIoldname\fR=\fInewname\fR]
 .SH "DESCRIPTION"
 .IX Header "DESCRIPTION"
-\&\s-1GNU\s0 \fBas\fR is really a family of assemblers.
+\&\s-1GNU \s0\fBas\fR is really a family of assemblers.
 If you use (or have used) the \s-1GNU\s0 assembler on one architecture, you
 should find a fairly similar environment when you use it on another
 architecture.  Each version has much in common with the others,
@@ -305,7 +314,7 @@ including object file formats, most asse
 \&\fIpseudo-ops\fR) and assembler syntax.
 .PP
 \&\fBas\fR is primarily intended to assemble the output of the
-\&\s-1GNU\s0 C compiler \f(CW\*(C`gcc\*(C'\fR for use by the linker
+\&\s-1GNU C\s0 compiler \f(CW\*(C`gcc\*(C'\fR for use by the linker
 \&\f(CW\*(C`ld\*(C'\fR.  Nevertheless, we've tried to make \fBas\fR
 assemble correctly everything that other assemblers for the same
 machine would assemble.
@@ -340,13 +349,13 @@ runs \fBas\fR automatically.  Warnings r
 that \fBas\fR could keep assembling a flawed program; errors report a
 grave problem that stops the assembly.
 .PP
-If you are invoking \fBas\fR via the \s-1GNU\s0 C compiler,
+If you are invoking \fBas\fR via the \s-1GNU C\s0 compiler,
 you can use the \fB\-Wa\fR option to pass arguments through to the assembler.
 The assembler arguments must be separated from each other (and the \fB\-Wa\fR)
 by commas.  For example:
 .PP
 .Vb 1
-\&        gcc -c -g -O -Wa,-alh,-L file.c
+\&        gcc \-c \-g \-O \-Wa,\-alh,\-L file.c
 .Ve
 .PP
 This passes two options to the assembler: \fB\-alh\fR (emit a listing to
@@ -365,7 +374,7 @@ assembler.)
 Read command-line options from \fIfile\fR.  The options read are
 inserted in place of the original @\fIfile\fR option.  If \fIfile\fR
 does not exist, or cannot be read, then the option will be treated
-literally, and not removed.  
+literally, and not removed.
 .Sp
 Options in \fIfile\fR are separated by whitespace.  A whitespace
 character may be included in an option by surrounding the entire
@@ -428,7 +437,7 @@ Define the symbol \fIsym\fR to be \fIval
 \&\fIvalue\fR must be an integer constant.  As in C, a leading \fB0x\fR
 indicates a hexadecimal value, and a leading \fB0\fR indicates an octal
 value.  The value of the symbol can be overridden inside a source file via the
-use of a \f(CW\*(C`.set\*(C'\fR pseudo\-op.
+use of a \f(CW\*(C`.set\*(C'\fR pseudo-op.
 .IP "\fB\-f\fR" 4
 .IX Item "-f"
 \&\*(L"fast\*(R"\-\-\-skip whitespace and comment preprocessing (assume source is
@@ -440,8 +449,8 @@ compiler output).
 .IX Item "--gen-debug"
 .PD
 Generate debugging information for each assembler source line using whichever
-debug format is preferred by the target.  This currently means either \s-1STABS\s0,
-\&\s-1ECOFF\s0 or \s-1DWARF2\s0.
+debug format is preferred by the target.  This currently means either \s-1STABS,
+ECOFF\s0 or \s-1DWARF2.\s0
 .IP "\fB\-\-gstabs\fR" 4
 .IX Item "--gstabs"
 Generate stabs debugging information for each assembler line.  This
@@ -665,11 +674,11 @@ is normally the M32R, but this option ch
 .IP "\fB\-\-warn\-explicit\-parallel\-conflicts or \-\-Wp\fR" 4
 .IX Item "--warn-explicit-parallel-conflicts or --Wp"
 Produce warning messages when questionable parallel constructs are
-encountered. 
+encountered.
 .IP "\fB\-\-no\-warn\-explicit\-parallel\-conflicts or \-\-Wnp\fR" 4
 .IX Item "--no-warn-explicit-parallel-conflicts or --Wnp"
 Do not produce warning messages when questionable parallel constructs are 
-encountered. 
+encountered.
 .PP
 The following options are available when as is configured for the
 Motorola 68000 series.
@@ -702,7 +711,7 @@ For details about the \s-1PDP\-11\s0 mac
 see \fBPDP\-11\-Options\fR.
 .IP "\fB\-mpic | \-mno\-pic\fR" 4
 .IX Item "-mpic | -mno-pic"
-Generate position-independent (or position\-dependent) code.  The
+Generate position-independent (or position-dependent) code.  The
 default is \fB\-mpic\fR.
 .IP "\fB\-mall\fR" 4
 .IX Item "-mall"
@@ -719,7 +728,7 @@ Disable all instruction set extensions.
 Enable (or disable) a particular instruction set extension.
 .IP "\fB\-m\fR\fIcpu\fR" 4
 .IX Item "-mcpu"
-Enable the instruction set extensions supported by a particular \s-1CPU\s0, and
+Enable the instruction set extensions supported by a particular \s-1CPU,\s0 and
 disable all other extensions.
 .IP "\fB\-m\fR\fImachine\fR" 4
 .IX Item "-mmachine"
@@ -743,16 +752,16 @@ Specify what processor is the target.  T
 defined by the configuration option when building the assembler.
 .IP "\fB\-mshort\fR" 4
 .IX Item "-mshort"
-Specify to use the 16\-bit integer \s-1ABI\s0.
+Specify to use the 16\-bit integer \s-1ABI.\s0
 .IP "\fB\-mlong\fR" 4
 .IX Item "-mlong"
-Specify to use the 32\-bit integer \s-1ABI\s0.  
+Specify to use the 32\-bit integer \s-1ABI.  \s0
 .IP "\fB\-mshort\-double\fR" 4
 .IX Item "-mshort-double"
-Specify to use the 32\-bit double \s-1ABI\s0.  
+Specify to use the 32\-bit double \s-1ABI.  \s0
 .IP "\fB\-mlong\-double\fR" 4
 .IX Item "-mlong-double"
-Specify to use the 64\-bit double \s-1ABI\s0.  
+Specify to use the 64\-bit double \s-1ABI.  \s0
 .IP "\fB\-\-force\-long\-branches\fR" 4
 .IX Item "--force-long-branches"
 Relative branches are turned into absolute ones. This concerns
@@ -790,7 +799,7 @@ Explicitly select a variant of the \s-1S
 \&\fB\-Av8plus\fR and \fB\-Av8plusa\fR select a 32 bit environment.
 \&\fB\-Av9\fR and \fB\-Av9a\fR select a 64 bit environment.
 .Sp
-\&\fB\-Av8plusa\fR and \fB\-Av9a\fR enable the \s-1SPARC\s0 V9 instruction set with
+\&\fB\-Av8plusa\fR and \fB\-Av9a\fR enable the \s-1SPARC V9\s0 instruction set with
 UltraSPARC extensions.
 .IP "\fB\-xarch=v8plus | \-xarch=v8plusa\fR" 4
 .IX Item "-xarch=v8plus | -xarch=v8plusa"
@@ -801,7 +810,7 @@ equivalent to \-Av8plus and \-Av8plusa,
 Warn when the assembler switches to another architecture.
 .PP
 The following options are available when as is configured for the 'c54x
-architecture. 
+architecture.
 .IP "\fB\-mfar\-mode\fR" 4
 .IX Item "-mfar-mode"
 Enable extended addressing mode.  All addresses and relocations will assume
@@ -854,7 +863,7 @@ alias for \fB\-march=r6000\fR, \fB\-mips
 \&\fB\-mips5\fR, \fB\-mips32\fR, \fB\-mips32r2\fR, \fB\-mips64\fR, and
 \&\fB\-mips64r2\fR
 correspond to generic
-\&\fB\s-1MIPS\s0 V\fR, \fB\s-1MIPS32\s0\fR, \fB\s-1MIPS32\s0 Release 2\fR, \fB\s-1MIPS64\s0\fR,
+\&\fB\s-1MIPS V\s0\fR, \fB\s-1MIPS32\s0\fR, \fB\s-1MIPS32\s0 Release 2\fR, \fB\s-1MIPS64\s0\fR,
 and \fB\s-1MIPS64\s0 Release 2\fR
 \&\s-1ISA\s0 processors, respectively.
 .IP "\fB\-march=\fR\fI\s-1CPU\s0\fR" 4
@@ -878,7 +887,7 @@ of an mfhi or mflo instruction occurs in
 .IX Item "-no-mdebug"
 .PD
 Cause stabs-style debugging output to go into an ECOFF-style .mdebug
-section instead of the standard \s-1ELF\s0 .stabs sections.
+section instead of the standard \s-1ELF \s0.stabs sections.
 .IP "\fB\-mpdr\fR" 4
 .IX Item "-mpdr"
 .PD 0
@@ -892,7 +901,7 @@ Control generation of \f(CW\*(C`.pdr\*(C
 .IP "\fB\-mfp32\fR" 4
 .IX Item "-mfp32"
 .PD
-The register sizes are normally inferred from the \s-1ISA\s0 and \s-1ABI\s0, but these
+The register sizes are normally inferred from the \s-1ISA\s0 and \s-1ABI,\s0 but these
 flags force a certain group of registers to be treated as 32 bits wide at
 all times.  \fB\-mgp32\fR controls the size of general-purpose registers
 and \fB\-mfp32\fR controls the size of floating-point registers.
@@ -902,7 +911,7 @@ and \fB\-mfp32\fR controls the size of f
 .IP "\fB\-no\-mips16\fR" 4
 .IX Item "-no-mips16"
 .PD
-Generate code for the \s-1MIPS\s0 16 processor.  This is equivalent to putting
+Generate code for the \s-1MIPS 16\s0 processor.  This is equivalent to putting
 \&\f(CW\*(C`.set mips16\*(C'\fR at the start of the assembly file.  \fB\-no\-mips16\fR
 turns off this option.
 .IP "\fB\-msmartmips\fR" 4
@@ -986,7 +995,7 @@ in the name.  Using \fB\-EB\fR or \fB\-E
 selection in any case.
 .Sp
 This option is currently supported only when the primary target
-\&\fBas\fR is configured for is a \s-1MIPS\s0 \s-1ELF\s0 or \s-1ECOFF\s0 target.
+\&\fBas\fR is configured for is a \s-1MIPS ELF\s0 or \s-1ECOFF\s0 target.
 Furthermore, the primary target or others specified with
 \&\fB\-\-enable\-targets=...\fR at configuration time must include support for
 the other format, if both are to be available.  For example, the Irix 5
@@ -1124,7 +1133,7 @@ Issue a warning for undocumented Z80 ins
 .IP "\fB\-Wup\fR" 4
 .IX Item "-Wup"
 .PD
-Issue a warning for undocumented Z80 instructions that do not work on R800.  
+Issue a warning for undocumented Z80 instructions that do not work on R800.
 .IP "\fB\-forbid\-undocumented\-instructions\fR" 4
 .IX Item "-forbid-undocumented-instructions"
 .PD 0
diff -rupN binutils-2.19.1-original/gprof/gprof.1 binutils-2.19.1/gprof/gprof.1
--- binutils-2.19.1-original/gprof/gprof.1	2008-09-10 03:50:23.000000000 -0400
+++ binutils-2.19.1/gprof/gprof.1	2024-03-11 22:39:48.276415165 -0400
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -46,23 +38,36 @@
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.    nr % 0
-.    rr F
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -128,7 +133,11 @@
 .\" ========================================================================
 .\"
 .IX Title "GPROF 1"
-.TH GPROF 1 "2008-09-10" "binutils-2.18.90" "GNU"
+.TH GPROF 1 "2015-07-10" "binutils-2.19.1" "GNU"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 gprof \- display call graph profile data
 .SH "SYNOPSIS"
@@ -179,11 +188,11 @@ The \fIcall graph\fR shows, for each fun
 other functions it called, and how many times.  There is also an estimate
 of how much time was spent in the subroutines of each function.  This can
 suggest places where you might try to eliminate function calls that use a
-lot of time.  
+lot of time.
 .PP
 The \fIannotated source\fR listing is a copy of the program's
 source code, labeled with the number of times each line of the
-program was executed.  
+program was executed.
 .SH "OPTIONS"
 .IX Header "OPTIONS"
 These options specify which of several output formats
@@ -192,7 +201,7 @@ These options specify which of several o
 Many of these options take an optional \fIsymspec\fR to specify
 functions to be included or excluded.  These options can be
 specified multiple times, with different symspecs, to include
-or exclude sets of symbols.  
+or exclude sets of symbols.
 .PP
 Specifying any of these options overrides the default (\fB\-p \-q\fR),
 which prints a flat profile and call graph analysis
@@ -349,7 +358,7 @@ default is 10.
 .PD
 This option affects annotated source output only.
 Normally, \f(CW\*(C`gprof\*(C'\fR prints annotated source files
-to standard\-output.  If this option is specified,
+to standard-output.  If this option is specified,
 annotated source for a file named \fIpath/\fIfilename\fI\fR
 is generated in the file \fI\fIfilename\fI\-ann\fR.  If the underlying
 file system would truncate \fI\fIfilename\fI\-ann\fR so that it
@@ -406,17 +415,17 @@ function name to object file mappings.
 the output of the program \f(CW\*(C`nm\*(C'\fR.
 .Sp
 .Vb 8
-\&        c-parse.o:00000000 T yyparse
-\&        c-parse.o:00000004 C yyerrflag
-\&        c-lang.o:00000000 T maybe_objc_method_name
-\&        c-lang.o:00000000 T print_lang_statistics
-\&        c-lang.o:00000000 T recognize_objc_keyword
-\&        c-decl.o:00000000 T print_lang_identifier
-\&        c-decl.o:00000000 T print_lang_type
+\&        c\-parse.o:00000000 T yyparse
+\&        c\-parse.o:00000004 C yyerrflag
+\&        c\-lang.o:00000000 T maybe_objc_method_name
+\&        c\-lang.o:00000000 T print_lang_statistics
+\&        c\-lang.o:00000000 T recognize_objc_keyword
+\&        c\-decl.o:00000000 T print_lang_identifier
+\&        c\-decl.o:00000000 T print_lang_type
 \&        ...
 .Ve
 .Sp
-To create a \fImap_file\fR with \s-1GNU\s0 \f(CW\*(C`nm\*(C'\fR, type a command like
+To create a \fImap_file\fR with \s-1GNU \s0\f(CW\*(C`nm\*(C'\fR, type a command like
 \&\f(CW\*(C`nm \-\-extern\-only \-\-defined\-only \-v \-\-print\-file\-name program\-name\*(C'\fR.
 .ie n .IP """\-T""" 4
 .el .IP "\f(CW\-T\fR" 4
@@ -466,7 +475,7 @@ printing output.  The default is to dema
 compilers have different mangling styles.  The optional demangling style 
 argument can be used to choose an appropriate demangling style for your 
 compiler.
-.Sh "Analysis Options"
+.SS "Analysis Options"
 .IX Subsection "Analysis Options"
 .ie n .IP """\-a""" 4
 .el .IP "\f(CW\-a\fR" 4
@@ -583,7 +592,7 @@ If you give the \fB\-z\fR option, \f(CW\
 functions in the flat profile, even those that were never called, and
 that had no time spent in them.  This is useful in conjunction with the
 \&\fB\-c\fR option for discovering which routines were never called.
-.Sh "Miscellaneous Options"
+.SS "Miscellaneous Options"
 .IX Subsection "Miscellaneous Options"
 .ie n .IP """\-d[\f(CInum\f(CW]""" 4
 .el .IP "\f(CW\-d[\f(CInum\f(CW]\fR" 4
@@ -642,46 +651,46 @@ cumulative data in the file \fIgmon.sum\
 .PD
 The \fB\-v\fR flag causes \f(CW\*(C`gprof\*(C'\fR to print the current version
 number, and then exit.
-.Sh "Deprecated Options"
+.SS "Deprecated Options"
 .IX Subsection "Deprecated Options"
 .RS 4
 These options have been replaced with newer versions that use symspecs.
-.RE
-.ie n .IP """\-e \f(CIfunction_name\f(CW""" 4
-.el .IP "\f(CW\-e \f(CIfunction_name\f(CW\fR" 4
-.IX Item "-e function_name"
+.Sp
+\&\f(CW\*(C`\-e \f(CIfunction_name\f(CW\*(C'\fR
+.Sp
 The \fB\-e\fR \fIfunction\fR option tells \f(CW\*(C`gprof\*(C'\fR to not print
 information about the function \fIfunction_name\fR (and its
 children...) in the call graph.  The function will still be listed
 as a child of any functions that call it, but its index number will be
 shown as \fB[not printed]\fR.  More than one \fB\-e\fR option may be
 given; only one \fIfunction_name\fR may be indicated with each \fB\-e\fR
-option. 
-.ie n .IP """\-E \f(CIfunction_name\f(CW""" 4
-.el .IP "\f(CW\-E \f(CIfunction_name\f(CW\fR" 4
-.IX Item "-E function_name"
+option.
+.Sp
+\&\f(CW\*(C`\-E \f(CIfunction_name\f(CW\*(C'\fR
+.Sp
 The \f(CW\*(C`\-E \f(CIfunction\f(CW\*(C'\fR option works like the \f(CW\*(C`\-e\*(C'\fR option, but
 time spent in the function (and children who were not called from
 anywhere else), will not be used to compute the percentages-of-time for
 the call graph.  More than one \fB\-E\fR option may be given; only one
 \&\fIfunction_name\fR may be indicated with each \fB\-E\fR option.
-.ie n .IP """\-f \f(CIfunction_name\f(CW""" 4
-.el .IP "\f(CW\-f \f(CIfunction_name\f(CW\fR" 4
-.IX Item "-f function_name"
+.Sp
+\&\f(CW\*(C`\-f \f(CIfunction_name\f(CW\*(C'\fR
+.Sp
 The \fB\-f\fR \fIfunction\fR option causes \f(CW\*(C`gprof\*(C'\fR to limit the
 call graph to the function \fIfunction_name\fR and its children (and
 their children...).  More than one \fB\-f\fR option may be given;
 only one \fIfunction_name\fR may be indicated with each \fB\-f\fR
-option.  
-.ie n .IP """\-F \f(CIfunction_name\f(CW""" 4
-.el .IP "\f(CW\-F \f(CIfunction_name\f(CW\fR" 4
-.IX Item "-F function_name"
+option.
+.Sp
+\&\f(CW\*(C`\-F \f(CIfunction_name\f(CW\*(C'\fR
+.Sp
 The \fB\-F\fR \fIfunction\fR option works like the \f(CW\*(C`\-f\*(C'\fR option, but
 only time spent in the function and its children (and their
 children...) will be used to determine total-time and
 percentages-of-time for the call graph.  More than one \fB\-F\fR option
 may be given; only one \fIfunction_name\fR may be indicated with each
 \&\fB\-F\fR option.  The \fB\-F\fR option overrides the \fB\-E\fR option.
+.RE
 .SH "FILES"
 .IX Header "FILES"
 .ie n .IP """\f(CIa.out\f(CW""" 4
@@ -695,7 +704,7 @@ dynamic call graph and profile.
 .ie n .IP """\f(CIgmon.sum\f(CW""" 4
 .el .IP "\f(CW\f(CIgmon.sum\f(CW\fR" 4
 .IX Item "gmon.sum"
-summarized dynamic call graph and profile.  
+summarized dynamic call graph and profile.
 .SH "BUGS"
 .IX Header "BUGS"
 The granularity of the sampling is shown, but remains
@@ -731,7 +740,7 @@ Vol. 13, pp. 671\-685, 1983.
 .PP
 \&\*(L"gprof: A Call Graph Execution Profiler\*(R",
 by S. Graham, P. Kessler, M. McKusick;
-Proceedings of the \s-1SIGPLAN\s0 '82 Symposium on Compiler Construction,
+Proceedings of the \s-1SIGPLAN \s0'82 Symposium on Compiler Construction,
 \&\s-1SIGPLAN\s0 Notices, Vol. 17, No  6, pp. 120\-126, June 1982.
 .SH "COPYRIGHT"
 .IX Header "COPYRIGHT"
diff -rupN binutils-2.19.1-original/include/dis-asm.h binutils-2.19.1/include/dis-asm.h
--- binutils-2.19.1-original/include/dis-asm.h	2008-07-07 14:40:13.000000000 -0400
+++ binutils-2.19.1/include/dis-asm.h	2024-03-11 22:39:46.800434122 -0400
@@ -275,6 +275,7 @@ extern int print_insn_tic30		(bfd_vma, d
 extern int print_insn_tic4x		(bfd_vma, disassemble_info *);
 extern int print_insn_tic54x		(bfd_vma, disassemble_info *);
 extern int print_insn_tic80		(bfd_vma, disassemble_info *);
+extern int print_insn_tms9900           (bfd_vma, disassemble_info *);
 extern int print_insn_v850		(bfd_vma, disassemble_info *);
 extern int print_insn_vax		(bfd_vma, disassemble_info *);
 extern int print_insn_w65		(bfd_vma, disassemble_info *);
diff -rupN binutils-2.19.1-original/include/elf/common.h binutils-2.19.1/include/elf/common.h
--- binutils-2.19.1-original/include/elf/common.h	2008-08-03 19:20:42.000000000 -0400
+++ binutils-2.19.1/include/elf/common.h	2024-03-11 22:39:46.792434227 -0400
@@ -334,6 +334,7 @@
 
 #define EM_CYGNUS_MEP		0xF00D  /* Toshiba MeP */
 
+#define EM_TMS9900		0xABBA
 /* See the above comment before you add a new EM_* value here.  */
 
 /* Values for e_version.  */
diff -rupN binutils-2.19.1-original/include/elf/tms9900.h binutils-2.19.1/include/elf/tms9900.h
--- binutils-2.19.1-original/include/elf/tms9900.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.19.1/include/elf/tms9900.h	2024-03-11 22:39:46.796434175 -0400
@@ -0,0 +1,32 @@
+/* ix86 ELF support for BFD.
+   Copyright 1998, 1999, 2000, 2002, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _ELF_TMS9900_H
+#define _ELF_TMS9900_H
+
+#include "elf/reloc-macros.h"
+
+START_RELOC_NUMBERS (elf_tms9900_reloc_type)
+     RELOC_NUMBER (R_TMS9900_NONE,      0)	/* No reloc */
+     RELOC_NUMBER (R_TMS9900_PC8,       1)	/* PC relative 8 bit */
+     RELOC_NUMBER (R_TMS9900_16,        2)	/* Direct 16 bit  */
+END_RELOC_NUMBERS (R_TMS9900_max)
+
+#endif
diff -rupN binutils-2.19.1-original/ld/configure.tgt binutils-2.19.1/ld/configure.tgt
--- binutils-2.19.1-original/ld/configure.tgt	2008-08-09 01:35:13.000000000 -0400
+++ binutils-2.19.1/ld/configure.tgt	2024-03-11 22:39:47.736422042 -0400
@@ -607,6 +607,8 @@ tic4x-*-* | c4x-*-*)    targ_emul=tic4xc
 tic54x-*-* | c54x*-*-*)	targ_emul=tic54xcoff ;;
 tic80-*-*)		targ_emul=tic80coff
 			;;
+tms9900-*-*)		targ_emul=tms9900
+			;;
 v850-*-*)		targ_emul=v850 ;;
 v850e-*-*)		targ_emul=v850 ;;
 v850ea-*-*)		targ_emul=v850
diff -rupN binutils-2.19.1-original/ld/emulparams/tms9900.sh binutils-2.19.1/ld/emulparams/tms9900.sh
--- binutils-2.19.1-original/ld/emulparams/tms9900.sh	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.19.1/ld/emulparams/tms9900.sh	2024-03-11 22:39:47.516424870 -0400
@@ -0,0 +1,6 @@
+SCRIPT_NAME=elf
+OUTPUT_FORMAT="elf32-tms9900"
+OUTPUT_ARCH="tms9900"
+TEXT_START_ADDR=0xA000
+TARGET_PAGE_SIZE=512
+ARCH=tms9900
diff -rupN binutils-2.19.1-original/ld/ld.1 binutils-2.19.1/ld/ld.1
--- binutils-2.19.1-original/ld/ld.1	2008-09-10 03:50:22.000000000 -0400
+++ binutils-2.19.1/ld/ld.1	2024-03-11 22:39:47.520424819 -0400
@@ -1,15 +1,7 @@
-.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
 .de Sp \" Vertical space (when we can't use .PP)
 .if t .sp .5v
 .if n .sp
@@ -25,11 +17,11 @@
 ..
 .\" Set up some character translations and predefined strings.  \*(-- will
 .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
 .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
 .ie n \{\
 .    ds -- \(*W-
@@ -46,23 +38,36 @@
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
 .\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.if \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.    nr % 0
-.    rr F
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -128,7 +133,11 @@
 .\" ========================================================================
 .\"
 .IX Title "LD 1"
-.TH LD 1 "2008-09-10" "binutils-2.18.90" "GNU Development Tools"
+.TH LD 1 "2015-07-10" "binutils-2.19.1" "GNU Development Tools"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
 .SH "NAME"
 ld \- The GNU linker
 .SH "SYNOPSIS"
@@ -152,7 +161,7 @@ This version of \fBld\fR uses the genera
 to operate on object files. This allows \fBld\fR to read, combine, and
 write object files in many different formats\-\-\-for example, \s-1COFF\s0 or
 \&\f(CW\*(C`a.out\*(C'\fR.  Different formats may be linked together to produce any
-available kind of object file.  
+available kind of object file.
 .PP
 Aside from its flexibility, the \s-1GNU\s0 linker is more helpful than other
 linkers in providing diagnostic information.  Many linkers abandon
@@ -172,7 +181,7 @@ object files on a standard, supported Un
 link a file \f(CW\*(C`hello.o\*(C'\fR:
 .PP
 .Vb 1
-\&        ld -o <output> /lib/crt0.o hello.o -lc
+\&        ld \-o <output> /lib/crt0.o hello.o \-lc
 .Ve
 .PP
 This tells \fBld\fR to produce a file called \fIoutput\fR as the
@@ -211,7 +220,7 @@ or an archive, but actually merely defin
 script in this way merely augments the main linker script, with the
 extra commands placed after the main script; use the \fB\-T\fR option
 to replace the default linker script entirely, but note the effect of
-the \f(CW\*(C`INSERT\*(C'\fR command.  
+the \f(CW\*(C`INSERT\*(C'\fR command.
 .PP
 For options whose names are a single letter,
 option arguments must either follow the option letter without intervening
@@ -240,7 +249,7 @@ prefixed by \fB\-Wl,\fR (or whatever is
 compiler driver) like this:
 .PP
 .Vb 1
-\&          gcc -Wl,--startgroup foo.o bar.o -Wl,--endgroup
+\&          gcc \-Wl,\-\-startgroup foo.o bar.o \-Wl,\-\-endgroup
 .Ve
 .PP
 This is important, because otherwise the compiler driver program may
@@ -253,7 +262,7 @@ linker:
 Read command-line options from \fIfile\fR.  The options read are
 inserted in place of the original @\fIfile\fR option.  If \fIfile\fR
 does not exist, or cannot be read, then the option will be treated
-literally, and not removed.  
+literally, and not removed.
 .Sp
 Options in \fIfile\fR are separated by whitespace.  A whitespace
 character may be included in an option by surrounding the entire
@@ -278,7 +287,7 @@ In the current release of \fBld\fR, this
 Intel 960 family of architectures.  In that \fBld\fR configuration, the
 \&\fIarchitecture\fR argument identifies the particular architecture in
 the 960 family, enabling some safeguards and modifying the
-archive-library search path.  
+archive-library search path.
 .Sp
 Future releases of \fBld\fR may support similar functionality for
 other architecture families.
@@ -316,7 +325,7 @@ You can also define the input format fro
 .IP "\fB\-\-mri\-script=\fR\fIMRI-commandfile\fR" 4
 .IX Item "--mri-script=MRI-commandfile"
 .PD
-For compatibility with linkers produced by \s-1MRI\s0, \fBld\fR accepts script
+For compatibility with linkers produced by \s-1MRI, \s0\fBld\fR accepts script
 files written in an alternate, restricted command language, described in
 the \s-1MRI\s0 Compatible Script Files section of \s-1GNU\s0 ld documentation.
 Introduce \s-1MRI\s0 script files with
@@ -347,14 +356,14 @@ program, rather than the default entry p
 named \fIentry\fR, the linker will try to parse \fIentry\fR as a number,
 and use that as the entry address (the number will be interpreted in
 base 10; you may use a leading \fB0x\fR for base 16, or a leading
-\&\fB0\fR for base 8).  
+\&\fB0\fR for base 8).
 .IP "\fB\-\-exclude\-libs\fR \fIlib\fR\fB,\fR\fIlib\fR\fB,...\fR" 4
 .IX Item "--exclude-libs lib,lib,..."
 Specifies a list of archive libraries from which symbols should not be automatically
 exported. The library names may be delimited by commas or colons.  Specifying
 \&\f(CW\*(C`\-\-exclude\-libs ALL\*(C'\fR excludes symbols in all archive libraries from
 automatic export.  This option is available only for the i386 \s-1PE\s0 targeted
-port of the linker and for \s-1ELF\s0 targeted ports.  For i386 \s-1PE\s0, symbols
+port of the linker and for \s-1ELF\s0 targeted ports.  For i386 \s-1PE,\s0 symbols
 explicitly listed in a .def file are still exported, regardless of this
 option.  For \s-1ELF\s0 targeted ports, symbols affected by this option will
 be treated as hidden.
@@ -454,7 +463,7 @@ Ignored.  Provided for compatibility wit
 .PD
 Set the maximum size of objects to be optimized using the \s-1GP\s0 register to
 \&\fIsize\fR.  This is only meaningful for object file formats such as
-\&\s-1MIPS\s0 \s-1ECOFF\s0 which supports putting large and small objects into different
+\&\s-1MIPS ECOFF\s0 which supports putting large and small objects into different
 sections.  This is ignored for other object file formats.
 .IP "\fB\-h\fR\fIname\fR" 4
 .IX Item "-hname"
@@ -510,7 +519,7 @@ archives multiple times.
 You may list the same archive multiple times on the command line.
 .Sp
 This type of archive searching is standard for Unix linkers.  However,
-if you are using \fBld\fR on \s-1AIX\s0, note that it is different from the
+if you are using \fBld\fR on \s-1AIX,\s0 note that it is different from the
 behaviour of the \s-1AIX\s0 linker.
 .IP "\fB\-L\fR\fIsearchdir\fR" 4
 .IX Item "-Lsearchdir"
@@ -531,7 +540,7 @@ by the \fIsysroot prefix\fR, a path spec
 .Sp
 The default set of paths searched (without being specified with
 \&\fB\-L\fR) depends on which emulation mode \fBld\fR is using, and in
-some cases also on how it was configured.  
+some cases also on how it was configured.
 .Sp
 The paths can also be specified in a link script with the
 \&\f(CW\*(C`SEARCH_DIR\*(C'\fR command.  Directories specified this way are searched
@@ -555,14 +564,14 @@ configured.
 Print a link map to the standard output.  A link map provides
 information about the link, including the following:
 .RS 4
-.IP "*" 4
+.IP "\(bu" 4
 Where object files are mapped into memory.
-.IP "*" 4
+.IP "\(bu" 4
 How common symbols are allocated.
-.IP "*" 4
+.IP "\(bu" 4
 All archive members included in the link, with a mention of the symbol
 which caused the archive member to be brought in.
-.IP "*" 4
+.IP "\(bu" 4
 The values assigned to symbols.
 .Sp
 Note \- symbols whose values are computed by an expression which
@@ -616,8 +625,8 @@ specification published by Microsoft.
 .IP "\fB\-\-no\-omagic\fR" 4
 .IX Item "--no-omagic"
 This option negates most of the effects of the \fB\-N\fR option.  It
-sets the text section to be read\-only, and forces the data segment to
-be page\-aligned.  Note \- this option does not enable linking against
+sets the text section to be read-only, and forces the data segment to
+be page-aligned.  Note \- this option does not enable linking against
 shared libraries.  Use \fB\-Bdynamic\fR for this.
 .IP "\fB\-o\fR \fIoutput\fR" 4
 .IX Item "-o output"
@@ -729,7 +738,7 @@ options accumulate.
 .IP "\fB\-\-default\-script=\fR\fIscriptfile\fR" 4
 .IX Item "--default-script=scriptfile"
 .PD
-Use \fIscriptfile\fR as the default linker script.  
+Use \fIscriptfile\fR as the default linker script.
 .Sp
 This option is similar to the \fB\-\-script\fR option except that
 processing of the script is delayed until after the rest of the
@@ -875,7 +884,7 @@ Marks the object can not be dumped by \f
 Marks the object as not requiring executable stack.
 .IP "\fBnorelro\fR" 4
 .IX Item "norelro"
-Don't create an \s-1ELF\s0 \f(CW\*(C`PT_GNU_RELRO\*(C'\fR segment header in the object.
+Don't create an \s-1ELF \s0\f(CW\*(C`PT_GNU_RELRO\*(C'\fR segment header in the object.
 .IP "\fBnow\fR" 4
 .IX Item "now"
 When generating an executable or shared library, mark it to tell the
@@ -888,7 +897,7 @@ first called.
 Marks the object may contain \f(CW$ORIGIN\fR.
 .IP "\fBrelro\fR" 4
 .IX Item "relro"
-Create an \s-1ELF\s0 \f(CW\*(C`PT_GNU_RELRO\*(C'\fR segment header in the object.
+Create an \s-1ELF \s0\f(CW\*(C`PT_GNU_RELRO\*(C'\fR segment header in the object.
 .IP "\fBmax\-page\-size=\fR\fIvalue\fR" 4
 .IX Item "max-page-size=value"
 Set the emulation maximum page size to \fIvalue\fR.
@@ -940,7 +949,7 @@ restore the old behaviour.
 .IP "\fB\-\-no\-as\-needed\fR" 4
 .IX Item "--no-as-needed"
 .PD
-This option affects \s-1ELF\s0 \s-1DT_NEEDED\s0 tags for dynamic libraries mentioned
+This option affects \s-1ELF DT_NEEDED\s0 tags for dynamic libraries mentioned
 on the command line after the \fB\-\-as\-needed\fR option.  Normally,
 the linker will add a \s-1DT_NEEDED\s0 tag for each dynamic library mentioned
 on the command line, regardless of whether the library is actually
@@ -954,8 +963,8 @@ which is undefined at the point that the
 .IP "\fB\-\-no\-add\-needed\fR" 4
 .IX Item "--no-add-needed"
 .PD
-This option affects the treatment of dynamic libraries from \s-1ELF\s0
-\&\s-1DT_NEEDED\s0 tags in dynamic libraries mentioned on the command line after
+This option affects the treatment of dynamic libraries from \s-1ELF
+DT_NEEDED\s0 tags in dynamic libraries mentioned on the command line after
 the \fB\-\-no\-add\-needed\fR option.  Normally, the linker will add
 a \s-1DT_NEEDED\s0 tag for each dynamic library from \s-1DT_NEEDED\s0 tags.
 \&\fB\-\-no\-add\-needed\fR causes \s-1DT_NEEDED\s0 tags will never be emitted
@@ -1277,7 +1286,7 @@ usual format on each machine.  \fIoutput
 name of a particular format supported by the \s-1BFD\s0 libraries.  (You can
 list the available binary formats with \fBobjdump \-i\fR.)  The script
 command \f(CW\*(C`OUTPUT_FORMAT\*(C'\fR can also specify the output format, but
-this option overrides it.  
+this option overrides it.
 .IP "\fB\-pie\fR" 4
 .IX Item "-pie"
 .PD 0
@@ -1356,7 +1365,7 @@ When using \s-1ELF\s0 or SunOS, one shar
 happens when an \f(CW\*(C`ld \-shared\*(C'\fR link includes a shared library as one
 of the input files.
 .Sp
-When the linker encounters such a dependency when doing a non\-shared,
+When the linker encounters such a dependency when doing a non-shared,
 non-relocatable link, it will automatically try to locate the required
 shared library and include it in the link, if it is not included
 explicitly.  In such a case, the \fB\-rpath\-link\fR option
@@ -1415,7 +1424,7 @@ warning and continue with the link.
 .IP "\fB\-Bshareable\fR" 4
 .IX Item "-Bshareable"
 .PD
-Create a shared library.  This is currently only supported on \s-1ELF\s0, \s-1XCOFF\s0
+Create a shared library.  This is currently only supported on \s-1ELF, XCOFF\s0
 and SunOS platforms.  On SunOS, the linker will automatically create a
 shared library if the \fB\-e\fR option is not used and there are
 undefined symbols in the link.
@@ -1424,7 +1433,7 @@ undefined symbols in the link.
 This option tells \fBld\fR to sort the common symbols by alignment in
 ascending or descending order when it places them in the appropriate output
 sections.  The symbol alignments considered are sixteen-byte or larger,
-eight\-byte, four\-byte, two\-byte, and one\-byte. This is to prevent gaps
+eight-byte, four-byte, two-byte, and one-byte. This is to prevent gaps
 between symbols due to alignment constraints.  If no sorting order is
 specified, then descending order is assumed.
 .IP "\fB\-\-sort\-section name\fR" 4
@@ -1582,7 +1591,7 @@ Turning a common symbol into a reference
 definition for the symbol.
 .Sp
 .Vb 3
-\&        <file>(<section>): warning: common of `<symbol>'
+\&        <file>(<section>): warning: common of \`<symbol>\*(Aq
 \&           overridden by definition
 \&        <file>(<section>): warning: defined here
 .Ve
@@ -1592,7 +1601,7 @@ the symbol is encountered.  This is the
 except that the symbols are encountered in a different order.
 .Sp
 .Vb 3
-\&        <file>(<section>): warning: definition of `<symbol>'
+\&        <file>(<section>): warning: definition of \`<symbol>\*(Aq
 \&           overriding common
 \&        <file>(<section>): warning: common is here
 .Ve
@@ -1601,14 +1610,14 @@ Merging a common symbol with a previous
 .Sp
 .Vb 3
 \&        <file>(<section>): warning: multiple common
-\&           of `<symbol>'
+\&           of \`<symbol>\*(Aq
 \&        <file>(<section>): warning: previous common is here
 .Ve
 .IP "4." 4
 Merging a common symbol with a previous larger common symbol.
 .Sp
 .Vb 3
-\&        <file>(<section>): warning: common of `<symbol>'
+\&        <file>(<section>): warning: common of \`<symbol>\*(Aq
 \&           overridden by larger common
 \&        <file>(<section>): warning: larger common is here
 .Ve
@@ -1618,7 +1627,7 @@ the same as the previous case, except th
 encountered in a different order.
 .Sp
 .Vb 3
-\&        <file>(<section>): warning: common of `<symbol>'
+\&        <file>(<section>): warning: common of \`<symbol>\*(Aq
 \&           overriding smaller common
 \&        <file>(<section>): warning: smaller common is here
 .Ve
@@ -1628,7 +1637,7 @@ encountered in a different order.
 .IP "\fB\-\-warn\-constructors\fR" 4
 .IX Item "--warn-constructors"
 Warn if any global constructors are used.  This is only useful for a few
-object file formats.  For formats like \s-1COFF\s0 or \s-1ELF\s0, the linker can not
+object file formats.  For formats like \s-1COFF\s0 or \s-1ELF,\s0 the linker can not
 detect the use of global constructors.
 .IP "\fB\-\-warn\-multiple\-gp\fR" 4
 .IX Item "--warn-multiple-gp"
@@ -1696,10 +1705,10 @@ Here is a trivial example:
 .Sp
 .Vb 6
 \&        void *
-\&        __wrap_malloc (size_t c)
+\&        _\|_wrap_malloc (size_t c)
 \&        {
 \&          printf ("malloc called with %zu\en", c);
-\&          return __real_malloc (c);
+\&          return _\|_real_malloc (c);
 \&        }
 .Ve
 .Sp
@@ -1715,15 +1724,15 @@ file as \f(CW\*(C`_\|_wrap_malloc\*(C'\f
 call before the linker has a chance to wrap it to \f(CW\*(C`malloc\*(C'\fR.
 .IP "\fB\-\-eh\-frame\-hdr\fR" 4
 .IX Item "--eh-frame-hdr"
-Request creation of \f(CW\*(C`.eh_frame_hdr\*(C'\fR section and \s-1ELF\s0
-\&\f(CW\*(C`PT_GNU_EH_FRAME\*(C'\fR segment header.
+Request creation of \f(CW\*(C`.eh_frame_hdr\*(C'\fR section and \s-1ELF
+\&\s0\f(CW\*(C`PT_GNU_EH_FRAME\*(C'\fR segment header.
 .IP "\fB\-\-enable\-new\-dtags\fR" 4
 .IX Item "--enable-new-dtags"
 .PD 0
 .IP "\fB\-\-disable\-new\-dtags\fR" 4
 .IX Item "--disable-new-dtags"
 .PD
-This linker can create the new dynamic tags in \s-1ELF\s0. But the older \s-1ELF\s0
+This linker can create the new dynamic tags in \s-1ELF.\s0 But the older \s-1ELF\s0
 systems may not understand them. If you specify
 \&\fB\-\-enable\-new\-dtags\fR, the dynamic tags will be created as needed.
 If you specify \fB\-\-disable\-new\-dtags\fR, no new dynamic tags will be
@@ -1739,9 +1748,9 @@ value can reduce the memory requirements
 .IP "\fB\-\-hash\-style=\fR\fIstyle\fR" 4
 .IX Item "--hash-style=style"
 Set the type of linker's hash table(s).  \fIstyle\fR can be either
-\&\f(CW\*(C`sysv\*(C'\fR for classic \s-1ELF\s0 \f(CW\*(C`.hash\*(C'\fR section, \f(CW\*(C`gnu\*(C'\fR for
-new style \s-1GNU\s0 \f(CW\*(C`.gnu.hash\*(C'\fR section or \f(CW\*(C`both\*(C'\fR for both
-the classic \s-1ELF\s0 \f(CW\*(C`.hash\*(C'\fR and new style \s-1GNU\s0 \f(CW\*(C`.gnu.hash\*(C'\fR
+\&\f(CW\*(C`sysv\*(C'\fR for classic \s-1ELF \s0\f(CW\*(C`.hash\*(C'\fR section, \f(CW\*(C`gnu\*(C'\fR for
+new style \s-1GNU \s0\f(CW\*(C`.gnu.hash\*(C'\fR section or \f(CW\*(C`both\*(C'\fR for both
+the classic \s-1ELF \s0\f(CW\*(C`.hash\*(C'\fR and new style \s-1GNU \s0\f(CW\*(C`.gnu.hash\*(C'\fR
 hash tables.  The default is \f(CW\*(C`sysv\*(C'\fR.
 .IP "\fB\-\-reduce\-memory\-overheads\fR" 4
 .IX Item "--reduce-memory-overheads"
@@ -1837,7 +1846,7 @@ mismatches are considered to be errors.
 .IP "\fB\-\-export\-all\-symbols\fR" 4
 .IX Item "--export-all-symbols"
 If given, all global symbols in the objects used to build a \s-1DLL\s0 will
-be exported by the \s-1DLL\s0.  Note that this is the default if there
+be exported by the \s-1DLL. \s0 Note that this is the default if there
 otherwise wouldn't be any exported symbols.  When symbols are
 explicitly exported via \s-1DEF\s0 files or implicitly exported via function
 attributes, the default is to not export anything else unless this
@@ -1845,7 +1854,7 @@ option is given.  Note that the symbols
 \&\f(CW\*(C`DllEntryPoint@0\*(C'\fR, \f(CW\*(C`DllMainCRTStartup@12\*(C'\fR, and
 \&\f(CW\*(C`impure_ptr\*(C'\fR will not be automatically
 exported.  Also, symbols imported from other DLLs will not be
-re\-exported, nor will symbols specifying the \s-1DLL\s0's internal layout
+re-exported, nor will symbols specifying the \s-1DLL\s0's internal layout
 such as those beginning with \f(CW\*(C`_head_\*(C'\fR or ending with
 \&\f(CW\*(C`_iname\*(C'\fR.  In addition, no symbols from \f(CW\*(C`libgcc\*(C'\fR,
 \&\f(CW\*(C`libstd++\*(C'\fR, \f(CW\*(C`libmingw32\*(C'\fR, or \f(CW\*(C`crtX.o\*(C'\fR will be exported.
@@ -1900,7 +1909,7 @@ If given, the appropriate bit in the \*(
 header is set to indicate that this executable supports virtual addresses
 greater than 2 gigabytes.  This should be used in conjunction with the /3GB
 or /USERVA=\fIvalue\fR megabytes switch in the \*(L"[operating systems]\*(R"
-section of the \s-1BOOT\s0.INI.  Otherwise, this bit has no effect.
+section of the \s-1BOOT.INI. \s0 Otherwise, this bit has no effect.
 [This option is specific to \s-1PE\s0 targeted ports of the linker]
 .IP "\fB\-\-major\-image\-version\fR \fIvalue\fR" 4
 .IX Item "--major-image-version value"
@@ -1947,7 +1956,7 @@ creation step.
 .IX Item "--enable-auto-image-base"
 Automatically choose the image base for DLLs, unless one is specified
 using the \f(CW\*(C`\-\-image\-base\*(C'\fR argument.  By using a hash generated
-from the dllname to create unique image bases for each \s-1DLL\s0, in-memory
+from the dllname to create unique image bases for each \s-1DLL,\s0 in-memory
 collisions and relocations which can delay program execution are
 avoided.
 [This option is specific to the i386 \s-1PE\s0 targeted port of the linker]
@@ -1984,14 +1993,14 @@ http://www.cygwin.com/ml/cygwin/2004\-09
 Using 'auto\-import' generally will 'just work' \*(-- but sometimes you may
 see this message:
 .Sp
-"variable '<var>' can't be auto\-imported. Please read the
+"variable '<var>' can't be auto-imported. Please read the
 documentation for ld's \f(CW\*(C`\-\-enable\-auto\-import\*(C'\fR for details."
 .Sp
 This message occurs when some (sub)expression accesses an address
 ultimately given by the sum of two constants (Win32 import tables only
 allow one).  Instances where this may occur include accesses to member
-fields of struct variables imported from a \s-1DLL\s0, as well as using a
-constant index into an array variable imported from a \s-1DLL\s0.  Any
+fields of struct variables imported from a \s-1DLL,\s0 as well as using a
+constant index into an array variable imported from a \s-1DLL. \s0 Any
 multiword variable (arrays, structs, long long, etc) may trigger
 this error condition.  However, regardless of the exact data type
 of the offending exported variable, ld will always detect it, issue
@@ -2011,7 +2020,7 @@ a variable, or b) make the 'constant' in
 .Sp
 .Vb 3
 \&        extern type extern_array[];
-\&        extern_array[1] -->
+\&        extern_array[1] \-\->
 \&           { volatile type *t=extern_array; t[1] }
 .Ve
 .Sp
@@ -2019,7 +2028,7 @@ or
 .Sp
 .Vb 3
 \&        extern type extern_array[];
-\&        extern_array[1] -->
+\&        extern_array[1] \-\->
 \&           { volatile int t=1; extern_array[t] }
 .Ve
 .Sp
@@ -2028,15 +2037,15 @@ is to make the struct itself (or the lon
 .Sp
 .Vb 3
 \&        extern struct s extern_struct;
-\&        extern_struct.field -->
-\&           { volatile struct s *t=&extern_struct; t->field }
+\&        extern_struct.field \-\->
+\&           { volatile struct s *t=&extern_struct; t\->field }
 .Ve
 .Sp
 or
 .Sp
 .Vb 3
 \&        extern long long extern_ll;
-\&        extern_ll -->
+\&        extern_ll \-\->
 \&          { volatile long long * local_ll=&extern_ll; *local_ll }
 .Ve
 .Sp
@@ -2044,7 +2053,7 @@ A third method of dealing with this diff
 \&'auto\-import' for the offending symbol and mark it with
 \&\f(CW\*(C`_\|_declspec(dllimport)\*(C'\fR.  However, in practise that
 requires using compile-time #defines to indicate whether you are
-building a \s-1DLL\s0, building client code that will link to the \s-1DLL\s0, or
+building a \s-1DLL,\s0 building client code that will link to the \s-1DLL,\s0 or
 merely building/linking to a static library.   In making the choice
 between the various methods of resolving the 'direct address with
 constant offset' problem, you should consider typical real-world usage:
@@ -2052,9 +2061,9 @@ constant offset' problem, you should con
 Original:
 .Sp
 .Vb 7
-\&        --foo.h
+\&        \-\-foo.h
 \&        extern int arr[];
-\&        --foo.c
+\&        \-\-foo.c
 \&        #include "foo.h"
 \&        void main(int argc, char **argv){
 \&          printf("%d\en",arr[1]);
@@ -2064,9 +2073,9 @@ Original:
 Solution 1:
 .Sp
 .Vb 9
-\&        --foo.h
+\&        \-\-foo.h
 \&        extern int arr[];
-\&        --foo.c
+\&        \-\-foo.c
 \&        #include "foo.h"
 \&        void main(int argc, char **argv){
 \&          /* This workaround is for win32 and cygwin; do not "optimize" */
@@ -2077,17 +2086,17 @@ Solution 1:
 .Sp
 Solution 2:
 .Sp
-.Vb 14
-\&        --foo.h
-\&        /* Note: auto-export is assumed (no __declspec(dllexport)) */
-\&        #if (defined(_WIN32) || defined(__CYGWIN__)) && \e
+.Vb 10
+\&        \-\-foo.h
+\&        /* Note: auto\-export is assumed (no _\|_declspec(dllexport)) */
+\&        #if (defined(_WIN32) || defined(_\|_CYGWIN_\|_)) && \e
 \&          !(defined(FOO_BUILD_DLL) || defined(FOO_STATIC))
-\&        #define FOO_IMPORT __declspec(dllimport)
+\&        #define FOO_IMPORT _\|_declspec(dllimport)
 \&        #else
 \&        #define FOO_IMPORT
 \&        #endif
 \&        extern FOO_IMPORT int arr[];
-\&        --foo.c
+\&        \-\-foo.c
 \&        #include "foo.h"
 \&        void main(int argc, char **argv){
 \&          printf("%d\en",arr[1]);
@@ -2188,7 +2197,7 @@ this method often succeeds, but there ar
 there is no method of ensuring that the magic number used to specify
 object-file formats is unique.  However, the configuration procedure for
 \&\s-1BFD\s0 on each system places the conventional format for that system first
-in the search\-list, so ambiguities are resolved in favor of convention.
+in the search-list, so ambiguities are resolved in favor of convention.
 .PP
 \&\f(CW\*(C`LDEMULATION\*(C'\fR determines the default emulation if you don't use the
 \&\fB\-m\fR option.  The emulation can affect various aspects of linker
diff -rupN binutils-2.19.1-original/ld/ldlex.c binutils-2.19.1/ld/ldlex.c
--- binutils-2.19.1-original/ld/ldlex.c	2008-09-10 03:50:23.000000000 -0400
+++ binutils-2.19.1/ld/ldlex.c	2024-03-11 22:39:47.736422042 -0400
@@ -8,7 +8,7 @@
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 31
+#define YY_FLEX_SUBMINOR_VERSION 39
 #if YY_FLEX_SUBMINOR_VERSION > 0
 #define FLEX_BETA
 #endif
@@ -30,7 +30,15 @@
 
 /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
 
-#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
 #include <inttypes.h>
 typedef int8_t flex_int8_t;
 typedef uint8_t flex_uint8_t;
@@ -45,7 +53,6 @@ typedef int flex_int32_t;
 typedef unsigned char flex_uint8_t; 
 typedef unsigned short int flex_uint16_t;
 typedef unsigned int flex_uint32_t;
-#endif /* ! C99 */
 
 /* Limits of integral types. */
 #ifndef INT8_MIN
@@ -76,6 +83,8 @@ typedef unsigned int flex_uint32_t;
 #define UINT32_MAX             (4294967295U)
 #endif
 
+#endif /* ! C99 */
+
 #endif /* ! FLEXINT_H */
 
 #ifdef __cplusplus
@@ -85,11 +94,12 @@ typedef unsigned int flex_uint32_t;
 
 #else	/* ! __cplusplus */
 
-#if __STDC__
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
 
 #define YY_USE_CONST
 
-#endif	/* __STDC__ */
+#endif	/* defined (__STDC__) */
 #endif	/* ! __cplusplus */
 
 #ifdef YY_USE_CONST
@@ -131,7 +141,15 @@ typedef unsigned int flex_uint32_t;
 
 /* Size of default input buffer. */
 #ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
 #define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
 #endif
 
 /* The state buf must be large enough to hold one state per character in the main buffer.
@@ -143,7 +161,12 @@ typedef unsigned int flex_uint32_t;
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
 #endif
 
-extern int yyleng;
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+extern yy_size_t yyleng;
 
 extern FILE *yyin, *yyout;
 
@@ -152,6 +175,7 @@ extern FILE *yyin, *yyout;
 #define EOB_ACT_LAST_MATCH 2
 
     #define YY_LESS_LINENO(n)
+    #define YY_LINENO_REWIND_TO(ptr)
     
 /* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
@@ -169,16 +193,6 @@ extern FILE *yyin, *yyout;
 
 #define unput(c) yyunput( c, (yytext_ptr)  )
 
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef unsigned int yy_size_t;
-#endif
-
 #ifndef YY_STRUCT_YY_BUFFER_STATE
 #define YY_STRUCT_YY_BUFFER_STATE
 struct yy_buffer_state
@@ -196,7 +210,7 @@ struct yy_buffer_state
 	/* Number of characters read into yy_ch_buf, not including EOB
 	 * characters.
 	 */
-	int yy_n_chars;
+	yy_size_t yy_n_chars;
 
 	/* Whether we "own" the buffer - i.e., we know we created it,
 	 * and can realloc() it to grow it, and should free() it to
@@ -266,12 +280,12 @@ static YY_BUFFER_STATE * yy_buffer_stack
 
 /* yy_hold_char holds the character lost when yytext is formed. */
 static char yy_hold_char;
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-int yyleng;
+static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
+yy_size_t yyleng;
 
 /* Points to current character in buffer. */
 static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
+static int yy_init = 0;		/* whether we need to initialize */
 static int yy_start = 0;	/* start state number */
 
 /* Flag which is used to allow yywrap()'s to do buffer switches
@@ -295,7 +309,7 @@ static void yy_init_buffer (YY_BUFFER_ST
 
 YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
 YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
 
 void *yyalloc (yy_size_t  );
 void *yyrealloc (void *,yy_size_t  );
@@ -334,6 +348,9 @@ FILE *yyin = (FILE *) 0, *yyout = (FILE
 typedef int yy_state_type;
 
 extern int yylineno;
+
+int yylineno = 1;
+
 extern char *yytext;
 #define yytext_ptr yytext
 
@@ -1633,7 +1650,7 @@ int yywrap (void) { return 1; }
 
 
 
-#line 1637 "ldlex.c"
+#line 1654 "ldlex.c"
 
 #define INITIAL 0
 #define SCRIPT 1
@@ -1645,16 +1662,49 @@ int yywrap (void) { return 1; }
 #define VERS_SCRIPT 7
 #define VERS_NODE 8
 
+#ifndef YY_NO_UNISTD_H
 /* Special case for "unistd.h", since it is non-ANSI. We include it way
  * down here because we want the user's section 1 to have been scanned first.
  * The user has a chance to override it with an option.
  */
 #include <unistd.h>
+#endif
 
 #ifndef YY_EXTRA_TYPE
 #define YY_EXTRA_TYPE void *
 #endif
 
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+yy_size_t yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
  */
@@ -1689,7 +1739,12 @@ static int input (void );
 
 /* Amount of stuff to slurp up with each read. */
 #ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
 #define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
@@ -1697,7 +1752,7 @@ static int input (void );
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -1790,30 +1845,9 @@ YY_DECL
 	register char *yy_cp, *yy_bp;
 	register int yy_act;
     
-#line 117 "ldlex.l"
-
-
-  if (parser_input != input_selected)
-    {
-      /* The first token of the input determines the initial parser state.  */
-      input_type t = parser_input;
-      parser_input = input_selected;
-      switch (t)
-	{
-	case input_script: return INPUT_SCRIPT; break;
-	case input_mri_script: return INPUT_MRI_SCRIPT; break;
-	case input_version_script: return INPUT_VERSION_SCRIPT; break;
-	case input_dynamic_list: return INPUT_DYNAMIC_LIST; break;
-	case input_defsym: return INPUT_DEFSYM; break;
-	default: abort ();
-	}
-    }
-
-#line 1813 "ldlex.c"
-
-	if ( (yy_init) )
+	if ( !(yy_init) )
 		{
-		(yy_init) = 0;
+		(yy_init) = 1;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
@@ -1837,6 +1871,28 @@ YY_DECL
 		yy_load_buffer_state( );
 		}
 
+	{
+#line 117 "ldlex.l"
+
+
+  if (parser_input != input_selected)
+    {
+      /* The first token of the input determines the initial parser state.  */
+      input_type t = parser_input;
+      parser_input = input_selected;
+      switch (t)
+	{
+	case input_script: return INPUT_SCRIPT; break;
+	case input_mri_script: return INPUT_MRI_SCRIPT; break;
+	case input_version_script: return INPUT_VERSION_SCRIPT; break;
+	case input_dynamic_list: return INPUT_DYNAMIC_LIST; break;
+	case input_defsym: return INPUT_DEFSYM; break;
+	default: abort ();
+	}
+    }
+
+#line 1895 "ldlex.c"
+
 	while ( 1 )		/* loops until end-of-file is reached */
 		{
 		yy_cp = (yy_c_buf_p);
@@ -1853,7 +1909,7 @@ YY_DECL
 yy_match:
 		do
 			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
 			if ( yy_accept[yy_current_state] )
 				{
 				(yy_last_accepting_state) = yy_current_state;
@@ -2971,7 +3027,7 @@ YY_RULE_SETUP
 #line 463 "ldlex.l"
 ECHO;
 	YY_BREAK
-#line 2975 "ldlex.c"
+#line 3031 "ldlex.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -3100,6 +3156,7 @@ ECHO;
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
+	} /* end of user's declarations */
 } /* end of yylex */
 
 /* yy_get_next_buffer - try to read in a new buffer
@@ -3155,21 +3212,21 @@ static int yy_get_next_buffer (void)
 
 	else
 		{
-			size_t num_to_read =
+			yy_size_t num_to_read =
 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
 			{ /* Not enough room in the buffer - grow it. */
 
 			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
 
 			int yy_c_buf_p_offset =
 				(int) ((yy_c_buf_p) - b->yy_ch_buf);
 
 			if ( b->yy_is_our_buffer )
 				{
-				int new_size = b->yy_buf_size * 2;
+				yy_size_t new_size = b->yy_buf_size * 2;
 
 				if ( new_size <= 0 )
 					b->yy_buf_size += b->yy_buf_size / 8;
@@ -3224,6 +3281,14 @@ static int yy_get_next_buffer (void)
 	else
 		ret_val = EOB_ACT_CONTINUE_SCAN;
 
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
 	(yy_n_chars) += number_to_move;
 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
@@ -3287,7 +3352,7 @@ static int yy_get_next_buffer (void)
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 	yy_is_jam = (yy_current_state == 1566);
 
-	return yy_is_jam ? 0 : yy_current_state;
+		return yy_is_jam ? 0 : yy_current_state;
 }
 
     static void yyunput (int c, register char * yy_bp )
@@ -3302,7 +3367,7 @@ static int yy_get_next_buffer (void)
 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 		{ /* need to shift things up to make room */
 		/* +2 for EOB chars. */
-		register int number_to_move = (yy_n_chars) + 2;
+		register yy_size_t number_to_move = (yy_n_chars) + 2;
 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
 		register char *source =
@@ -3351,7 +3416,7 @@ static int yy_get_next_buffer (void)
 
 		else
 			{ /* need more input */
-			int offset = (yy_c_buf_p) - (yytext_ptr);
+			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
 			++(yy_c_buf_p);
 
 			switch ( yy_get_next_buffer(  ) )
@@ -3511,10 +3576,6 @@ static void yy_load_buffer_state  (void)
 	yyfree((void *) b  );
 }
 
-#ifndef __cplusplus
-extern int isatty (int );
-#endif /* __cplusplus */
-    
 /* Initializes or reinitializes a buffer.
  * This function is sometimes called more than once on the same buffer,
  * such as during a yyrestart() or at EOF.
@@ -3627,7 +3688,7 @@ void yypop_buffer_state (void)
  */
 static void yyensure_buffer_stack (void)
 {
-	int num_to_alloc;
+	yy_size_t num_to_alloc;
     
 	if (!(yy_buffer_stack)) {
 
@@ -3639,7 +3700,9 @@ static void yyensure_buffer_stack (void)
 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
 								(num_to_alloc * sizeof(struct yy_buffer_state*)
 								);
-		
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
 				
 		(yy_buffer_stack_max) = num_to_alloc;
@@ -3657,6 +3720,8 @@ static void yyensure_buffer_stack (void)
 								((yy_buffer_stack),
 								num_to_alloc * sizeof(struct yy_buffer_state*)
 								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
 
 		/* zero only the new slots.*/
 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
@@ -3701,42 +3766,42 @@ YY_BUFFER_STATE yy_scan_buffer  (char *
 
 /** Setup the input buffer state to scan a string. The next call to yylex() will
  * scan from a @e copy of @a str.
- * @param str a NUL-terminated string to scan
+ * @param yystr a NUL-terminated string to scan
  * 
  * @return the newly allocated buffer state object.
  * @note If you want to scan bytes that may contain NUL values, then use
  *       yy_scan_bytes() instead.
  */
-YY_BUFFER_STATE yy_scan_string (yyconst char * str )
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
 {
     
-	return yy_scan_bytes(str,strlen(str) );
+	return yy_scan_bytes(yystr,strlen(yystr) );
 }
 
 /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
  * scan from a @e copy of @a bytes.
- * @param bytes the byte buffer to scan
- * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
  * 
  * @return the newly allocated buffer state object.
  */
-YY_BUFFER_STATE yy_scan_bytes  (yyconst char * bytes, int  len )
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
 {
 	YY_BUFFER_STATE b;
 	char *buf;
 	yy_size_t n;
-	int i;
+	yy_size_t i;
     
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
+	n = _yybytes_len + 2;
 	buf = (char *) yyalloc(n  );
 	if ( ! buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
 
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
 
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
 
 	b = yy_scan_buffer(buf,n );
 	if ( ! b )
@@ -3779,6 +3844,15 @@ static void yy_fatal_error (yyconst char
 
 /* Accessor  methods (get/set functions) to struct members. */
 
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
 /** Get the input stream.
  * 
  */
@@ -3798,7 +3872,7 @@ FILE *yyget_out  (void)
 /** Get the length of the current token.
  * 
  */
-int yyget_leng  (void)
+yy_size_t yyget_leng  (void)
 {
         return yyleng;
 }
@@ -3812,6 +3886,16 @@ char *yyget_text  (void)
         return yytext;
 }
 
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
 /** Set the input stream. This does not discard the current
  * input buffer.
  * @param in_str A readable stream.
@@ -3838,6 +3922,34 @@ void yyset_debug (int  bdebug )
         yy_flex_debug = bdebug ;
 }
 
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
 /* yylex_destroy is for both reentrant and non-reentrant scanners. */
 int yylex_destroy  (void)
 {
@@ -3853,6 +3965,10 @@ int yylex_destroy  (void)
 	yyfree((yy_buffer_stack) );
 	(yy_buffer_stack) = NULL;
 
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
     return 0;
 }
 
@@ -3864,7 +3980,7 @@ int yylex_destroy  (void)
 static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
 {
 	register int i;
-    	for ( i = 0; i < n; ++i )
+	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
 }
 #endif
@@ -3873,7 +3989,7 @@ static void yy_flex_strncpy (char* s1, y
 static int yy_flex_strlen (yyconst char * s )
 {
 	register int n;
-    	for ( n = 0; s[n]; ++n )
+	for ( n = 0; s[n]; ++n )
 		;
 
 	return n;
@@ -3904,7 +4020,7 @@ void yyfree (void * ptr )
 
 #define YYTABLES_NAME "yytables"
 
-#line 463 "ldlex.l"
+#line 462 "ldlex.l"
 
 
 
diff -rupN binutils-2.19.1-original/ld/Makefile.in binutils-2.19.1/ld/Makefile.in
--- binutils-2.19.1-original/ld/Makefile.in	2008-12-23 08:54:52.000000000 -0500
+++ binutils-2.19.1/ld/Makefile.in	2024-03-11 22:39:47.536424613 -0400
@@ -640,6 +640,7 @@ ALL_EMULATIONS = \
 	etic4xcoff.o \
 	etic54xcoff.o \
 	etic80coff.o \
+	etms9900.o \
 	evanilla.o \
 	evax.o \
 	evaxnbsd.o \
@@ -2520,6 +2521,9 @@ etic54xcoff.c: $(srcdir)/emulparams/tic5
 etic80coff.c: $(srcdir)/emulparams/tic80coff.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic80coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} tic80coff "$(tdir_tic80coff)"
+etms9900.c: $(srcdir)/emulparams/tms9900.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tms9900 "$(tdir_tms9900)"
 evanilla.c: $(srcdir)/emulparams/vanilla.sh \
   $(srcdir)/emultempl/vanilla.em $(srcdir)/scripttempl/vanilla.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} vanilla "$(tdir_vanilla)"
diff -rupN binutils-2.19.1-original/ld/scripttempl/tms9900.sc binutils-2.19.1/ld/scripttempl/tms9900.sc
--- binutils-2.19.1-original/ld/scripttempl/tms9900.sc	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.19.1/ld/scripttempl/tms9900.sc	2024-03-11 22:39:47.752421836 -0400
@@ -0,0 +1,35 @@
+if [ x${LD_FLAG} = x ]
+then
+cat << EOF
+/* Create a cp/m executable; load and execute at 0x100.  */
+OUTPUT_FORMAT("binary")
+. = 0x100;
+__Ltext = .;
+ENTRY (__Ltext)
+EOF
+else 
+    echo "OUTPUT_FORMAT(\"${OUTPUT_FORMAT}\")"
+fi
+cat <<EOF
+OUTPUT_ARCH("${OUTPUT_ARCH}")
+SECTIONS
+{
+.text :	{
+	*(.text)
+	*(text)
+	${RELOCATING+ __Htext = .;}
+	}
+.data :	{
+	${RELOCATING+ __Ldata = .;}
+	*(.data)
+	*(data)
+	${RELOCATING+ __Hdata = .;}
+	}
+.bss :	{
+	${RELOCATING+ __Lbss = .;}
+	*(.bss)
+	*(bss)
+	${RELOCATING+ __Hbss = .;}
+	}
+}
+EOF
diff -rupN binutils-2.19.1-original/md5.sum binutils-2.19.1/md5.sum
--- binutils-2.19.1-original/md5.sum	2011-08-24 05:50:03.000000000 -0400
+++ binutils-2.19.1/md5.sum	2024-03-11 22:39:46.868433232 -0400
@@ -9192,22 +9192,3 @@ f5856de6558c455ae6851b707531bc9f  src-re
 cf2baa0854f564a7785307e79f155efc  symlink-tree
 b97f1c282c19b00608b1680ad02ae227  texinfo/texinfo.tex
 e0a5f7e59d19edfd4b4d26479a141f02  ylwrap
-148fad0cc1f763de146e8b24585ecc7c  cgen/cpu/fr30.cpu
-9c5d5fa5b445b9355b85077bd49a5f97  cgen/cpu/fr30.opc
-75592d87915e75debae73108ddc302b2  cgen/cpu/ip2k.cpu
-8d5edda5f98445600dee230f555a2456  cgen/cpu/ip2k.opc
-78cbdc847b9f6c9e2c621e970e7c14f3  cgen/cpu/mep.cpu
-1b47be125fba9f799fffa8328508532d  cgen/cpu/mep-avc2.cpu
-be2133911e03d367684b1c8dcd6c4758  cgen/cpu/mep-avc.cpu
-f622a5215187ade7c348fe1374de4209  cgen/cpu/mep-core.cpu
-644c6915597b8cb2da2689e5740ee7d7  cgen/cpu/mep-default.cpu
-cd5f31291159e09506f8905f4655d0d1  cgen/cpu/mep-ext-cop.cpu
-688dc3b64342a492e1264b6708889cd3  cgen/cpu/mep-fmax.cpu
-ae3f5a95d6888eab3f31b94483e7bc9a  cgen/cpu/mep-h1.cpu
-08eff1d5157ccea7719aa0e35021472c  cgen/cpu/mep-rhcop.cpu
-284063bede32c6719663891fd89889d7  cgen/cpu/mep-sample-ucidsp.cpu
-072fc4afbdd9d0828d5b1122d203034e  cgen/cpu/mep.opc
-867a60d05d64405fdb1ef21000caeedc  cgen/cpu/openrisc.cpu
-945e53326e14b969cd64bb0cb5a37c30  cgen/cpu/openrisc.opc
-cc879f39f6d39e65f03f40957006d894  cgen/cpu/xstormy16.cpu
-ce470f63afdfaaaffd13956b0d3b51db  cgen/cpu/xstormy16.opc
diff -rupN binutils-2.19.1-original/opcodes/configure binutils-2.19.1/opcodes/configure
--- binutils-2.19.1-original/opcodes/configure	2008-08-15 04:31:51.000000000 -0400
+++ binutils-2.19.1/opcodes/configure	2024-03-11 22:39:46.972431870 -0400
@@ -11885,6 +11885,7 @@ if test x${all_targets} = xfalse ; then
         bfd_tic4x_arch)         ta="$ta tic4x-dis.lo" ;;
 	bfd_tic54x_arch)	ta="$ta tic54x-dis.lo tic54x-opc.lo" ;;
 	bfd_tic80_arch)		ta="$ta tic80-dis.lo tic80-opc.lo" ;;
+        bfd_tms9900_arch)	ta="$ta tms9900-dis.lo" ;;
 	bfd_v850_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850e_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850ea_arch)	ta="$ta v850-opc.lo v850-dis.lo" ;;
diff -rupN binutils-2.19.1-original/opcodes/disassemble.c binutils-2.19.1/opcodes/disassemble.c
--- binutils-2.19.1-original/opcodes/disassemble.c	2008-04-10 09:36:43.000000000 -0400
+++ binutils-2.19.1/opcodes/disassemble.c	2024-03-11 22:39:47.048430887 -0400
@@ -77,6 +77,7 @@
 #define ARCH_tic4x
 #define ARCH_tic54x
 #define ARCH_tic80
+#define ARCH_tms9900
 #define ARCH_v850
 #define ARCH_vax
 #define ARCH_w65
@@ -386,6 +387,11 @@ disassembler (abfd)
       disassemble = print_insn_tic80;
       break;
 #endif
+#ifdef ARCH_tms9900
+    case bfd_arch_tms9900:
+      disassemble = print_insn_tms9900;
+      break;
+#endif
 #ifdef ARCH_v850
     case bfd_arch_v850:
       disassemble = print_insn_v850;
diff -rupN binutils-2.19.1-original/opcodes/Makefile.in binutils-2.19.1/opcodes/Makefile.in
--- binutils-2.19.1-original/opcodes/Makefile.in	2008-09-09 04:02:19.000000000 -0400
+++ binutils-2.19.1/opcodes/Makefile.in	2024-03-11 22:39:47.028431144 -0400
@@ -420,7 +420,8 @@ CFILES = \
 	tic54x-opc.c \
 	tic80-dis.c \
 	tic80-opc.c \
-	v850-dis.c \
+	tms9900-dis.c \
+        v850-dis.c \
 	v850-opc.c \
 	vax-dis.c \
 	w65-dis.c \
@@ -1664,6 +1665,8 @@ tic80-dis.lo: tic80-dis.c sysdep.h confi
   $(INCDIR)/symcat.h
 tic80-opc.lo: tic80-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/opcode/tic80.h
+tms9900-dis.lo: tms9900-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(INCDIR)/dis-asm.h
 v850-dis.lo: v850-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/opcode/v850.h $(INCDIR)/dis-asm.h $(BFD_H) \
   $(INCDIR)/symcat.h opintl.h
diff -rupN binutils-2.19.1-original/opcodes/tms9900-dis.c binutils-2.19.1/opcodes/tms9900-dis.c
--- binutils-2.19.1-original/opcodes/tms9900-dis.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.19.1/opcodes/tms9900-dis.c	2024-03-11 22:39:47.064430681 -0400
@@ -0,0 +1,387 @@
+/* Print TMS9900 instructions
+   Copyright 2009 Eric Welser
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "dis-asm.h"
+#include <stdio.h>
+
+struct buffer
+{
+  bfd_vma base;
+  unsigned short opcode;
+  int n_fetch;
+  unsigned char data[6];
+} ;
+
+typedef void (*parse_func)(struct buffer *, disassemble_info *, char *);
+
+struct parse_table
+{
+  parse_func func;
+  char* text;
+};
+
+static int
+fetch_data (struct buffer *buf, disassemble_info * info, int n)
+{
+  int r;
+
+  if (buf->n_fetch + n > 6)
+    abort ();
+
+  r = info->read_memory_func (buf->base + buf->n_fetch,
+			      (unsigned char*) buf->data + buf->n_fetch,
+			      n, info);
+  if (r == 0)
+    buf->n_fetch += n;
+  return !r;
+}
+
+static void parse_error(struct buffer *buffer, disassemble_info *info, char *text ATTRIBUTE_UNUSED)
+{
+  info->fprintf_func (info->stream, "data %02X%02X", 
+                      buffer->data[0],  buffer->data[1]);  
+}
+
+static void parse_mode(struct buffer *buffer, disassemble_info *info, char *arg, int code)
+{
+  int mode = (code >> 4) & 0x3;
+  int reg = code & 0xF;
+  if(mode == 2)
+    {
+      unsigned char *data = &buffer->data[buffer->n_fetch];
+      unsigned short value;
+      if (! fetch_data (buffer, info, 2))
+        return;
+      value = ((unsigned short)data[0] << 8) | data[1];
+      if(reg == 0)
+        sprintf(arg, "@>%04X",value);
+      else
+        sprintf(arg, "@>%04X(r%d)", value, reg);
+    }
+  else
+    {
+      char *format[] = { "r%d", "*r%d", "", "*r%d+" };
+      sprintf(arg, format[mode], reg);
+    }
+}
+
+static void parse_type_1(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // source, dest     |Opcode  |B |Td   |Dest. Reg. |Ts   |Source Reg.|
+
+  char source[16];
+  char dest[16];
+
+  parse_mode(buffer, info, source, (buffer->opcode & 0x3F));
+  parse_mode(buffer, info, dest, ((buffer->opcode >> 6) & 0x3F));
+
+  info->fprintf_func (info->stream, "%s %s, %s", text, source, dest);
+}
+
+static void parse_type_2(struct buffer *buffer ATTRIBUTE_UNUSED, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // PC-rel           |Opcode                 |Offset                 |
+
+  char disp = buffer->opcode & 0xFF;
+  info->fprintf_func (info->stream, "%s %d", text, (int)(disp) * 2);
+}
+
+static void parse_type_2a(struct buffer *buffer ATTRIBUTE_UNUSED, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // CRU disp         |Opcode                 |Offset                 |
+
+  char disp = buffer->opcode & 0xFF;
+  info->fprintf_func (info->stream, "%s %d", text, (int)(disp));
+}
+
+static void parse_type_3(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // source, reg      |Opcode           |Register   |Ts   |Source Reg.|
+
+  char source[16];
+  parse_mode(buffer, info, source, (buffer->opcode & 0x3F));
+  info->fprintf_func (info->stream, "%s %s, r%d", 
+                      text, source, (buffer->opcode >> 6) & 0xF);
+}
+
+static void parse_type_4(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // source, nbits    |Opcode           |NBits      |Ts   |Source Reg.|
+
+  char source[16];
+  parse_mode(buffer, info, source, (buffer->opcode & 0x3F));
+  info->fprintf_func (info->stream, "%s %s, %d", 
+                      text, source, (buffer->opcode >> 6) & 0xF);
+}
+
+static void parse_type_5(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // register, count  |Opcode                 |Count      |Register   |
+
+  info->fprintf_func (info->stream, "%s r%d, %d", 
+                      text, buffer->opcode & 0xF, (buffer->opcode >> 4) & 0xF);
+}
+
+static void parse_type_6(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // dest             |Opcode                       |Ts   |Source Reg.|
+
+  char source[16];
+  parse_mode(buffer, info, source, (buffer->opcode & 0x3F));
+  info->fprintf_func (info->stream, "%s %s", text, source);
+}
+
+static void parse_type_7(struct buffer *buffer ATTRIBUTE_UNUSED, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // dest             |Opcode                             | 0  0  0  0|
+
+  info->fprintf_func (info->stream, "%s", text);
+}
+
+static void parse_type_8(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // register, count  |Opcode                          | 0|Register   |
+  // immediate        |Data                                           |
+
+  unsigned char *data = &buffer->data[buffer->n_fetch];
+  unsigned short value;
+  if (! fetch_data (buffer, info, 2))
+    return;
+  value = ((unsigned short)data[0] << 8) | data[1];
+
+  info->fprintf_func (info->stream, "%s r%d, >%04X", 
+                      text, buffer->opcode & 0xF, value);
+}
+
+static void parse_type_8a(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // register, count  |Opcode                          | 0|Register   |
+
+  info->fprintf_func (info->stream, "%s r%d", 
+                      text, buffer->opcode & 0xF);
+}
+
+static void parse_type_8b(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // opcode           |Opcode                          | 0            |
+  // immediate        |Data                                           |
+
+  unsigned char *data = &buffer->data[buffer->n_fetch];
+  unsigned short value;
+  if (! fetch_data (buffer, info, 2))
+    return;
+  value = ((unsigned short)data[0] << 8) | data[1];
+
+  info->fprintf_func (info->stream, "%s >%04X", 
+                      text, value);
+}
+
+static struct parse_table level_5[] =
+{
+  {parse_type_6, "blwp"},
+  {parse_type_6, "b"},
+  {parse_type_6, "x"},
+  {parse_type_6, "clr"},
+  {parse_type_6, "neg"},
+  {parse_type_6, "inv"},
+  {parse_type_6, "inc"},
+  {parse_type_6, "inct"},
+  {parse_type_6, "dec"},
+  {parse_type_6, "dect"},
+  {parse_type_6, "bl"},
+  {parse_type_6, "swpb"},
+  {parse_type_6, "seto"},
+  {parse_type_6, "abs"},
+  {parse_error,  ""},
+  {parse_error,  ""}
+};
+
+static void parse_level_5(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  unsigned int code = (buffer->opcode >> 6) & 0xF;
+  text = level_5[code].text;
+  level_5[code].func(buffer, info, text);
+}
+
+static struct parse_table level_4[] =
+{
+  {parse_type_8,  "li"},
+  {parse_error,   ""},
+  {parse_type_8,  "ai"},
+  {parse_error,   ""},
+  {parse_type_8,  "andi"},
+  {parse_error,   ""},
+  {parse_type_8,  "ori"},
+  {parse_error,   ""},
+  {parse_type_8,  "ci"},
+  {parse_error,   ""},
+  {parse_type_8a, "stwp"},
+  {parse_error,   ""},
+  {parse_type_8a, "stst"},
+  {parse_error,   ""},
+  {parse_type_8b, "lwpi"},
+  {parse_error,   ""},
+  {parse_type_8b, "limi"},
+  {parse_error,   ""},
+  {parse_type_7,  "idle"},
+  {parse_error,   ""},
+  {parse_type_7,  "rset"},
+  {parse_error,   ""},
+  {parse_type_7,  "rtwp"},
+  {parse_error,   ""},
+  {parse_type_7,  "ckon"},
+  {parse_error,   ""},
+  {parse_type_7,  "ckof"},
+  {parse_error,   ""},
+  {parse_type_7,  "lrex"},
+  {parse_error,   ""},
+  {parse_error,   ""},
+  {parse_error,   ""}
+};
+
+static void parse_level_4(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  unsigned int code = (buffer->opcode >> 4) & 0x1F;
+  text = level_4[code].text;
+  level_4[code].func(buffer, info, text);
+}
+
+static struct parse_table level_3[] =
+{
+  {parse_error,   ""},
+  {parse_error,   ""},
+  {parse_level_4, ""},
+  {parse_level_4, ""},
+  {parse_level_5, ""},
+  {parse_level_5, ""},
+  {parse_level_5, ""},
+  {parse_level_5, ""},
+  {parse_type_5,  "sra"},
+  {parse_type_5,  "srl"},
+  {parse_type_5,  "sla"},
+  {parse_type_5,  "src"},
+  {parse_error,   ""},
+  {parse_error,   ""},
+  {parse_error,   ""},
+  {parse_error,   ""}
+};
+
+static void parse_level_3(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  unsigned int code = (buffer->opcode >> 8) & 0xF;
+  text = level_3[code].text;
+  level_3[code].func(buffer, info, text);
+}
+
+static struct parse_table level_2[] =
+{
+  {parse_type_2,  "jmp"},
+  {parse_type_2,  "jlt"},
+  {parse_type_2,  "jle"},
+  {parse_type_2,  "jeq"},
+  {parse_type_2,  "jhe"},
+  {parse_type_2,  "jgt"},
+  {parse_type_2,  "jne"},
+  {parse_type_2,  "jnc"},
+  {parse_type_2,  "joc"},
+  {parse_type_2,  "jno"},
+  {parse_type_2,  "jl"},
+  {parse_type_2,  "jh"},
+  {parse_type_2,  "jop"},
+  {parse_type_2a, "sbo"},
+  {parse_type_2a, "sbz"},
+  {parse_type_2a, "tb"}
+};
+
+static void parse_level_2(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  unsigned int code = (buffer->opcode >> 8) & 0xF;
+  text = level_2[code].text;
+  level_2[code].func(buffer, info, text);
+}
+
+static struct parse_table level_1[] =
+{
+  {parse_type_3, "coc"},
+  {parse_type_3, "czc"},
+  {parse_type_3, "xor"},
+  {parse_type_4, "xop"},
+  {parse_type_4, "ldcr"},
+  {parse_type_4, "stcr"},
+  {parse_type_3, "mpy"},
+  {parse_type_3, "div"}
+};
+
+static void parse_level_1(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  unsigned int code = (buffer->opcode >> 10) & 0x7;
+  text = level_1[code].text;
+  level_1[code].func(buffer, info, text);
+}
+
+static struct parse_table level_0[] =
+{
+  {parse_level_3, ""},
+  {parse_level_2, ""},
+  {parse_level_1, ""},
+  {parse_level_1, ""},
+  {parse_type_1,  "szc"},
+  {parse_type_1,  "szcb"},
+  {parse_type_1,  "s"},
+  {parse_type_1,  "sb"},
+  {parse_type_1,  "c"},
+  {parse_type_1,  "cb"},
+  {parse_type_1,  "a"},
+  {parse_type_1,  "ab"},
+  {parse_type_1,  "mov"},
+  {parse_type_1,  "movb"},
+  {parse_type_1,  "soc"},
+  {parse_type_1,  "socb"}
+};
+
+int
+print_insn_tms9900 (bfd_vma addr, disassemble_info * info)
+{
+  struct buffer buf;
+  unsigned int code;
+  
+  buf.base = addr;
+  buf.n_fetch = 0;
+
+  if (! fetch_data (& buf, info, 2))
+    return -1;
+  buf.opcode = (((unsigned int)buf.data[0]) << 8) | buf.data[1];
+  code = (buf.opcode >> 12) & 0xF;
+  level_0[code].func(&buf, info, level_0[code].text);
+  return(buf.n_fetch);
+}
+
