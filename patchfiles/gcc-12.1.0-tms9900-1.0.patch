diff -rupN gcc-12.1.0-original/config.sub gcc-12.1.0/config.sub
--- gcc-12.1.0-original/config.sub	2022-05-06 03:30:56.000000000 -0400
+++ gcc-12.1.0/config.sub	2024-03-13 00:00:04.594223922 -0400
@@ -1265,6 +1265,7 @@ case $cpu-$vendor in
 			| tahoe \
 			| thumbv7* \
 			| tic30 | tic4x | tic54x | tic55x | tic6x | tic80 \
+			| tms9900 \
 			| tron \
 			| ubicom32 \
 			| v70 | v850 | v850e | v850e1 | v850es | v850e2 | v850e2v3 \
diff -rupN gcc-12.1.0-original/gcc/config/tms9900/constraints.md gcc-12.1.0/gcc/config/tms9900/constraints.md
--- gcc-12.1.0-original/gcc/config/tms9900/constraints.md	1969-12-31 19:00:00.000000000 -0500
+++ gcc-12.1.0/gcc/config/tms9900/constraints.md	2024-03-13 00:00:04.698224896 -0400
@@ -0,0 +1,46 @@
+;; Constraints for TMS9900.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful, but
+;; WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;; General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.  */
+
+
+;;=============================================================================
+;; Memory addressing constraints.
+;;   'Q' is for memory references that require an extra word after the opcode.
+;;   'R' is for memory references which are encoded within the opcode.
+;;=============================================================================
+
+
+(define_memory_constraint "Q"
+  "Memory operands with base register and displacement"
+  (and (match_code "mem")
+       (match_test "tms9900_address_ok_for_letter(op, 'Q')")))
+
+
+(define_memory_constraint "R"
+  "Memory operands with base register only"
+  (and (match_code "mem")
+       (match_test "tms9900_address_ok_for_letter(op, 'R')")))
+
+
+;;=============================================================================
+;; Register constraints.
+;;   'S' is for R0, the shift count register
+;;=============================================================================
+
+
+(define_register_constraint "S" "SHIFT_REGS" "Shift count register")
+
diff -rupN gcc-12.1.0-original/gcc/config/tms9900/lib1funcs.asm gcc-12.1.0/gcc/config/tms9900/lib1funcs.asm
--- gcc-12.1.0-original/gcc/config/tms9900/lib1funcs.asm	1969-12-31 19:00:00.000000000 -0500
+++ gcc-12.1.0/gcc/config/tms9900/lib1funcs.asm	2024-03-13 00:00:04.698224896 -0400
@@ -0,0 +1,820 @@
+/******************************************************************************
+*                               __clzM2
+*******************************************************************************
+* Return the number of leading 0-bits in a value, starting at the most
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : r1 - Value to test
+*
+* Returns: r1 - Number of zero bits
+******************************************************************************/
+
+#ifdef L_clzqi2
+/*********************************************************/
+/*                     __clzqi2                          */
+/*********************************************************/
+  def __clzqi2
+__clzqi2:
+  movb r1, r2  /* Move value into position, set condition flags */
+  clr  r1      /* Set minimum bit count, flags unchanged */
+  jgt  do_clz  /* If val==0, return undefined, if val<0, MSB set, return 0*/
+  b    *r11
+do_clz:
+  b    @__clz
+#endif
+
+
+#ifdef L_clzhi2
+/*********************************************************/
+/*                     __clzhi2                          */
+/*********************************************************/
+  def __clzhi2
+__clzhi2:
+  mov  r1, r2  /* Move value into position, set condition flags */
+  clr  r1      /* Set minimum bit count, flags unchanged */
+  jgt  do_clz  /* If val==0, return undefined, if val<0, MSB set, return 0*/
+  b *r11
+do_clz:
+  b    @__clz
+#endif
+
+
+#ifdef L_clzsi2
+/*********************************************************/
+/*                     __clzsi2                          */
+/*********************************************************/
+  def __clzsi2
+__clzsi2:
+  mov  r1, r1   /* Test MSW for set bits */
+  jlt  ret_0    /* Upper bit of MSW set, return zero */
+  jgt  clz_msw  /* Count leading zeroes in MSW */
+
+clz_lsw:
+  li   r1, 16   /* MSW was zero, initialize count to 16 */
+  mov  r2, r2   /* Test bits in LSW */
+  jlt  ret_16   /* Upper bit of LSW set, return sisxteen */
+  jgt  do_clz   /* Count leading zeroes of LSW */
+
+ret_0:
+  clr  r1
+ret_16:
+  b    *r11
+
+clz_msw:
+  mov  r1, r2  /* Move MSW into test position */
+  clr  r1      /* Initialize count to zero */
+do_clz:
+  b    @__clz
+#endif
+
+
+#ifdef L_clz
+/******************************************************************************
+*                               __clz
+*******************************************************************************
+* Return the number of leading 0-bits in a 16-bit value, starting at the most 
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : R1 - Minimum posible bit count
+*          R2 - Value to test
+*
+* Returns: R1 - Number of zero bits
+*******************************************************************************/
+  def __clz
+/*
+* We will shift left until we find a set bit
+*
+* Example 1, zero leading bits:
+*   C Val   N
+*   - ----  -
+*   . 1000  0
+*
+* Example 2, one leading bit:
+*   C Val   N
+*   - ----  -
+*   . 0100  4
+*   1 00..  2->1
+*
+* Example 3, two leading bits:
+*   C Val   N
+*   - ----  -
+*   0 0010  4
+*   0 10..  2
+*
+* If we got here, there is at least one bit set in supplied value
+*/
+__clz:
+  inct r1      /* Assume two zero bits, double count implied bit */
+  sla  r2, 2   /* Move next two bits into test position, set flags */
+  joc  bottom  /* Upper test bit set, exit */
+  jgt  __clz   /* Upper and lower test bits clear, loop */
+  
+  /* Clean up after loop */
+  inc r1       /* If we got here, negate next instruction */
+bottom:
+  dec r1       /* No cleared bits in last test set, decrement count */
+
+  /* Bit count is in R1, exit */
+  b *r11
+#endif
+
+  
+/******************************************************************************
+*                               __ctzM2
+*******************************************************************************
+* Return the number of trailing 0-bits in a 16-bit value, starting at the least
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Number of zero bits
+******************************************************************************/
+
+#ifdef L_ctzqi2
+/*********************************************************/
+/*                     __ctzqi2                          */
+/*********************************************************/
+  def __ctzqi2
+__ctzqi2:
+  clr  r2
+  movb r1, r2  /* Move value to R2, clearing low bits */
+  jeq  bottom  /* If all bits clear, stop now, return zero */
+  li   r1, 8   /* Max possible zero bits */
+  b    @__ctz  /* Examine provided value */
+bottom:
+  b *r11
+#endif
+
+
+#ifdef L_ctzhi2
+/*********************************************************/
+/*                     __ctzhi2                          */
+/*********************************************************/
+  def __ctzhi2
+__ctzhi2:
+  mov r1, r2  /* Move value to R2, set condition flags */
+  jeq bottom  /* If all bits clear, stop now, return zero */
+  li  r1, 16  /* Max possible zero bits */
+  b   @__ctz  /* Examine provided value */
+bottom:
+  b *r11
+#endif
+
+
+#ifdef L_ctzsi2
+/*********************************************************/
+/*                     __ctzsi2                          */
+/*********************************************************/
+  def __ctzsi2
+__ctzsi2:
+  mov  r2, r2     /* Check low word for set bits */
+  jeq  lsw_clear 
+
+  /* There are set bits in the low word */
+  li   r1, 16     /* Maximum number of possible zero bits */
+  b    @__ctz     /* Examine provided value */
+
+  /* All bits clear in the low word, no need to test them */
+lsw_clear:
+  mov  r1, r2     /* Move high word into test position */
+  jeq  bottom     /* If all bits clear, stop now, return zero */
+  li   r1, 32     /* Maximum number of possible zero bits */
+  b    @__ctz     /* Examine provided value */
+
+bottom:
+  b *r11
+#endif
+
+
+#if L_ctz
+/******************************************************************************
+*                               __ctz
+*******************************************************************************
+* Return the number of trailing 0-bits in a 16-bit value, starting at the least 
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : R1 - Maximum posible bit count
+*          R2 - Value to test
+*
+* Returns: R1 - Number of zero bits
+******************************************************************************/
+  def __ctz
+
+/*
+* We will shift left until all leading set bits are shifted out of the value
+*
+* Exmaple 1, zero trailing bits:
+*   C Val   N
+*   - ----  -
+*   . 0001  4
+*   0 01..  2
+*   1 ....  0
+*
+* Exmaple 2, one trailing bit:
+*   C Val   N
+*   - ----  -
+*   . 0010  4
+*   0 10..  2
+*   0 ....  1
+*
+* Exmaple 3, two trailing bits:
+*   C Val   N
+*   - ----  -
+*   0 0100  4
+*   1 00..  2
+*/
+
+  /* Test loop, check two uppermost bits at a time */
+__ctz:
+  dect r1      /* Assume both bits are set */
+  sla  r2, 2   /* Shift two bits into test position */
+  jne  __ctz   /* Still have set bits, keep looping */
+
+  /* Correct for last two test bits */
+  joc  bottom  /* If carry bit set, lower test bit was set */
+  inc  r1      /* lower test bit was clear, increment bit count */
+bottom:
+  b *r11
+#endif
+
+
+/******************************************************************************
+*                               __ffsM2
+*******************************************************************************
+* Return the index of the least significant set bit in a value, or zero 
+* if the value is zero.  The least significant bit is index one.
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Index to lowest set bit
+******************************************************************************/
+
+
+#ifdef L_ffsqi2
+/*********************************************************/
+/*                     __ffsqi2                          */
+/*********************************************************/
+  def __ffsqi2
+__ffsqi2:
+  movb r1, r1     /* Check for zero value */
+  jeq  done       /* If so, exit now */
+  mov  r11, r3    /* Move return pointer, it won't be affected by next call */
+  bl   @__ctzqi2  /* Count trailing zero bits */
+  inc  r1         /* Least sig. bit is in position trailing_count +1 */
+  b    *r3        /* Return to caller */
+done:
+  clr  r1         /* Return zero value */
+  b    *r11
+#endif
+
+
+#ifdef L_ffshi2
+/*********************************************************/
+/*                     __ffshi2                          */
+/*********************************************************/
+  def __ffshi2
+__ffshi2:
+  mov r11, r3     /* Move return pointer, it won't be affected by next call */
+  mov r1, r1      /* Check for zero value */
+  jeq done        /* If so, exit now */
+  bl  @__ctzhi2   /* Count trailing zero bits */
+  inc r1          /* Least sig. bit is in position trailing_count +1 */
+done:
+  b   *r3         /* Return to caller */
+#endif
+
+
+#ifdef L_ffssi2
+/*********************************************************/
+/*                     __ffssi2                          */
+/*********************************************************/
+  def __ffssi2
+__ffssi2:
+  mov r11, r3     /* Move return pointer, it won't be affected by next call */
+  mov r1, r4
+  soc r2, r4      /* Check for zero value */
+  jeq done        /* If so, exit now */
+  bl  @__ctzsi2   /* Count trailing zero bits */
+  inc r1          /* Least sig. bit is in position trailing_count +1 */
+done:
+  b   *r3         /* Return to caller */
+  def __modsi3
+#endif
+
+
+#ifdef L_parity
+/******************************************************************************
+*                               __parityM2
+*******************************************************************************
+* Return the value zero if the number of bits set in the given value is even,
+* and the value one otherwise.
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Number of zero bits
+******************************************************************************/
+
+/* Test an 8-bit value */
+  def __parityqi2
+__parityqi2:
+  seto r3
+  jmp byte1
+
+/* Test a 16-bit value */
+  def __parityhi2
+__parityhi2:
+  clr r3
+  jmp byte2
+
+/* Test a 32-bit value */
+  def __paritysi2
+__paritysi2:
+  clr  r3
+  movb r2, r2
+  jop pre_byte3
+  inv r3
+pre_byte3:
+  swpb r2
+byte3:
+  movb r2, r2
+  jop byte2
+  inv r3
+byte2:
+  movb r1, r1
+  jop pre_byte1
+  inv r3
+pre_byte1:
+  swpb r1
+byte1:
+  movb r1, r1
+  jop done
+  inv r3
+done:
+  neg r3
+  mov r3, r1
+  bl *r11
+#endif
+
+
+/******************************************************************************
+*                               __popcountM2
+*******************************************************************************
+* Return the number of set bits in a value
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Number of set bits
+******************************************************************************/
+
+
+#ifdef L_popcountqi2
+/*********************************************************/
+/*                   __popcountqi2                       */
+/*********************************************************/
+  def __popcountqi2
+__popcountqi2:
+  clr  r2           /* Clear lower unused bits */
+  movb r1, r2       /* Move value into test position */
+  clr  r1           /* Clear bit count */
+  b    @__popcount  /* Find set bit count */
+#endif
+
+
+#ifdef L_popcounthi2
+/*********************************************************/
+/*                   __popcounthi2                       */
+/*********************************************************/
+  def __popcounthi2
+__popcounthi2:
+  mov  r1, r2       /* Move value into test position */
+  clr  r1           /* Clear bit count */
+  b    @__popcount  /* Find set bit count */
+#endif
+
+
+#ifdef L_popcountsi2
+/*********************************************************/
+/*                   __popcountsi2                       */
+/*********************************************************/
+  def __popcountsi2
+__popcountsi2:
+  mov  r11, r4      /* Move Return value where it will be safe */
+  mov  r1, r3       /* Move MSW to safe position */
+  clr  r1           /* Clear bit count */
+  bl   @__popcount  /* Find LSW set bit count */
+  mov  r3, r2       /* Move MSW into test position */
+  bl   @__popcount  /* Find MSW set bit count */
+  b    *r4          /* Return to caller */
+#endif
+
+
+#ifdef L_popcount
+/******************************************************************************
+*                               __popcount
+*******************************************************************************
+* Return the number of set bits in a 16-bit value
+*
+* Inputs : R1 - Current bit count
+*          R2 - Value to test
+*
+* Returns: R1 - Number of set bits
+******************************************************************************/
+  def __popcount
+__popcount:
+  mov  r2,r2   /* Check for zero value */  
+  jeq  done    /* If zero, exit now */
+top:
+  inc  r1      /* Increment bit count */
+  mov  r2, r0  /* \                           */
+  neg  r0      /* | Equvilent to r2 &= (r2-1) */
+  szc  r0, r2  /* /                           */
+  jne  top     /* Keep looping until all bits counted */
+done:
+  b    *r11    /* Return to caller */
+#endif
+
+
+#ifdef L_divmodsi3
+/******************************************************************************
+*                               __divmodsi3
+*******************************************************************************
+* Calculate the signed quotient and modulus of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*           R5     - Address for modulus
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __divmodsi3
+__divmodsi3:
+  /* Save modulo addess */
+  mov  r5, @-6(r10)
+
+  /* Save return register */
+  mov  r11, @-2(r10)
+  bl   @__divmodstart
+
+  /* Caclulate result */
+calc:
+  bl   @__udivmod32
+
+  /* Negate modulus if needed */
+  mov  @-4(r10), r0
+  jlt  savemod
+  inv  r3
+  neg  r4
+  jnc  savemod
+  inc  r3
+  
+  /* Save modulus */
+savemod:
+  mov  @-6(r10), r0
+  mov  r3, *r0
+  mov  r4, *r0+
+
+  /* Complete operatons */
+  b    @__divmodend
+#endif
+
+
+#ifdef L_divsi3
+/******************************************************************************
+*                               __divsi3
+*******************************************************************************
+* Calculate the signed quotient of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __divsi3
+__divsi3:
+  /* Save return register */
+  mov  r11, @-2(r10)
+  bl   @__divmodstart
+
+  /* Caclulate result */
+calc:
+  bl   @__udivmod32
+  b    @__divmodend
+#endif
+
+
+#ifdef L_modsi3
+/******************************************************************************
+*                               __modsi3
+*******************************************************************************
+* Calculate the signed modulus of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit modulus
+******************************************************************************/
+  def __modsi3
+__modsi3:
+  /* Save return register */
+  mov  r11, @-2(r10)
+  bl   @__divmodstart
+
+  /* Caclulate result */
+calc:
+  bl   @__udivmod32
+  mov  r3, r1
+  mov  r4, r2
+  b    @__divmodend
+#endif
+
+
+#ifdef L_divmod_common
+/******************************************************************************
+*                               __divmodstart
+*******************************************************************************
+* Common code for the start of all signed division and modulo calculations
+*
+* Inputs:  [R1,R2] - Signed 32-bit numerator
+*          [R3,R4] - Signed 32-bit denominator
+*
+* Returns: [R1,R2] - Positive 32-bit quotient
+*          [R3,R4] - Positive 32-bit denominator
+*          sp-4    - Sign of result
+******************************************************************************/
+  def __divmodstart
+__divmodstart:
+  /* Make numerator positive */
+  mov  r1, r5
+  jlt  negnum
+  jmp  testden
+negnum:
+  inv  r1
+  neg  r2
+  jnc  testden
+  inc  r1
+
+  /* Make denominator positive */
+testden:
+  xor  r3, r5
+  mov  r5, @-4(r10)
+  mov  r3, r3
+  jlt  negden
+  jmp  done
+negden:
+  inv  r3
+  neg  r4
+  jnc  done
+  inc  r3
+done:
+  b    *r11
+
+
+/******************************************************************************
+*                               __divmodend
+*******************************************************************************
+* Common code for the end of all signed division and modulo calculations
+*
+* Inputs:  [R1,R2] - Positive 32-bit quotient
+*          [R3,R4] - Positive 32-bit denominator
+*          sp-2    - Return pointer
+*          sp-4    - Sign of result
+*          
+* Returns: [R1,R2] - Signed 32-bit result
+******************************************************************************/
+  def __divmodend
+__divmodend:
+  /* Restore return register */
+  mov  @-2(r10), r11
+
+  /* Do we need to negate the result? */
+  mov  @-4(r10), r0
+  jlt  makeneg  
+  b    *r11        # Nope, exit now
+
+  /* Negate result and return */
+makeneg:  
+  inv  r1
+  neg  r2
+  jnc  jmp1
+  inc  r1
+jmp1:
+  b    *r11
+#endif
+
+
+#ifdef L_udivmodsi3
+/******************************************************************************
+*                             __udivmodsi3
+*******************************************************************************
+* Calculate the unsigned quotient and remainder of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*           R5     - Address to place 32-bit remainder
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __udivmodsi3
+__udivmodsi3:
+  /* Save pointer and return address */
+  mov  r5,  @-2(r10)
+  mov  r11, @-4(r10)
+
+  /* Do some math */
+  bl   @__udivmodsi
+  
+  /* Save remainder */
+  mov  @-2(r10), r0
+  mov  r3, *r0+
+  mov  r4, *r0
+  mov  @-4(r10), r11
+  b    *r11
+#endif
+
+
+#ifdef L_udivsi3
+/******************************************************************************
+*                               __udivsi3
+*******************************************************************************
+* Calculate the unsigned quotient of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __udivsi3
+__udivsi3:
+  /* Fall through to next routine */
+
+
+/******************************************************************************
+*                               __udivmod32
+*******************************************************************************
+* Calculate the unsigned quotient and remainder of the two values provided.
+* This is used by all the 32-bit division and modulus functions.
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit quotient
+*          [R3,R4] - 32-bit remainder
+******************************************************************************/
+  def __udivmod32
+__udivmod32:
+  /* Check size of denominator */
+  mov  r3, r3      /* Is the upper word of denominator used? */
+  jne  den32       /* If so, jump to 32-bit code */
+
+  /* Handle 16-bit denominator */
+  /* Zero extend numerator */
+  clr  r0
+  mov  r1, r1
+  jeq  num16       /* If numerator is only 16 bits, skip the first DIV */
+
+  /* Perform calculation */
+  div  r4, r0
+num16:
+  div  r4, r1
+
+  /* Move results into return position */
+  mov  r2, r4      /* LSW of remainder */
+                   /* MSW of remainder still zero */
+  mov  r1, r2      /* LSW of result */
+  mov  r0, r1      /* MSW of result */
+  b    *r11
+
+den32:
+  /*
+  * Handle 32-bit denominator
+  *
+  *      A1*N + A1
+  * Q = ---------
+  *      B1*N + B2
+  *
+  * N = 0x10000
+  *
+  * Divide top and bottom by 2*B1 to make the denominator a 16-bit quantity
+  *
+  *        A1*N + A2
+  *       ---------
+  *          2*B1
+  * Q = ---------------
+  *        N     B2
+  *       --- + ---
+  *        2    2*B1
+  *
+  * This will result in some rounding error which must be corrected for.
+  * We will call the approximate value P, and the rounding error E. 
+  *
+  * Q - P = E
+  *
+  * Analysis of the error shows that E must be either 0 or -1. We will calculate
+  * the remainder to determine E and so correct P.
+  *
+  * R = (A1*N + A2) - P*(B1*N + B2)
+  *
+  * If R is negative, P is too large by one and we will apply the correction.
+  * Otherwise, P is correct and we can use the value directly.
+  */
+
+  /* Move arguments into test position */
+  mov  r1, r0      /* [r0,r12] <- [A1,A2] = numerator */
+  mov  r2, r12
+
+  mov  r3, r7      /* [r7,r8] <- [B1,B2] = deominator */
+  mov  r4, r8
+
+  /* Calculate V = (N/2 + B2/(2*B1)) */
+  clr  r1          /* [r1,r2] <- [C1,C2] = B2/2 */
+  mov  r8, r2
+  srl  r2, 1
+
+  div  r7, r1      /* r1 <- v = [C1,C2]/B1 */
+  ai   r1, 0x8000  /* v += 0x8000 */
+
+  /* Calculate U = (A1*N + A2)/(2*B1) */
+  mov  r0, r2      /* [r2,r3] <- [U1,U2] = [A1,A2] */
+  mov  r12, r3
+
+  srl  r2, 1       /* [U1,U2] = [A1,A2]/2 */
+  srl  r3, 1
+  jnc  jmp1
+  ori  r3, 0x8000
+jmp1:
+
+  clr  r4          /* [U1,U2] = [U1,U2]/B1 */
+  mov  r2, r5
+  div  r7, r4
+  mov  r3, r6
+  div  r7, r5
+  mov  r4, r2
+  mov  r5, r3
+
+  div  r1, r2      /* r2 <- P = [U1,U2]/V */
+
+  /* Calculate remainder  [m1,m2]=[a1,a2]-[b1,b2]*p */
+  mov  r7, r3      /* [r3,r4] <- [U1,U2] = B1*p */
+  mpy  r2, r3
+
+  mov  r8, r5      /* [r5,r6] <- [D1,D2] = B2*P */
+  mpy  r2, r5
+
+  a    r4, r5      /* [D1,D2] += [U2,0] */
+
+  mov  r0, r3      /* [M1,M2] = [A1,A2] */
+  mov  r12, r4
+
+  s    r5, r3      /* [M1,M2] -= [D1,D2] */
+  s    r6, r4
+  joc  jmp2
+  dec  r3
+jmp2:
+
+  /*
+  * Results now in return position, prepare for exit
+  *   [r1,r2] <- quotient
+  *   [r3,r4] <- remainder
+  */
+  clr  r1          /* Set upper word of quotient, we know it will be zero */
+  mov  r3, r3      /* if(remainder >= 0) P is correct */
+  jlt  jmp3
+  b    *r11
+jmp3:
+
+  /* Correct result for rounding error */
+  dec  r2          /* P -= 1 */
+
+  /* Correct remainder for rounding error */
+  a    r7, r3      /* [M1,M2] += [B1,B2] */
+  a    r8, r4
+  jnc  jmp4
+  inc  r3
+jmp4:
+
+  /* Return value */
+  b    *r11
+#endif
+
+
+#ifdef L_umodsi3
+/******************************************************************************
+*                               __umodsi3
+*******************************************************************************
+* Calculate the unsigned modulus of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit modulus
+******************************************************************************/
+  def __umodsi3
+__umodsi3:
+  mov  r11, @-2(r10)
+  bl   @__udivmod32
+  mov  r3, r1
+  mov  r4, r2
+  mov  @-2(r10), r11
+  b    *r11
+#endif
+
diff -rupN gcc-12.1.0-original/gcc/config/tms9900/predicates.md gcc-12.1.0/gcc/config/tms9900/predicates.md
--- gcc-12.1.0-original/gcc/config/tms9900/predicates.md	1969-12-31 19:00:00.000000000 -0500
+++ gcc-12.1.0/gcc/config/tms9900/predicates.md	2024-03-13 00:00:04.698224896 -0400
@@ -0,0 +1,43 @@
+;; Predicates for TMS9900.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful, but
+;; WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;; General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>
+
+
+;;=============================================================================
+;; Predicate for bit shift count
+;;=============================================================================
+(define_predicate "shift_count_operand"
+  (ior (match_code "const_int")
+       (match_code "reg")))
+
+;;=============================================================================
+;; Predicate for right operand of subtraction expression
+;;=============================================================================
+(define_predicate "subtrahend_operand"
+  (not (ior (match_code "symbol_ref")
+            (match_code "label_ref"))))
+
+
+;;=============================================================================
+;; Predicate for operands of a MOV expression
+;;=============================================================================
+(define_predicate "move_operand"
+  (ior (and (not (match_code "mem, code_label, label_ref, symbol_ref"))
+            (match_test "general_operand (op, GET_MODE (op))"))
+       (and (match_code "mem, code_label, label_ref, symbol_ref")
+            (match_test "tms9900_legitimate_address_p (GET_MODE (op), op, false)"))))
+
diff -rupN gcc-12.1.0-original/gcc/config/tms9900/tms9900.cc gcc-12.1.0/gcc/config/tms9900/tms9900.cc
--- gcc-12.1.0-original/gcc/config/tms9900/tms9900.cc	1969-12-31 19:00:00.000000000 -0500
+++ gcc-12.1.0/gcc/config/tms9900/tms9900.cc	2024-03-13 00:00:04.698224896 -0400
@@ -0,0 +1,4023 @@
+#include "insn-modes.h"
+#include <stdio.h>
+#include <stdarg.h>
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "target.h"
+#include "rtl.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "attribs.h"
+#include "df.h"
+#include "memmodel.h"
+#include "insn-config.h"
+#include "insn-attr.h"
+#include "regs.h"
+#include "emit-rtl.h"
+#include "recog.h"
+#include "conditions.h"
+#include "output.h"
+#include "stor-layout.h"
+#include "varasm.h"
+#include "calls.h"
+#include "expr.h"
+#include "builtins.h"
+#include "dbxout.h"
+#include "explow.h"
+#include "expmed.h"
+#include "optabs.h"
+#include "tm.h"
+#include "target-def.h"
+#include "function.h"
+
+
+#undef  TARGET_ASM_BYTE_OP
+#define TARGET_ASM_BYTE_OP "\tbyte\t"
+
+#undef  TARGET_ASM_ALIGNED_DI_OP
+#define TARGET_ASM_ALIGNED_DI_OP NULL
+
+#undef  TARGET_ASM_ALIGNED_HI_OP
+#define TARGET_ASM_ALIGNED_HI_OP "\tdata\t"
+
+#undef  TARGET_ASM_ALIGNED_SI_OP
+#define TARGET_ASM_ALIGNED_SI_OP NULL
+
+#undef  TARGET_ASM_ALIGNED_TI_OP
+#define TARGET_ASM_ALIGNED_TI_OP NULL
+
+
+#define INSN_CLOBBER_COUNT 10
+#define SHIFT_LIST_LENGTH 20
+
+
+#define JUMP_MAX  256
+#define JUMP_MIN -252
+
+/* Identifiers for addressing modes */
+enum
+{
+  TMS9900_ADDR_NONE = 0,  /* Not an address                 */
+  TMS9900_ADDR_INDIRECT,  /* Register indirect : *Rn        */
+  TMS9900_ADDR_POSTINC,   /* Post increment    : *Rn+       */
+  TMS9900_ADDR_INDEX      /* Indexed register  : @INDEX(Rn) */
+};
+
+/* Identifiers for operand parser flags */
+enum
+{
+  OPF_FAIL    = 0x01,
+  OPF_POSTINC = 0x02,
+  OPF_LABEL   = 0x04,
+  OPF_OFFSET  = 0x08,
+  OPF_REG     = 0x10,
+  OPF_MEM     = 0x20
+};
+
+/* Identifiers for instruction pass state */
+enum
+{
+  IST_UNKNOWN = 0,
+  IST_LENGTH,
+  IST_TEXT,
+};
+
+/* Identifiers for shift merging */
+enum
+{
+  SHID_NONE = 0,
+  SHID_LEFT = 1,
+  SHID_ARITH = 2,
+  SHID_LOGIC = 4,
+  SHID_ALL = (SHID_LEFT | SHID_ARITH | SHID_LOGIC)
+};
+
+/* Function pointer type for instruction handlers */
+typedef void (*insn_func) (struct insn_info *info);
+
+
+/* Data used to add corrections for QI data in registers */
+struct fixup_info
+{
+  int  *byte_length;
+  int   first;
+  char *src_regname;
+  int   src_undo;
+};
+
+/* Data used to describe parameters for the current instruction */
+struct insn_info
+{
+  rtx_insn *insn;
+  insn_func func;
+  rtx src;
+  rtx dst_pre;
+  rtx dst;
+  rtx dst_two;
+  rtx clobber[INSN_CLOBBER_COUNT];
+  rtx *operands;
+  int code;
+  int pre_lshift;
+};
+
+/* Record used to track register data format (QI vs. HI) */
+struct reg_state_struct
+{
+  int mode;
+  rtx_insn *birth;
+  rtx_insn *death;
+};
+
+/* Record used to manage constant literals for a function */
+struct const_block
+{
+  char *name;
+  machine_mode mode;
+  int end;
+  rtx label;
+  rtx first;
+  rtx data[4096];
+};
+
+/* Record for a shift list entry */
+struct shift_list_entry
+{
+  int code;
+  int offset;
+  int pos_max;
+  int pos_min;
+  int position;
+};
+
+/* Data used to merge redundant register shifts */
+struct shift_list_state
+{
+  int length;
+  int regno;
+  int is_byte;
+  struct shift_list_entry entry[SHIFT_LIST_LENGTH];
+};
+
+/* Components of a valid address */
+struct addr_parts
+{
+  int flags;
+  rtx label;
+  int offset;
+  int regno;
+};
+
+
+static struct fixup_info s_fixup_info;
+static struct reg_state_struct reg_state[HARD_REGNUM_COUNT] = {};
+static int insn_state = IST_UNKNOWN;
+static int tms9900_dwarf_label_counter;
+static struct shift_list_state shift_list = {0};
+static struct const_block const_block_list[] =
+{
+  {"byte", QImode, 0, NULL, NULL, {NULL}},
+  {"data", HImode, 0, NULL, NULL, {NULL}}
+};
+
+/* Non-volatile registers to be saved across function calls */
+static int nvolregs[] =
+{
+  HARD_R11_REGNUM,  /* Link register */
+  HARD_R9_REGNUM,
+  HARD_R13_REGNUM,  /* Caller's workspace after BLWP */
+  HARD_R14_REGNUM,  /* Caller's PC after BLWP */
+  HARD_R15_REGNUM,  /* Caller's status register after BLWP */
+  0
+};
+
+
+bool tms9900_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,
+                                   rtx address, bool strict ATTRIBUTE_UNUSED);
+void tms9900_print_operand_address (FILE *file, machine_mode mode ATTRIBUTE_UNUSED,
+                                    register rtx addr);
+void tms9900_print_operand (FILE *file, rtx x, int code);
+
+
+/*=============================================================================
+===============================================================================
+
+                              Static functions
+
+===============================================================================
+=============================================================================*/
+
+
+/*=============================================================================
+  Helper function for tms9900_print_operand_address
+  Parse an address RTX to identify its components
+
+  Inputs : addr   - Address to parse
+           flags  - Set of flags indicating which component types were found
+           label  - Label which indicates the base address
+           offset - Number of bytes to add to the base address
+           regno  - Register whose value is added to the base address
+
+  Returns: 0 - Address cannot be parsed
+           1 - Address parsed properly
+=============================================================================*/
+static int
+parse_operand_address (rtx addr,
+                       struct addr_parts *parsed)
+{
+  switch (GET_CODE (addr))
+  {
+    case CONST:
+      /* This doesn't tell us much, dig deeper */
+      parse_operand_address (XEXP (addr, 0), parsed);
+      break;
+
+    case MEM:
+      /* This doesn't tell us much, dig deeper */
+      if (GET_CODE (XEXP (addr,0)) != SYMBOL_REF)
+      {
+        parsed->flags |= OPF_MEM;
+      }
+      parse_operand_address (XEXP (addr, 0), parsed);
+      break;
+
+    case REG:
+      /* Fail if multiple registers are used */
+      if (parsed->flags & OPF_REG)
+      {
+        parsed->flags |= OPF_FAIL;
+      }
+      parsed->flags |= OPF_REG;
+      parsed->regno = REGNO (addr);
+      break;
+
+    case POST_MODIFY:
+    case POST_INC:
+      /* Fail if multiple registers are used */
+      if (parsed->flags & OPF_REG)
+      {
+        parsed->flags |= OPF_FAIL;
+      }
+      parsed->flags |= OPF_POSTINC;
+      parsed->flags |= OPF_REG;
+      parsed->regno = REGNO (XEXP (addr, 0));
+      break;
+
+    case PLUS:
+      /* Inspect each operand */
+      parse_operand_address (XEXP (addr, 0), parsed);
+      parse_operand_address (XEXP (addr, 1), parsed);
+      break;
+
+    case CONST_INT:
+      parsed->flags |= OPF_OFFSET;
+      parsed->offset += INTVAL (addr);
+      break;
+
+    case CODE_LABEL:
+    case LABEL_REF:
+    case SYMBOL_REF:
+      /* Fail if multiple symbols are used */
+      if (parsed->flags & OPF_LABEL)
+      {
+        parsed->flags |= OPF_FAIL;
+      }
+      parsed->flags |= OPF_LABEL;
+      parsed->label = addr;
+      break;
+
+    default:
+      /* Unsupported operation */
+      parsed->flags |= OPF_FAIL;
+      break;
+  }
+
+  return ((parsed->flags & OPF_FAIL) == 0);
+}
+
+
+
+/*=============================================================================
+  Determine the addressing mode type
+
+  Inputs : op - Expression to examine
+
+  Returns: TMS9900_ADDR_NONE     - Not an address
+           TMS9900_ADDR_INDIRECT - Register indirect : *Rn
+           TMS9900_ADDR_POSTINC  - Post increment    : *Rn+
+           TMS9900_ADDR_INDEX    - Indexed register  : @INDEX(Rn)
+=============================================================================*/
+static int
+tms9900_address_type (rtx op)
+{
+  rtx addr;
+
+  /* Eliminate non-memory operations */
+  if (GET_CODE (op) != MEM)
+  {
+    return TMS9900_ADDR_NONE;
+  }
+
+  /* Decode the address now.  */
+indirection:
+  addr = XEXP (op, 0);
+  switch (GET_CODE (addr))
+  {
+    case REG:
+      /* Register indirect: *Rn */
+      return TMS9900_ADDR_INDIRECT;
+
+    case POST_INC:
+      /* Post increment: *Rn+ */
+      return TMS9900_ADDR_POSTINC;
+
+    case MEM:
+      /* Yes, we know this is a memory expression.
+         Strip this code and try again */
+      op = addr;
+      goto indirection;
+
+    case CONST:
+    case CONST_INT:
+    case LABEL_REF:
+    case SYMBOL_REF:
+      /* Indexed register : @ADDRESS(R0) - extra word required */
+      /* Fallthrough to next case */
+
+    case PLUS:
+      /* Indexed register : @INDEX(Rn) - extra word required */
+      return TMS9900_ADDR_INDEX;
+
+    default:
+      break;
+  }
+
+  /* We should never get here, but we need to return something */
+  return TMS9900_ADDR_NONE;
+}
+
+
+/*=============================================================================
+  Should we save this register in the function prologue?
+
+  Inputs : regno - Register to inspect
+
+  Returns: 0 - Do not save register
+           1 - Save register
+=============================================================================*/
+static int
+tms9900_should_save_reg (int regno)
+{
+  static int call_used_regs[] = CALL_USED_REGISTERS;
+
+  return (/* Register is used, but also non-volatile */
+          ((df_regs_ever_live_p (regno)) &&
+           (call_used_regs[regno] == 0))
+          ||
+          /* Register is R11 and this is not a leaf function */
+          ((regno == HARD_R11_REGNUM) &&
+           (crtl->is_leaf == 0)));
+}
+
+
+/*=============================================================================
+  Get number of bytes used to save registers in the current stack frame
+
+  Inputs : None
+
+  Returns: Number of bytes used for saved registers
+=============================================================================*/
+static int
+tms9900_get_saved_reg_size (void)
+{
+  int idx = 0;
+  int size = 0;
+  int *regno;
+  for (regno = &nvolregs[0]; *regno != 0; regno++)
+  {
+    if (tms9900_should_save_reg (*regno))
+    {
+      size += HARD_REG_SIZE;
+    }
+  }
+  return (size);
+}
+
+
+/*=============================================================================
+  Get low word of an SImode value
+
+  Inputs : x - RTX of source value to inspect
+
+  Returns: RTX of low word of "x" value
+=============================================================================*/
+static rtx
+si_lowpart (rtx x)
+{
+  rtx ret;
+
+  /* Handle an integer constant */
+  if (CONST_INT_P (x))
+  {
+    ret = gen_rtx_CONST_INT (HImode, (INTVAL (x) & 0xffff));
+  }
+
+  /* Handle a register */
+  else if (REG_P (x))
+  {
+    ret = gen_rtx_REG (HImode, REGNO (x) + REGS_PER_WORD);
+  }
+
+  else
+  {
+    rtx addr = XEXP (x, 0);
+    if (SYMBOL_REF_P (addr))
+    {
+      /* Handle a symbol reference */
+      rtx offset = gen_rtx_CONST_INT(HImode, HARD_REG_SIZE);
+      rtx plus = simplify_gen_binary(PLUS, HImode, addr, offset);
+      ret = gen_rtx_MEM (HImode, plus);
+    }
+    else
+    {
+      /* Handle a memory address */
+      ret = adjust_address (x, HImode, UNITS_PER_WORD);
+    }
+  }
+
+  return ret;
+}
+
+
+/*=============================================================================
+  Get high word of an SImode value
+
+  Inputs : x - RTX of source value to inspect
+
+  Returns: RTX of low word of "x" value
+=============================================================================*/
+static rtx
+si_highpart (rtx x)
+{
+  rtx ret;
+
+  /* Handle an integer constant */
+  if (CONST_INT_P (x))
+  {
+    ret = gen_rtx_CONST_INT (HImode, (INTVAL (x) >> 16));
+  }
+
+  /* Handle a register */
+  else if (REG_P (x))
+  {
+    ret = gen_rtx_REG (HImode, REGNO (x));
+  }
+
+  /* Handle an address */
+  else
+  {
+    ret = adjust_address (x, HImode, 0);
+  }
+  return ret;
+}
+
+
+/*=============================================================================
+  Initialize records for a new instruction
+
+  Inputs : x - RTX of source value to inspect
+
+  Returns: None
+=============================================================================*/
+static void
+put_insn_start (int *byte_length)
+{
+  memset (&s_fixup_info, 0, sizeof (s_fixup_info));
+  s_fixup_info.byte_length = byte_length;
+  s_fixup_info.first = 1;
+}
+
+
+/*=============================================================================
+  Emit opcodes into the output stream
+
+  Inputs : text     - Format of instruction text
+           len      - Number of bytes in assembled instruction
+           operands - RTX of operands for instruction
+           ...      - Additional values used in formatted text
+
+  Returns: None
+=============================================================================*/
+static void
+put_insn (char *text, int byte_length, rtx *operands, ...)
+{
+  char buffer[128];
+  int bufflen;
+  va_list args;
+  va_start (args, byte_length);
+
+  if (asm_out_file != NULL)
+  {
+    vsprintf (buffer, text, args);
+    output_asm_insn (buffer, operands);
+  }
+
+  *s_fixup_info.byte_length += byte_length;
+  s_fixup_info.first = 0;
+  va_end (args);
+}
+
+
+/*=============================================================================
+  Emit labels into the output stream
+
+  Inputs : label - RTX of label to emit
+
+  Returns: None
+=============================================================================*/
+static void
+put_label (rtx label)
+{
+  if (asm_out_file != NULL)
+  {
+    output_asm_label (label);
+  }
+}
+
+
+/*=============================================================================
+  Emit instructions for elements in shift list
+
+  Inputs : None
+
+  Returns: None
+=============================================================================*/
+static void shift_dump (void)
+{
+  struct shift_list_entry *entry;
+  const char *opcode;
+  int i;
+
+  for (i = 0; i < shift_list.length; i++)
+  {
+    entry = &(shift_list.entry)[i];
+    if (entry->code != 0)
+    {
+      opcode = (entry->code == SHID_LEFT  ? "sla" :
+               (entry->code == SHID_LOGIC ? "srl" :
+                                            "sra"));
+      put_insn ("%s  r%d, %d", 2, NULL, opcode, shift_list.regno, abs (entry->offset));
+    }
+  }
+  shift_list.length = 0;
+}
+
+
+/*=============================================================================
+  Try to merge elements in shift list
+
+  Inputs : index - Location in shift list to start merge
+
+  Returns: 0 - No elements merged
+           1 - One or more elements merged
+=============================================================================*/
+static int
+shift_merge (int index)
+{
+  int i;
+  int remove = 0;
+  struct shift_list_entry *end = &(shift_list.entry)[shift_list.length];
+  struct shift_list_entry *entry = &(shift_list.entry)[index];
+  struct shift_list_entry *next = entry + 1;
+  struct shift_list_entry *prev = (index == 0 ? NULL : entry - 1);
+
+  /*-------------------------------------------------------
+    See if there's any data left */
+  if ((entry->pos_max >= INT_TYPE_SIZE) ||
+      ((entry->code == SHID_LOGIC) &&
+       (entry->pos_min <= -INT_TYPE_SIZE)))
+  {
+    /* All data has been shifted out, nothing left but zeroes */
+    entry = &shift_list.entry[0];
+    entry->pos_max = 999;
+    entry->pos_min = 0;
+    entry->code = SHID_LEFT;
+    entry->position = 999;
+    entry->offset = 999;
+
+    /* Erase all other entries */
+    remove = shift_list.length - 1;
+  }
+
+  /*-------------------------------------------------------
+    Merge repeated shift types */
+  else if ((entry->code == next->code) &&
+           (next != end))
+  {
+    entry->offset += next->offset;
+    entry->position = next->position;
+    entry->pos_max = next->pos_max;
+    entry->pos_min = next->pos_min;
+    remove = 1;
+  }
+
+  /*-------------------------------------------------------
+    Remove shadowed shifts */
+  else if ((prev != NULL) &&
+           (next != NULL) &&
+           (next != end) &&
+           (entry->offset * next->offset < 0) &&
+           (((entry->code == SHID_LEFT) && (prev->pos_max == entry->pos_max)) ||
+            ((entry->code != SHID_LEFT) && (prev->pos_min == entry->pos_min))))
+  {
+    /* Shift directions differ, and front bit isn't altered by entry */
+    entry->offset += next->offset;
+    if (entry->offset < 0)
+    {
+      /* Shift left then right */
+      entry->code = ((entry->code | next->code) & (~SHID_LEFT));
+      entry->position = prev->position + entry->offset;
+      if (entry->position < entry->pos_min)
+        entry->pos_min = entry->position;
+      remove = 1;
+    }
+    else if (entry->offset > 0)
+    {
+      /* Shift right then left */
+      entry->code = SHID_LEFT;
+      entry->position = prev->position + entry->offset;
+      entry->offset = -entry->offset;
+      if (entry->position > entry->pos_max)
+        entry->pos_max = entry->position;
+      remove = 1;
+    }
+    else
+    {
+      /* Shifts cancel each other out, delete both entries */
+      entry -= 1;
+      remove = 2;
+    }
+  }
+
+  /*-------------------------------------------------------
+    Remove merged instructions */
+  if (remove > 0)
+  {
+    /* Remove "remove" entries after "entry" */
+    memmove (entry + 1, entry + remove + 1,
+             sizeof (*entry) * (shift_list.length - remove));
+    shift_list.length -= remove;
+  }
+  return (remove != 0);
+}
+
+
+/*=============================================================================
+  Make shift operation
+
+  Inputs : code  - Shift code (SHID_*)
+           count - Number of bit positions to shift
+
+  Returns: None
+=============================================================================*/
+static void
+shift_add (int code, int count)
+{
+  int recheck;
+  int i = 0;
+  struct shift_list_entry *entry = &(shift_list.entry)[shift_list.length++];
+  struct shift_list_entry *prev = entry - 1;
+  int offset = (code == SHID_LEFT ? count : -count);
+
+  if ((shift_list.is_byte) &&
+      (entry == shift_list.entry))
+  {
+    /* Add record to account for value being in high byte */
+    entry->code = 0;
+    entry->offset = 0;
+    entry->pos_max = 8;
+    entry->pos_min = 0;
+    entry->position = 8;
+
+    entry++;
+    prev++;
+    shift_list.length++;
+  }
+
+  /* Compose shift entry */
+  entry->code = code;
+  entry->offset = offset;
+  entry->position = offset;
+  entry->pos_max = 0;
+  entry->pos_min = 0;
+
+  /* Update position min and max */
+  if (prev >= &(shift_list.entry)[0])
+  {
+    entry->position = prev->position + offset;
+    entry->pos_max = prev->pos_max;
+    entry->pos_min = prev->pos_min;
+  }
+
+  if (entry->pos_max < entry->position)
+    entry->pos_max = entry->position;
+
+  if (entry->pos_min > entry->position)
+    entry->pos_min = entry->position;
+
+  /* Keep looping through state list trying to merge elements */
+  do
+  {
+    recheck = 0;
+    for (i = 0; i < shift_list.length; i++)
+    {
+      if (shift_merge (i))
+      {
+        recheck = 1;
+        break;
+      }
+    }
+  } while (recheck);
+}
+
+
+/*=============================================================================
+  Determine if a register is in QI or HI mode
+
+  Inputs : reg  - RTX of register to inspect
+
+  Returns: true  - Register is in QI mode
+           false - Register is in HI mode
+=============================================================================*/
+static bool
+is_qi_high (rtx reg)
+{
+  int mode;
+  int offset;
+  int regno;
+  bool ret = false;
+
+  if (reg && REG_P (reg))
+  {
+    mode = GET_MODE (reg);
+    offset = REG_OFFSET (reg).coeffs[0];
+    regno=REGNO (reg);
+
+    /* Inspect register offset to determine previous mode */
+    if ((reg_state[regno].mode == 0) ||
+        (reg_state[regno].mode == QImode))
+    {
+      if (((mode == QImode) &&
+           (offset == 0))
+          ||
+          ((mode == HImode) &&
+           (offset == -1)))
+      {
+        ret = true;
+      }
+    }
+
+    if ((ret == false) &&
+        (reg_state[regno].mode == QImode))
+    {
+      /* This register was previously marked as using QImode */
+      ret = true;
+    }
+  }
+  return (ret);
+}
+
+
+/*=============================================================================
+  Add a shift instruction
+
+  Inputs : code  - RTL code for shift instruction
+           reg   - RTX of register to inspect
+           count - Number of bit positions to shift
+           mode  - Force register to use this mode
+
+  Returns: None
+=============================================================================*/
+static void
+put_reg_shift (int code, rtx reg, int count, int mode)
+{
+  static int last_insn_state;
+  int regno = REGNO (reg);
+  code = (code == ASHIFT   ? SHID_LEFT :
+         (code == ASHIFTRT ? SHID_ARITH : SHID_LOGIC));
+
+  shift_list.is_byte = is_qi_high (reg);
+
+  /* Handle forced modes */
+  if (mode == QImode)
+  {
+    shift_list.is_byte = 1;
+  }
+  else if (mode == HImode)
+  {
+    shift_list.is_byte = 0;
+  }
+
+  /* Dump instructions if the shift register changes */
+  if (insn_state != last_insn_state)
+  {
+    shift_list.length = 0;
+  }
+  last_insn_state = insn_state;
+
+  if ((shift_list.length > 0) &&
+      (regno != shift_list.regno))
+  {
+    /* Register has changed, dump accumulated shifts */
+    shift_dump ();
+  }
+
+  shift_list.regno = regno;
+  shift_add (code, count);
+}
+
+
+/*=============================================================================
+  Set current register mode
+
+  Inputs : insn - Current instruction
+           reg  - RTX for register
+           mode - Desired mode
+
+  Returns: None
+=============================================================================*/
+static void
+set_reg_mode (rtx_insn *insn, rtx reg, int mode)
+{
+  int regno;
+
+  if (is_qi_high (reg))
+  {
+    if (mode == HImode)
+    {
+      /* Convert from QImode to HImode */
+      put_reg_shift (ASHIFTRT, reg, 8, HImode);
+    }
+  }
+  else
+  {
+    if (mode == QImode)
+    {
+      /* Convert from HImode to QImode */
+      put_reg_shift (ASHIFT, reg, 8, HImode);
+    }
+  }
+  regno = REGNO (reg);
+  reg_state[regno].mode = mode;
+  reg_state[regno].birth = insn;
+}
+
+
+/*=============================================================================
+  Update register mode tracking records
+
+  Inputs : info  - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+update_reg_info (struct insn_info *info)
+{
+  int regno;
+  int mode;
+
+  if ((info->dst != NULL) &&
+      (REG_P(info->dst)))
+  {
+    regno = REGNO (info->dst);
+    mode = GET_MODE (info->dst);
+    if (mode == SImode)
+    {
+      reg_state[regno + 1].mode = mode;
+      reg_state[regno + 1].birth = info->insn;
+    }
+    reg_state[regno].mode = mode;
+    reg_state[regno].birth = info->insn;
+
+    /* Check for death of the register in the current shift list */
+    if (find_regno_note (info->insn, REG_DEAD, shift_list.regno) != NULL)
+    {
+      /* Current shifted register is dead, clear shift list */
+      shift_list.length = 0;
+    }
+
+    if (find_regno_note (info->insn, REG_DEAD, regno) != NULL)
+    {
+      /* Register dies this instruction */
+      reg_state[regno].death = info->insn;
+    }
+    else
+    {
+      /* Register is still alive, check for a USE instruction */
+      rtx_insn *insn = info->insn;
+      do
+      {
+        insn = NEXT_INSN (insn);
+      } while ((insn != NULL) &&
+               (INSN_P (insn) == 0));
+
+      if ((insn != NULL) &&
+          (INSN_P (insn)))
+      {
+        /* We found a USE instruction */
+        rtx expr = PATTERN (insn);
+        if (GET_CODE (expr) == USE)
+        {
+          /* See if the USE pertains to this instruction's target */
+          expr = XEXP (expr,0);
+          if (REG_P (expr) &&
+             (regno == REGNO (info->dst)))
+          {
+            /* Switch register mode if needed */
+            int use_mode = GET_MODE (expr);
+            if ((reg_state[regno].mode != use_mode)
+               &&
+               ((reg_state[regno].mode == QImode) ||
+                (use_mode == QImode)))
+            {
+              if (use_mode == QImode)
+              {
+                /* Switch from word to byte mode */
+                put_reg_shift (ASHIFT, info->dst, 8, HImode);
+              }
+              else
+              {
+                /* Switch from byte to word mode */
+                put_reg_shift (ASHIFTRT, info->dst, 8, HImode);
+              }
+              reg_state[regno + 1].mode = use_mode;
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+
+/*=============================================================================
+  Return number of additional instruction bytes needed for an operand
+
+  Inputs : op - RTX for operand
+
+  Returns: Number of needed bytes
+=============================================================================*/
+static int
+operand_length (rtx op)
+{
+  int len = 0;
+
+  retry:
+  if (op != NULL)
+  {
+    switch (GET_CODE (op))
+    {
+      case MEM:
+        op = XEXP (op, 0);
+        goto retry;
+
+      case REG:
+      case POST_MODIFY:
+      case POST_INC:
+        len = 0;
+        break;
+
+      default:
+        len = 2;
+        break;
+    }
+  }
+  return (len);
+}
+
+
+/*=============================================================================
+  Handle byte-word conversions of the destination before the instruction
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+fixup_pre_dst (struct insn_info *info)
+{
+  char text[32];
+  int want_qi_high;
+
+  if ((info->dst_pre != NULL) &&
+      (GET_CODE (info->dst_pre) == REG))
+  {
+    want_qi_high = (GET_MODE (info->dst_pre) == QImode);
+    if ((info->dst_pre != NULL) &&
+        (is_qi_high (info->dst_pre) != want_qi_high))
+    {
+      /* Need to switch register mode */
+      if (want_qi_high == 0)
+      {
+        /* Switch from byte to word mode */
+        put_reg_shift (ASHIFTRT, info->dst_pre, 8, HImode);
+      }
+      else
+      {
+        /* Switch from word to byte mode */
+        put_reg_shift (ASHIFT, info->dst_pre, 8, HImode);
+      }
+    }
+  }
+}
+
+
+/*=============================================================================
+  Handle byte-word conversions of the source before the instruction
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+fixup_pre_src (struct insn_info *info)
+{
+  int want_qi_high;
+
+  if (info->src && info->dst)
+  {
+    s_fixup_info.src_regname = "%%2";
+    if (REG_P (info->src))
+    {
+      /* Are source and destination in the same mode? */
+      want_qi_high = (GET_MODE (info->dst) == QImode);
+      if (is_qi_high (info->src) != want_qi_high)
+      {
+        /* Need to switch register mode */
+        s_fixup_info.src_regname = (char*)reg_names[REGNO (info->src)];
+        if (want_qi_high == 0)
+        {
+          /* Switch from byte to word mode */
+          if (info->code == ZERO_EXTEND)
+          {
+            put_reg_shift (LSHIFTRT, info->src, 8, HImode);
+          }
+          else
+          {
+            put_reg_shift (ASHIFTRT, info->src, 8, HImode);
+          }
+        }
+        else
+        {
+          /* Switch from word to byte mode */
+          put_reg_shift (ASHIFT, info->src, 8, HImode);
+        }
+        if ((REG_P (info->dst)) &&
+            (REGNO (info->dst) != REGNO (info->src)) &&
+            (find_regno_note (info->insn, REG_DEAD, REGNO (info->src)) == NULL))
+        {
+          s_fixup_info.src_undo = 1;
+        }
+      }
+    }
+  }
+}
+
+
+/*=============================================================================
+  Handle byte-word conversions of the source and destination before the instruction
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+fixup_pre_all (struct insn_info *info)
+{
+  fixup_pre_dst (info);
+  fixup_pre_src (info);
+
+  /* If the shift stack is not empty and this is a non-shift
+     instruction, dump the contents of the shift stack */
+  if ((shift_list.length != 0) &&
+      (info->code != ASHIFT) &&
+      (info->code != ASHIFTRT) &&
+      (info->code != LSHIFTRT) &&
+      (info->code != SIGN_EXTEND) &&
+      (info->code != ZERO_EXTEND))
+  {
+    /* Dump shift stack */
+    shift_dump ();
+  }
+}
+
+
+/*=============================================================================
+  Handle byte-word conversions of the source after the instruction
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+fixup_post (struct insn_info *info)
+{
+  if (s_fixup_info.src_undo)
+  {
+    put_insn ("swpb %s", 2, NULL, s_fixup_info.src_regname);
+  }
+}
+
+
+/*=============================================================================
+  Print operand to a string
+
+  Inputs : op - RTX for operand
+
+  Returns: Pointer to buffer holding operand text
+=============================================================================*/
+static char*
+sprint_operand (rtx op)
+{
+  static int max_length = 128;
+  static char buffer[1024] = {0};
+  static char *ptr = &buffer[0];
+  FILE *temp;
+  FILE *old_out_file;
+
+  /* Point to next unused part of the buffer */
+  ptr += strlen (ptr) + 1;
+  if (ptr > &buffer[sizeof (buffer) - max_length])
+  {
+    ptr = &buffer[0];
+  }
+
+  /* Get test for operand */
+  ptr[0] = 0;
+  if ((op != NULL) &&
+      (asm_out_file != NULL))
+  {
+    temp = tmpfile ();
+    if (temp != NULL)
+    {
+      /* Point out file to our temp file */
+      old_out_file = asm_out_file;
+      asm_out_file = temp;
+
+      /* Print operand */
+      if (GET_CODE (op) == MEM)
+        tms9900_print_operand_address (temp, GET_MODE(op), op);
+      else
+        tms9900_print_operand (temp, op, 0);
+
+      /* Get operand text */
+      rewind (temp);
+      if (fgets (ptr, max_length, temp) == NULL)
+      {
+        ptr[0] = 0;
+      }
+
+      /* Restore out file and close temp file */
+      asm_out_file = old_out_file;
+      fclose (temp);
+    }
+  }
+  return (ptr);
+}
+
+
+/*=============================================================================
+  Add a value to a block of constants for this function
+
+  Inputs : value - RTX of value to add
+           mode  - Mode of value to add
+
+  Returns: RTX of added constant
+=============================================================================*/
+static rtx
+add_block_constant (rtx value, machine_mode mode)
+{
+  struct const_block *block;
+  rtx retval = NULL;
+  int block_idx;
+  int i;
+
+  /* Search for appropriate block */
+  for (block_idx = 0; block_idx < sizeof (const_block_list) / sizeof (const_block_list[0]); block_idx++)
+  {
+    /* Check block params */
+    block = &const_block_list[block_idx];
+    if ((mode == block->mode) &&
+        (block->end < sizeof (block->data)))
+    {
+      /* Make label for this block of constants */
+      if ((block->label == NULL) ||
+          (GET_CODE (block->label) != CODE_LABEL))
+      {
+        block->label = gen_label_rtx ();
+        block->first = gen_rtx_MEM (Pmode, block->label);
+      }
+
+      /* Check for match against existing value */
+      for (i = 0; i < block->end; i++)
+      {
+        if (rtx_equal_p (value, block->data[i]))
+        {
+          /* Found a match, reuse this constant */
+          retval = adjust_address (block->first, Pmode, i * GET_MODE_SIZE (block->mode));
+          break;
+        }
+      }
+
+      /* Add constant to block */
+      if (retval == NULL)
+      {
+        block->data[block->end] = value;
+        retval = adjust_address (block->first, Pmode, block->end * GET_MODE_SIZE (block->mode));
+        block->end++;
+      }
+      break;
+    }
+  }
+  return (retval);
+}
+
+
+/*=============================================================================
+  Make ABS instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_abs (struct insn_info *info)
+{
+  int dst_length = operand_length (info->dst);
+
+  /* --- 32-bit operation --- */
+  if (GET_MODE (info->dst) == SImode)
+  {
+    char *highname = sprint_operand (si_highpart (info->dst));
+    char *lowname = sprint_operand (si_lowpart (info->dst));
+
+    put_insn ("abs  %s",    2 + dst_length, NULL, highname);
+    put_insn ("jgt  $+>%x", 2, NULL, 8 + 2 * dst_length);
+    put_insn ("neg  %s",    2 + dst_length, NULL, lowname);
+    put_insn ("joc  $+>%x", 2, NULL, 4 + dst_length);
+    put_insn ("dec  %s",    2 + dst_length, NULL, highname);
+  }
+
+  /* --- 16-bit operation --- */
+  else if (GET_MODE (info->dst) == HImode)
+  {
+    put_insn ("abs  %%0", 2 + dst_length, info->operands);
+  }
+
+  /* --- 8-bit operation --- */
+  else if (GET_MODE (info->dst) == QImode)
+  {
+    if (REG_P (info->dst))
+    {
+      put_insn ("andi %%0, >ff00", 4, info->operands);
+      put_insn ("abs  %%0", 2, info->operands);
+    }
+    else
+    {
+      gcc_unreachable ();
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make AND instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_and (struct insn_info *info)
+{
+  int val;
+  rtx const_value;
+
+  /* --- 16-bit operation --- */
+  if (GET_MODE (info->dst) == HImode)
+  {
+    /* Source is constant */
+    if (GET_CODE (info->src) == CONST_INT)
+    {
+      val = INTVAL (info->src) & 0xffff;
+      if (val == 0)
+        put_insn ("clr  %%0", 2, info->operands);
+      else if (val != 0xffff)
+      {
+        /* Destination is register */
+        if (REG_P (info->dst))
+        {
+          put_insn ("andi %%0, >%x", 4, info->operands, (val & 0xffff));
+        }
+
+        /* Destination is memory */
+        else
+        {
+          const_value = add_block_constant (GEN_INT ((val ^ 0xffff) & 0xffff), HImode);
+          put_insn ("szc  %s, %%0", 2 + operand_length (const_value) + operand_length (info->dst),
+                                    info->operands,
+                                    sprint_operand (const_value));
+        }
+      }
+    }
+
+    /* Source is memory or register */
+    else
+    {
+      /* Invert source, SZC is wierd */
+      put_insn ("mov  %%2, %%3", 2 + operand_length (info->src), info->operands);
+      put_insn ("inv  %%3", 2, info->operands);
+      put_insn ("szc  %%3, %%0", 2 + operand_length (info->dst), info->operands);
+    }
+  }
+
+  /* --- 8-bit operation --- */
+  if (GET_MODE (info->dst) == QImode)
+  {
+    /* Source is constant */
+    if (GET_CODE (info->src) == CONST_INT)
+    {
+      val = (INTVAL (info->src) & 0xff);
+
+      /* Destination is a register */
+      if (REG_P (info->dst))
+      {
+        if (val == 0)
+          put_insn ("clr  %%0", 2, info->operands);
+        else if (val != 0xff)
+          put_insn ("andi %%0, >%x", 4, info->operands, ((val * 0x100) & 0xffff));
+      }
+
+      /* Destination is memory */
+      else
+      {
+        const_value = add_block_constant (GEN_INT ((val ^ 0xff) & 0xff), QImode);
+        put_insn ("szcb %s, %%0", 2 + operand_length (const_value) + operand_length (info->dst),
+                                  info->operands,
+                                  sprint_operand (const_value));
+      }
+    }
+
+    /* Source is memory or register */
+    else
+    {
+      /* Invert source, SZC is wierd */
+      put_insn ("movb %%2, %%3", 2 + operand_length (info->src), info->operands);
+      put_insn ("inv  %%3", 2, info->operands);
+      put_insn ("szcb %%3, %%0", 2 + operand_length (info->dst), info->operands);
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make ASHIFT instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_ashift (struct insn_info *info)
+{
+  rtx ops[7];
+  int offset;
+
+  /* --- 32-bit operation --- */
+  if (GET_MODE (info->dst) == SImode)
+  {
+    ops[0] = info->operands[0];  /* Destination */
+    ops[1] = info->operands[1];  /* Source */
+    ops[2] = info->operands[2];  /* Shift count */
+    ops[3] = info->operands[3];  /* Scratch reg */
+    ops[4] = gen_rtx_REG (HImode, REGNO (info->operands[0]) + REGS_PER_WORD);  /* Low word of source */
+
+    if (GET_CODE (info->src) == CONST_INT)
+    {
+      /* Constant shift */
+      offset = INTVAL (info->operands[2]);
+      ops[5] = GEN_INT (16 - offset);  /* Complement of shift count */
+      ops[6] = GEN_INT (offset % 16);  /* Modulo of shift count */
+
+      if (offset < 16)
+      {
+        if (offset == 8)
+        {
+          put_insn ("movb %%4, %%1", 2, ops);  /* Move MSB of high word */
+          put_insn ("sb   %%4, %%4", 2, ops);  /* Clear MSB of high word */
+          put_insn ("swpb %%1",      2, ops);  /* Swap bytes in low word */
+          put_insn ("swpb %%4",      2, ops);  /* Swap bytes in high word */
+        }
+        else
+        {
+          put_insn ("mov  %%4, %%3", 2, ops);  /* Save low word to temp */
+          put_insn ("sla  %%1, %%2", 2, ops);  /* Shift high word */
+          put_insn ("sla  %%4, %%2", 2, ops);  /* Shift low word */
+          put_insn ("srl  %%3, %%5", 2, ops);  /* Shift low word bits into high word position */
+          put_insn ("soc  %%3, %%1", 2, ops);  /* Merge low word bits into high word */
+        }
+      }
+      else
+      {
+        if (offset > 16)
+        {
+          put_insn ("sla  %%4, %%6", 2, ops);  /* Shift low word */
+        }
+        put_insn ("mov  %%4, %%1", 2, ops);  /* Move low word into high word */
+        put_insn ("clr  %%4",      2, ops);  /* Clear low word */
+      }
+    }
+
+    else
+    {
+      /* Variable shift */
+      put_insn ("ci   %%2, 16",  4, ops);  /* +0: Compare shift to 16 */
+      put_insn ("jlt  $+12",     2, ops);  /* +4: If shift was < 16, goto lt_16 */
+      put_insn ("jeq  $+4",      2, ops);  /* +6: If shift was 16, goto eq_16 */
+
+      /* Shift count greater than 16 */
+      put_insn ("sla  %%4, %%2", 2, ops);  /* +8: Shift low word */
+
+      /* eq_16: Shift count equals 16 */
+      put_insn ("mov  %%4, %%1", 2, ops);  /* +10: Copy low word to high word */
+      put_insn ("clr  %%4",      2, ops);  /* +12: Clear low word */
+      put_insn ("jmp  $+20",     2, ops);  /* +14: Goto end */
+
+      /* lt_16: Shift count less than 16 */
+      put_insn ("abs  %%2",      2, ops);  /* +16: Test shift count */
+      put_insn ("jeq  $+16",     2, ops);  /* +18: If shift==0, goto end */
+      put_insn ("mov  %%4, %%3", 2, ops);  /* +20: Save low word to temp */
+      put_insn ("sla  %%1, %%2", 2, ops);  /* +22: Shift high word */
+      put_insn ("sla  %%4, %%2", 2, ops);  /* +24: Shift low word */
+      put_insn ("neg  %%2",      2, ops);  /* +26: Get complement of shift count */
+      put_insn ("srl  %%3, %%2", 2, ops);  /* +28: Shift low word bits into high word position */
+      put_insn ("soc  %%3, %%1", 2, ops);  /* +30: Merge shifted low word bits into high word */
+      put_insn ("neg  %%2",      2, ops);  /* +32: Restore shift count */
+      /* +34: End */
+    }
+  }
+
+  /* --- 8-bit and 16-bit operation --- */
+  else
+  {
+    if (GET_MODE (info->dst) == QImode)
+    {
+      put_insn ("andi %%0, >FF00", 4, info->operands);
+    }
+
+    if (REG_P (info->src))
+    {
+      put_insn ("abs  r0"      , 2, info->operands);
+      put_insn ("jeq  $+8"     , 2, info->operands);  /* If shift count is zero, do nothing */
+      put_insn ("sla  %%0, 0"  , 2, info->operands);
+    }
+    else
+    {
+      put_reg_shift (ASHIFT, info->dst, INTVAL (info->src), 0);
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make ASHIFTRT instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_ashiftrt (struct insn_info *info)
+{
+  rtx ops[7];
+  int offset;
+
+  /* --- 32-bit operation --- */
+  if (GET_MODE (info->dst) == SImode)
+  {
+    ops[0] = info->operands[0];  /* Destination */
+    ops[1] = info->operands[1];  /* Source */
+    ops[2] = info->operands[2];  /* Shift count */
+    ops[3] = info->operands[3];  /* Scratch reg */
+    ops[4] = gen_rtx_REG (HImode, REGNO (info->operands[0]) + REGS_PER_WORD);  /* Low word of source */
+
+    if (GET_CODE (info->src) == CONST_INT)
+    {
+      /* Constant shift */
+      offset = INTVAL (info->operands[2]);
+      ops[5] = GEN_INT (16 - offset);  /* Complement of shift count */
+      ops[6] = GEN_INT (offset % 16);  /* Modulo of shift count */
+
+      if (offset < 16)
+      {
+        put_insn ("mov  %%1, %%3", 2, ops);  /* Save high word to temp */
+        put_insn ("sra  %%1, %%6", 2, ops);  /* Shift high word */
+        put_insn ("srl  %%4, %%6", 2, ops);  /* Shift low word */
+        put_insn ("sla  %%3, %%5", 2, ops);  /* Shift high word bits into low word position */
+        put_insn ("soc  %%3, %%4", 2, ops);  /* Merge shifted high word bits into low word */
+      }
+      else
+      {
+        if (offset > 16)
+        {
+          put_insn ("sra  %%1, %%6", 2, ops);  /* Shift high word */
+        }
+        put_insn ("mov  %%1, %%4", 2, ops);  /* Copy high word to low word */
+        put_insn ("seto %%1",      2, ops);  /* Assume negative value, set high word */
+        put_insn ("jlt  $+4",      2, ops);  /* If value was negative, skip next instruction */
+        put_insn ("clr  %%1",      2, ops);  /* Clear high word */
+      }
+    }
+    else
+    {
+      /* Variable shift */
+      put_insn("ci   %%2, 16",  4, ops);  /* +0: Compare shift to 16 */
+      put_insn("jlt  $+16",     2, ops);  /* +4: If shift was < 16, goto lt_16 */
+      put_insn("jeq  $+4",      2, ops);  /* +6: If shift was 16, goto eq_16 */
+
+      /* Shift count greater than 16 */
+      put_insn("sra  %%1, %%2", 2, ops);  /* +8: Shift high word */
+
+      /* eq_16: Shift count equals 16 */
+      put_insn("mov  %%1, %%4", 2, ops);  /* +10: Copy high word to low word */
+      put_insn("seto %%1",      2, ops);  /* +12: Assume negative value, set high word */
+      put_insn("jlt  $+4",      2, ops);  /* +14: If value was negative, skip next instruction */
+      put_insn("clr  %%1",      2, ops);  /* +16: Clear high word */
+      put_insn("jmp  $+20",     2, ops);  /* +18: Goto end */
+
+      /* lt_16: Shift count less than 16 */
+      put_insn("abs  %%2",      2, ops);  /* +20: Test shift count */
+      put_insn("jeq  $+16",     2, ops);  /* +22: If shift==0, goto end */
+      put_insn("mov  %%4, %%3", 2, ops);  /* +24: Save high word to temp */
+      put_insn("sra  %%1, %%2", 2, ops);  /* +26: Shift high word */
+      put_insn("srl  %%4, %%2", 2, ops);  /* +28: Shift low word */
+      put_insn("neg  %%2",      2, ops);  /* +30: Get complement of shift count */
+      put_insn("sla  %%3, %%2", 2, ops);  /* +32: Shift high word bits into low word position */
+      put_insn("soc  %%3, %%4", 2, ops);  /* +34: Merge shifted high word bits into low word */
+      put_insn("neg  %%2",      2, ops);  /* +36: Restore shift count */
+      /* +38: End */
+    }
+  }
+
+  /* --- 8-bit and 16-bit operation --- */
+  else
+  {
+    if (GET_MODE (info->dst) == QImode)
+    {
+      put_insn ("andi %%0, >FF00", 4, info->operands);
+    }
+
+    if (REG_P (info->src))
+    {
+      put_insn ("abs  r0"      , 2, info->operands);
+      put_insn ("jeq  $+8"     , 2, info->operands);  /* If shift count is zero, do nothing */
+      put_insn ("sra  %%0, 0"  , 2, info->operands);
+    }
+    else
+    {
+      put_reg_shift (ASHIFTRT, info->dst, INTVAL (info->src), 0);
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make branch instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_branch (struct insn_info *info)
+{
+  const char *pos, *neg;
+
+  /* Get branch instruction */
+  switch (GET_CODE (info->operands[0]))
+  {
+    case EQ:  pos = "jeq";  neg = "jne"; break;
+    case NE:  pos = "jne";  neg = "jeq"; break;
+    case GT:  pos = "jgt";  neg = "jle"; break;
+    case GTU: pos = "jh ";  neg = NULL;  break;
+    case LT:  pos = "jlt";  neg = NULL;  break;
+    case LTU: pos = "jl ";  neg = "jhe"; break;
+    case GE:  pos = NULL;   neg = "jlt"; break;
+    case GEU: pos = "jhe";  neg = "jl "; break;
+    case LE:  pos = "jle";  neg = "jgt"; break;
+    case LEU: pos = NULL;   neg = "jh "; break;
+    default: gcc_unreachable ();
+  }
+
+  switch (get_attr_length (info->insn))
+  {
+    case 2:
+      /* Near jump, use positive logic */
+      put_insn ("%s  %%l1", 2, info->operands, pos);
+      break;
+
+    case 4:
+      /* Near jump, use negative logic */
+      put_insn ("%s  $+4", 2, info->operands, neg);
+      put_insn ("jmp  %%l1", 2, info->operands);
+      break;
+
+    case 6:
+      /* Far jump, use positive logic */
+      put_insn ("%s  $+6", 2, info->operands, neg);
+      put_insn ("b    @%%l1", 4, info->operands);
+      break;
+
+    case 8:
+      /* Far jump, use negative logic */
+      put_insn ("%s  $+4", 2, info->operands, pos);
+      put_insn ("jmp $+6", 2, info->operands);
+      put_insn ("b    @%%l1", 4, info->operands);
+      break;
+
+    default:
+      gcc_unreachable();
+  }
+}
+
+
+/*=============================================================================
+  Make CALL instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_call (struct insn_info *info)
+{
+  int i;
+  static int call_used_registers[] = CALL_USED_REGISTERS;
+  int arg = (info->code < 0 ? 0 : 1);
+
+  if (SIBLING_CALL_P (info->insn))
+  {
+    put_insn ("b    %%%d", operand_length (info->dst), info->operands, arg);
+  }
+  else
+  {
+    put_insn ("bl   %%%d", operand_length (info->dst), info->operands, arg);
+  }
+
+  /* Clear state for call-clobbered registers */
+  for (i = 0; i < HARD_REGNUM_COUNT; i++)
+  {
+    if (call_used_registers[i] != 0)
+    {
+      memset (&reg_state[i], 0, sizeof (reg_state[0]));
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make COMPARE instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_compare (struct insn_info *info)
+{
+  int intval;
+  int reg_dead;
+  rtx const_value;
+
+  /* --- 16-bit operation --- */
+  if (GET_MODE (info->dst) == HImode)
+  {
+    if (GET_RTX_CLASS (GET_CODE (info->src)) == RTX_CONST_OBJ)
+    {
+      intval = INTVAL (info->src);
+      if(REG_P (info->dst))
+      {
+        /* Destination is a register */
+        if ((find_regno_note (info->insn, REG_DEAD, REGNO (info->dst))) &&
+            (GET_CODE (info->src) == CONST_INT) &&
+            (intval >= -2) &&
+            (intval <= 2))
+        {
+          /* Use optimized instruction */
+          put_insn ("%s%%0", 2, info->operands,
+                             (intval == -2 ? "inct " :
+                             (intval == -1 ? "inc  " :
+                             (intval ==  0 ? "abs  " :
+                             (intval ==  1 ? "dec  " :
+                             (intval ==  2 ? "dect " :
+                                               ""))))));
+        }
+        else
+        {
+          /* Compare register and constant */
+          if (intval == 0)
+          {
+            /* Compare with zero */
+            put_insn ("mov  %%0, %%0", 2 + operand_length (const_value) + operand_length (info->dst),
+                                       info->operands);
+          }
+          else
+          {
+            /* Compare against some other constant */
+            put_insn ("ci   %%0, %%1", 2 + operand_length (info->src),
+                                       info->operands);
+          }
+        }
+      }
+      else
+      {
+        /* Destination is memory */
+        if (GET_CODE(info->src) == CONST_INT)
+        {
+          if (intval == 0)
+          {
+            /* Compare with zero */
+            put_insn ("mov  %%0, %%0", 2 + operand_length (const_value) + operand_length (info->dst),
+                                       info->operands);
+          }
+          else
+          {
+            /* Compare with non-zero */
+            const_value = add_block_constant (GEN_INT (intval & 0xffff), HImode);
+            put_insn ("c    %%0, %s", 2 + operand_length (const_value) + operand_length (info->dst),
+                                      info->operands,
+                                      sprint_operand (const_value));
+          }
+        }
+      }
+    }
+    else
+    {
+      /* Compare with non-constant value */
+      put_insn ("c    %%0, %%1", 2 + operand_length (info->src) + operand_length (info->dst),
+                                info->operands);
+    }
+  }
+
+  /* --- 8-bit operation --- */
+  else if (GET_MODE (info->dst) == QImode)
+  {
+    /* Source is a constant */
+    if (GET_CODE (info->src) == CONST_INT)
+    {
+      intval = INTVAL (info->src);
+      if (intval == 0)
+        put_insn ("movb %%0, %%0", 2, info->operands);
+      else
+      {
+      const_value = add_block_constant (GEN_INT (intval & 0xff), QImode);
+      put_insn ("cb   %%0, %s", 2 + operand_length (const_value) + operand_length (info->dst),
+                                info->operands,
+                                sprint_operand (const_value));
+      }
+    }
+    /* Source is not a constant */
+    else
+    {
+      put_insn ("cb   %%0, %%1", 2 + operand_length (info->dst) + operand_length (info->src),
+                                 info->operands);
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make DIV instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_div (struct insn_info *info)
+{
+  rtx x;
+  int fixup_div = 1;
+  int fixup_mod = 1;
+  const char *name_lowpart = reg_names[REGNO (info->operands[5])];
+  const char *name_highpart = reg_names[REGNO (info->operands[5]) + 1];
+
+  /* Determine if one of the outputs is not used */
+  for (x = REG_NOTES (info->insn); x; x = XEXP (x, 1))
+  {
+    if (REG_NOTE_KIND (x) == REG_DEAD || REG_NOTE_KIND (x) == REG_UNUSED)
+    {
+      rtx note = XEXP (x, 0);
+      if (REG_P (note))
+      {
+        if (REGNO (note) == REGNO (info->dst)) fixup_div = 0;
+        if (REGNO (note) == REGNO (info->dst_two)) fixup_mod = 0;
+      }
+    }
+  }
+
+  /* Operand usage:
+       operand[0] - Division result
+       operand[1] - Dividend
+       operand[2] - Divisor
+       operand[3] - Modulo result
+       operand[4] - Absolute value of divisor / Temporary value
+       operand[5] - High word of temporary 32-bit quantity
+  */
+
+  /* Copy dividend into position */
+  put_insn ("mov  %%1, %s", 2 + operand_length (info->dst_pre), info->operands, name_lowpart);
+  put_insn ("clr  %s", 2, info->operands, name_highpart);
+
+  /* Copy divisor into position */
+  put_insn ("mov  %%2, %%4",  2 + operand_length (info->src), info->operands);
+
+  /* Convert operands to absolute value */
+  put_insn ("abs  %s", 2, info->operands, name_lowpart);
+  put_insn ("abs  %%4", 2, info->operands);
+
+  /* Perform division and modulus */
+  put_insn ("div  %%4, %s", 2, info->operands, name_lowpart);
+
+  /* Prepare for sign correction */
+  put_insn ("mov  %%1, %%4", 2 + operand_length (info->dst_pre),
+                             info->operands);
+
+  /* Correct sign of modulo result */
+  if (fixup_mod)
+  {
+    /* Use sign of dividend. Condition flags were set in the previous function */
+    put_insn ("jgt  $+4", 2, info->operands);
+    put_insn ("neg  %s", 2, info->operands, name_lowpart);
+    put_insn ("mov  %s, %%3", 2, info->operands, name_lowpart);
+  }
+
+  /* Correct sign of division result */
+  if (fixup_div)
+  {
+    /* Use sign of XOR of dividend and divisor */
+    put_insn ("xor  %%2, %%4", 2 + operand_length (info->src), info->operands);
+    put_insn ("jlt  $+4", 2, info->operands);
+    put_insn ("neg  %s", 2, info->operands, name_lowpart);
+    put_insn ("mov  %s, %%0", 2, info->operands, name_highpart);
+  }
+}
+
+
+/*=============================================================================
+  Make IOR instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_ior (struct insn_info *info)
+{
+  int intval;
+  rtx const_value;
+
+  /* --- 16-bit operation --- */
+  if (GET_MODE (info->dst) == HImode)
+  {
+    /* Source is constant */
+    if (GET_CODE (info->src) == CONST_INT)
+    {
+      intval = INTVAL (info->src) & 0xffff;
+      if (intval == 0xffff)
+        put_insn ("seto %%0", 2, info->operands);
+      else if (intval != 0)
+      {
+        /* Destination is register */
+        if (REG_P (info->dst))
+        {
+          put_insn ("ori  %%0, >%x", 4, info->operands, (intval & 0xffff));
+        }
+
+        /* Destination is memory */
+        else
+        {
+          const_value = add_block_constant (GEN_INT (intval & 0xffff), HImode);
+          put_insn ("soc  %s, %%0", 2 + operand_length (const_value) + operand_length (info->dst),
+                                    info->operands,
+                                    sprint_operand (const_value));
+        }
+      }
+    }
+
+    /* Source is register or memory */
+    else
+    {
+      put_insn ("soc  %%2, %%0", 2 + operand_length (info->src) + operand_length (info->dst),
+                                 info->operands);
+    }
+  }
+
+  /* --- 8-bit operation --- */
+  if (GET_MODE (info->dst) == QImode)
+  {
+    /* Source is constant */
+    if (GET_CODE (info->src) == CONST_INT)
+    {
+      intval = (INTVAL (info->src) & 0xff);
+
+      /* Destination is a register */
+      if (REG_P (info->dst))
+      {
+        if (intval == 0xff)
+          put_insn ("clr  %%0", 2, info->operands);
+        else if (intval != 0)
+          put_insn ("ori  %%0, >%x", 4, info->operands, ((intval * 0x100) & 0xff00));
+      }
+
+      /* Destination is memory */
+      else
+      {
+        const_value = add_block_constant (GEN_INT (intval & 0xff), QImode);
+        put_insn ("socb %s, %%0", 2 + operand_length (const_value) + operand_length (info->dst),
+                                  info->operands,
+
+                             sprint_operand (const_value));
+      }
+    }
+
+    /* Source is register or memory */
+    else
+    {
+      put_insn ("socb %%2, %%0", 2 + operand_length (info->src) + operand_length (info->dst),
+                                 info->operands);
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make LSHIFTRT instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+void
+define_lshiftrt (struct insn_info *info)
+{
+  rtx ops[7];
+  int offset;
+
+  /* --- 32-bit operation --- */
+  if (GET_MODE (info->dst) == SImode)
+  {
+    ops[0] = info->operands[0];  /* Destination */
+    ops[1] = info->operands[1];  /* Source */
+    ops[2] = info->operands[2];  /* Shift count */
+    ops[3] = info->operands[3];  /* Scratch reg */
+    ops[4] = gen_rtx_REG (HImode, REGNO (info->operands[0]) + REGS_PER_WORD);  /* Low word of source */
+
+    /* Source is constant */
+    if (GET_CODE (info->src) == CONST_INT)
+    {
+      /* Constant shift */
+      offset = INTVAL (info->operands[2]);
+      ops[5] = GEN_INT (16 - offset);  /* Complement of shift count */
+      ops[6] = GEN_INT (offset % 16);  /* Modulo of shift count */
+
+      if (offset < 16)
+      {
+        if (offset == 8)
+        {
+          put_insn ("swpb %%1",      2, ops);  /* Swap bytes in low word */
+          put_insn ("swpb %%4",      2, ops);  /* Swap bytes in high word */
+          put_insn ("movb %%1, %%4", 2, ops);  /* Move MSB of high word */
+          put_insn ("sb   %%1, %%1", 2, ops);  /* Clear MSB of high word */
+        }
+        else
+        {
+          put_insn ("mov  %%1, %%3", 2, ops);  /* Save high word to temp */
+          put_insn ("srl  %%1, %%6", 2, ops);  /* Shift high word */
+          put_insn ("srl  %%4, %%6", 2, ops);  /* Shift low word */
+          put_insn ("sla  %%3, %%5", 2, ops);  /* Shift high word bits into low word position */
+          put_insn ("soc  %%3, %%4", 2, ops);  /* Merge shifted high word bits into low word */
+        }
+      }
+      else
+      {
+        if (offset > 16)
+        {
+          put_insn ("srl  %%1, %%6", 2, ops);  /* Shift high word */
+        }
+        put_insn ("mov  %%1, %%4", 2, ops);  /* Copy high word to low word */
+        put_insn ("clr  %%1",      2, ops);  /* Clear high word */
+      }
+    }
+    else
+    {
+      /* Variable shift */
+      put_insn ("ci   %%2, 16",  4, ops);  /* +0: Compare shift to 16 */
+      put_insn ("jlt  $+12",     2, ops);  /* +4: If shift was < 16, goto lt_16 */
+      put_insn ("jeq  $+4",      2, ops);  /* +6: If shift was 16, goto eq_16 */
+
+      /* Shift count greater than 16 */
+      put_insn ("srl  %%1, %%2", 2, ops);  /* +8: Shift high word */
+
+      /* eq_16: Shift count equals 16 */
+      put_insn ("mov  %%1, %%4", 2, ops);  /* +10: Copy high word to low word */
+      put_insn ("clr  %%1",      2, ops);  /* +12: Clear high word */
+      put_insn ("jmp  $+20",     2, ops);  /* +14: Goto end */
+
+      /* lt_16: Shift count less than 16 */
+      put_insn ("abs  %%2",      2, ops);  /* +16: Test shift count */
+      put_insn ("jeq  $+16",     2, ops);  /* +18: If shift==0, goto end */
+      put_insn ("mov  %%1, %%3", 2, ops);  /* +20: Save high word to temp */
+      put_insn ("srl  %%1, %%2", 2, ops);  /* +22: Shift high word */
+      put_insn ("srl  %%4, %%2", 2, ops);  /* +24: Shift low word */
+      put_insn ("neg  %%2",      2, ops);  /* +26: Get complement of shift count */
+      put_insn ("sla  %%3, %%2", 2, ops);  /* +28: Shift high word bits into low word position */
+      put_insn ("soc  %%3, %%4", 2, ops);  /* +30: Merge shifted high word bits into low word */
+      put_insn ("neg  %%2",      2, ops);  /* +32: Restore shift count */
+      /* +34: End */
+    }
+  }
+
+  /* --- 8-bit and 16-bit operation --- */
+  else
+  {
+    if (GET_MODE (info->dst) == QImode)
+    {
+      put_insn ("andi %%0, >FF00", 4, info->operands);
+    }
+
+    if (REG_P (info->src))
+    {
+      put_insn ("abs  r0"      , 2, info->operands);
+      put_insn ("jeq  $+8"     , 2, info->operands);  /* If shift count is zero, do nothing */
+      put_insn ("srl  %%0, 0"  , 2, info->operands);
+    }
+    else
+    {
+      put_reg_shift (LSHIFTRT, info->dst, INTVAL (info->src), 0);
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make MINUS instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_minus (struct insn_info *info)
+{
+  int intval;
+  int len;
+  rtx const_value;
+
+  /* --- 32-bit operation --- */
+  if (GET_MODE (info->dst) == SImode)
+  {
+    struct insn_info subinfo;
+
+    /* Add high words */
+    subinfo.src = si_highpart (info->src);
+    subinfo.dst = si_highpart (info->dst);
+    define_minus (&subinfo);
+
+    /* Add low words */
+    subinfo.src = si_lowpart (info->src);
+    subinfo.dst = si_lowpart (info->dst);
+    define_minus (&subinfo);
+
+    /* Handle borrow */
+    if (!CONST_INT_P (subinfo.src) ||
+        (INTVAL (subinfo.src) != 0))
+    {
+      subinfo.dst = si_highpart (info->dst);
+      len = operand_length (subinfo.dst);
+      put_insn ("jnc  $+%d", 2, info->operands, 2 + len);
+      put_insn ("inc  %s", 2 + len, info->operands, sprint_operand (subinfo.dst));
+    }
+  }
+
+  /* --- 16-bit operation --- */
+  else if (GET_MODE (info->dst) == HImode)
+  {
+    char *dst_name = sprint_operand (info->dst);
+    if (GET_CODE (info->src) == CONST_INT)
+    {
+      intval = INTVAL (info->src);
+      len = operand_length (info->src);
+      if (intval == -1)
+        put_insn ("inc  %s", 2 + len, info->operands, dst_name);
+      else if (intval == -2)
+        put_insn ("inct %s", 2 + len, info->operands, dst_name);
+      else if (intval == 1)
+        put_insn ("dec  %s", 2 + len, info->operands, dst_name);
+      else if (intval == 2)
+        put_insn ("dect %s", 2 + len, info->operands, dst_name);
+      else if (REG_P (info->dst))
+        put_insn ("ai   %s, >%x", 2 + 2, info->operands, dst_name, ((-intval) & 0xffff));
+      else
+      {
+        const_value = add_block_constant (GEN_INT (intval & 0xffff), HImode);
+        put_insn ("s    %s, %s", 2 + operand_length (const_value) + operand_length (info->dst),
+                                 info->operands,
+                                 sprint_operand (const_value), dst_name);
+      }
+    }
+    else
+    {
+      put_insn ("s    %s, %s", 2 + operand_length (info->src) + operand_length (info->dst),
+                               info->operands,
+                               sprint_operand (info->src), dst_name);
+    }
+  }
+
+  /* --- 8-bit operation --- */
+  else if (GET_MODE (info->dst) == QImode)
+  {
+    if (GET_CODE (info->src) == CONST_INT)
+    {
+      intval = INTVAL (info->src);
+      if (REG_P (info->dst))
+      {
+        put_insn ("ai   %%0, >%x", 2 + 2,
+                                   info->operands,
+                                   ((-intval) & 0xff) * 0x100);
+      }
+      else
+      {
+        const_value = add_block_constant (GEN_INT (intval & 0xff), QImode);
+        put_insn ("sb   %s, %%0", 2 + operand_length (const_value) + operand_length (info->dst),
+                                   info->operands,
+                                  sprint_operand (const_value));
+      }
+    }
+    else
+    {
+      put_insn ("sb   %%2, %%0", 2 + operand_length (info->src) + operand_length (info->dst),
+                                 info->operands);
+
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make MULT instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_mult (struct insn_info *info)
+{
+  rtx ops[6];
+
+  /* --- 32-bit operation --- */
+  if (GET_MODE (info->src) == SImode)
+  {
+    ops[0] = info->operands[0];  /* Destination R */
+    ops[1] = gen_lowpart_SUBREG (HImode, info->operands[0]);
+    ops[2] = info->operands[2];  /* Source G */
+    ops[4] = info->operands[3];  /* Temp */
+    ops[5] = info->operands[4];  /* Hold */
+
+    if (REG_P (info->operands[2]))
+    {
+      ops[3] = gen_lowpart_SUBREG (HImode, info->operands[2]);
+    }
+    else
+    {
+      ops[3] = adjust_address (info->operands[2], HImode, 2);
+    }
+
+    /* Since we only have a 16-bit multiply, we need to expand this math.
+       We can omit the R0*G0 term since it won't fit into 32 bits
+
+          (R0*N+R1)*(G0*N+G1) = R0*G0*N*N + R0*G1*N + R1*G0*N + R1*G1
+    */
+    put_insn ("mov  %%1, %%5", 2, ops);  /* H = R1          */
+    put_insn ("mpy  %%3, %%0", 2, ops);  /* [R0,R1] = R0*G1 */
+    put_insn ("mov  %%1, %%4", 2, ops);  /* T = LSW(R0*G1)  */
+    put_insn ("mov  %%5, %%0", 2, ops);  /* R0 = H          */
+    put_insn ("mpy  %%2, %%0", 2, ops);  /* [R0,R1] = R1*G0 */
+    put_insn ("a    %%1, %%4", 2, ops);  /* T += LSW(R1*G0) */
+    put_insn ("mov  %%5, %%0", 2, ops);  /* R0 = H          */
+    put_insn ("mpy  %%3, %%0", 2, ops);  /* [R0,R1] = R1*G1 */
+    put_insn ("a    %%4, %%0", 2, ops);  /* R0 += T         */
+  }
+
+  /* --- 16-bit operation --- */
+  else
+  {
+    if (REGNO (info->dst) == REGNO (info->dst_pre))
+    {
+      /* Arguments are in the proper location */
+      put_insn ("mpy  %%2, %%0", 2 + operand_length (info->src),
+                                 info->operands);
+    }
+    else
+    {
+      if ((!REG_P (info->src)) ||
+         (REGNO (info->src) != REGNO (info->dst)))
+      {
+        /* Move arguments so we can use them */
+        put_insn ("mov  %%2, %%0", 2 + operand_length (info->src),
+                                   info->operands);
+      }
+      put_insn ("mpy  %%1, %%0", 2, info->operands);
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make NEG instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_neg (struct insn_info *info)
+{
+  int dst_length = operand_length (info->dst);
+  char *high_name;
+  char *low_name;
+
+  /* --- 32-bit operation --- */
+  if (GET_MODE (info->dst) == SImode)
+  {
+    high_name = sprint_operand (si_highpart (info->dst));
+    low_name = sprint_operand (si_lowpart (info->dst));
+    put_insn ("inv  %s", 2 + dst_length, info->operands, high_name);
+    put_insn ("neg  %s", 2 + dst_length, info->operands, low_name);
+    put_insn ("jnc  $+>%x", 2, info->operands, 4 + dst_length);
+    put_insn ("inc  %s", 2 + dst_length, info->operands, high_name);
+  }
+
+  /* --- 16-bit operation --- */
+  else if (GET_MODE (info->dst) == HImode)
+  {
+    put_insn ("neg  %%0", 2 + dst_length, info->operands);
+  }
+
+  /* --- 8-bit operation --- */
+  else if (GET_MODE (info->dst) == QImode)
+  {
+    if (REG_P (info->dst))
+    {
+      put_insn ("andi %%0, >ff00", 4, info->operands);
+      put_insn ("neg  %%0", 2, info->operands);
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make NOT instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_not (struct insn_info *info)
+{
+  put_insn ("inv  %%0", 2 + operand_length (info->dst), info->operands);
+}
+
+
+/*=============================================================================
+  Make PLUS instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_plus (struct insn_info *info)
+{
+  int intval;
+  int dst_len;
+  int src_len;
+  rtx dst;
+  rtx src;
+  rtx const_value;
+  rtx temp;
+  rtx suboperands[3];
+  struct insn_info subinfo;
+
+  if (!rtx_equal_p (info->operands[0], info->operands[1]))
+  {
+    /* Operands are not in proper position, we need to handle two cases:
+           Case A: r1 = r2 + r1
+           Case B: r1 = r2 + r3
+    */
+    if (rtx_equal_p (info->operands[0], info->operands[2]))
+    {
+      /* Handle case A, swap arguments */
+      temp = info->operands[1];
+      info->operands[1] = info->operands[2];
+      info->operands[2] = temp;
+    }
+    else
+    {
+      /* Handle case B, initialize destination */
+      dst_len = operand_length (info->operands[0]);
+      src_len = operand_length (info->operands[1]);
+
+      if (GET_MODE (info->operands[0]) == SImode)
+      {
+        dst = si_highpart (info->operands[0]);
+        src = si_highpart (info->operands[1]);
+        put_insn ("mov  %s, %s", 2 + dst_len + src_len, info->operands, 
+                                 sprint_operand (src), sprint_operand (dst));
+        dst = si_lowpart (info->operands[0]);
+        src = si_lowpart (info->operands[1]);
+        put_insn ("mov  %s, %s", 2 + dst_len + src_len, info->operands,
+                                 sprint_operand (src), sprint_operand (dst));
+      }
+      if (GET_MODE (info->operands[0]) == HImode)
+      {
+        put_insn ("mov  %%1, %%0", 2 + dst_len + src_len, info->operands);
+      }
+      if (GET_MODE (info->operands[0]) == QImode)
+      {
+        put_insn ("movb %%1, %%0", 2 + dst_len + src_len, info->operands);
+      }
+
+      info->operands[1] = info->operands[0];
+    }
+  }
+
+  dst = info->operands[0];
+  src = info->operands[2];
+  dst_len = operand_length (dst);
+  src_len = operand_length (src);
+
+  /* --- 32-bit operation --- */
+  if (GET_MODE (dst) == SImode)
+  {
+
+    /* Add high words */
+    suboperands[0] = si_highpart (dst);
+    suboperands[1] = suboperands[0];
+    suboperands[2] = si_highpart (src);
+    subinfo.operands = &suboperands[0];
+    subinfo.insn = info->insn;
+    define_plus (&subinfo);
+
+    /* Add low words */
+    suboperands[0] = si_lowpart (dst);
+    suboperands[1] = suboperands[0];
+    suboperands[2] = si_lowpart (src);
+    subinfo.operands = &suboperands[0];
+    subinfo.insn = info->insn;
+    define_plus (&subinfo);
+
+    /* Handle carry */
+    src = subinfo.operands[2];
+    if (!CONST_INT_P (src) ||
+        (INTVAL (src) != 0))
+    {
+      dst = si_highpart (dst);
+      dst_len = operand_length (dst);
+      put_insn ("jnc  $+%d", 2, info->operands, 2 + dst_len);
+      put_insn ("inc  %s", 2 + dst_len, info->operands, sprint_operand (dst));
+    }
+  }
+
+  /* --- 16-bit operation --- */
+  else if (GET_MODE (dst) == HImode)
+  {
+    if (GET_CODE (src) == CONST_INT)
+    {
+      intval = (INTVAL (src) & 0xffff);
+      if (intval != 0)
+      {
+        if (intval == 1)
+          put_insn ("inc  %%0", 2 + dst_len, info->operands);
+        else if (intval == 2)
+          put_insn ("inct %%0", 2 + dst_len, info->operands);
+        else if (intval == 0xffff)
+          put_insn ("dec  %%0", 2 + dst_len, info->operands);
+        else if (intval == 0xfffe)
+          put_insn ("dect %%0", 2 + dst_len, info->operands);
+        else if (REG_P (dst))
+          put_insn ("ai   %%0, >%x", 2 + dst_len + src_len, info->operands, intval);
+        else
+        {
+          const_value = add_block_constant (GEN_INT (intval), HImode);
+          put_insn ("a    %s, %%0", 2 + dst_len + src_len, info->operands,
+                                   sprint_operand (const_value));
+        }
+      }
+    }
+
+    else if (GET_RTX_CLASS (GET_CODE (src)) == RTX_CONST_OBJ)
+    {
+      put_insn ("ai   %%0, %%2", 2 + dst_len + src_len, info->operands);
+    }
+    else
+    {
+      put_insn ("a    %%2, %%0", 2 + dst_len + src_len, info->operands);
+    }
+  }
+
+  /* --- 8-bit operation --- */
+  else if (GET_MODE (dst) == QImode)
+  {
+    if (GET_CODE (src) == CONST_INT)
+    {
+      intval = INTVAL (src);
+      if (intval != 0)
+      {
+        if (REG_P (dst))
+        {
+          put_insn ("ai   %%0, >%x", 2 + 2,
+                                     info->operands,
+                                     ((INTVAL (src) * 0x100) & 0xffff));
+        }
+        else
+        {
+          const_value = add_block_constant (GEN_INT (intval & 0xff), QImode);
+          put_insn ("ab   %s, %%0", 2 + operand_length (const_value) + operand_length (dst),
+                                    info->operands,
+                                    sprint_operand (const_value));
+        }
+      }
+    }
+    else
+    {
+      put_insn ("ab   %%2, %%0", 2 + operand_length (src) + operand_length (dst),
+                                 info->operands);
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make RETURN instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_return (struct insn_info *info)
+{
+  /* Output return instruction */
+  put_insn ("b    *r11", 2, NULL);
+}
+
+
+/*=============================================================================
+  Make ROTATERT instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_rotatert (struct insn_info *info)
+{
+  put_insn ("src  %%0, %%2", 2, info->operands);
+}
+
+
+/*=============================================================================
+  Make SET instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_set (struct insn_info *info)
+{
+  int i;
+  int intval;
+  int op_len;
+  char *regname;
+  rtx low_word[2];
+  rtx const_value;
+  int length_src;
+  int length_dst;
+  int define_done;
+
+  op_len = operand_length (info->src) + operand_length (info->dst);
+
+  /* --- 32-bit operation --- */
+  if (GET_MODE (info->dst) == SImode)
+  {
+    struct insn_info subinfo_low;
+    struct insn_info subinfo_high;
+    subinfo_low.src = si_lowpart (info->src);
+    subinfo_low.dst = si_lowpart (info->dst);
+    subinfo_high.src = si_highpart (info->src);
+    subinfo_high.dst = si_highpart (info->dst);
+
+    if (rtx_equal_p (subinfo_low.src, subinfo_high.dst))
+    {
+      /* Backwards copy */
+      define_set (&subinfo_low);
+      define_set (&subinfo_high);
+    }
+    else
+    {
+      /* Forwards copy */
+      define_set (&subinfo_high);
+      define_set (&subinfo_low);
+    }
+  }
+
+  /* --- 16-bit operation --- */
+  else if (GET_MODE (info->dst) == HImode)
+  {
+    char *dst_name = sprint_operand (info->dst);
+    int dst_length = operand_length (info->dst);
+
+    /* Set from constant */
+    define_done = 0;
+    if (CONSTANT_ADDRESS_P (info->src))
+    {
+      /* Optimizations for special constant values */
+      if (GET_CODE (info->src) == CONST_INT)
+      {
+        define_done = 1;
+        intval = (INTVAL (info->src) & 0xffff);
+        if (intval == 0)
+          put_insn ("clr  %s", 2 + dst_length, NULL, dst_name);
+        else if (intval == 0xffff)
+          put_insn ("seto %s", 2 + dst_length, NULL, dst_name);
+        else
+          define_done = 0;
+      }
+
+      /* Handle all other constant values */
+      if (define_done == 0)
+      {
+        if (REG_P (info->dst))
+        {
+          put_insn ("li   %s, %s", 4, NULL, dst_name, sprint_operand (info->src));
+        }
+        else
+        {
+          const_value = add_block_constant (info->src, HImode);
+          put_insn ("mov  %s, %s", 2 + operand_length (const_value) + dst_length,
+                                   NULL,
+                                   sprint_operand (const_value), dst_name);
+        }
+      }
+    }
+
+    /* Set from register or memory */
+    else
+    {
+      put_insn ("mov  %s, %s", 2 + op_len, NULL, sprint_operand (info->src), dst_name);
+    }
+  }
+
+  /* --- 8-bit operation --- */
+  else if (GET_MODE (info->dst) == QImode)
+  {
+    /* Set from constant */
+    if (GET_CODE (info->src) == CONST_INT)
+    {
+      intval = (INTVAL (info->src) & 0xffff);
+      if (REG_P (info->dst))
+      {
+        /* Set register */
+        if (intval == 0)
+          put_insn ("clr  %%0", 2, info->operands);
+        else if ((intval & 0xff) == 0xff)
+          put_insn ("seto %%0", 2, info->operands);
+        else if (REG_P (info->dst))
+        {
+          put_insn ("li   %%0, >%x", 4, info->operands, ((intval * 0x100) & 0xffff));
+        }
+      }
+      else
+      {
+        /* Set memory */
+        const_value = add_block_constant (GEN_INT (intval), QImode);
+        put_insn ("movb %s, %%0", 2 + operand_length (const_value) + operand_length (info->dst),
+                                  info->operands,
+                                  sprint_operand (const_value));
+      }
+    }
+    /* Set from register or memory */
+    else
+    {
+      put_insn ("movb %%1, %%0", 2 + op_len, info->operands);
+    }
+  }
+}
+
+
+/*=============================================================================
+  Make SIGN EXTEND instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_sextend (struct insn_info *info)
+{
+  /* Not much to do here, just perform a copy if needed */
+  if (REGNO (info->src) != REGNO (info->dst))
+  {
+    put_insn ("mov  %1, %0", 2 + operand_length (info->src) + operand_length (info->dst),
+                             info->operands);
+  }
+}
+
+
+/*=============================================================================
+  Make UDIV instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_udiv (struct insn_info *info)
+{
+  rtx x;
+  int use_mod = 1;
+
+  /* Determine if one of the outputs is not used */
+  for (x = REG_NOTES (info->insn); x; x = XEXP (x, 1))
+  {
+    if (REG_NOTE_KIND (x) == REG_DEAD || REG_NOTE_KIND (x) == REG_UNUSED)
+    {
+      rtx note = XEXP (x, 0);
+      if (REG_P (note))
+      {
+        if (REGNO (note) == REGNO (info->dst_two)) use_mod = 0;
+      }
+    }
+  }
+
+  put_insn ("div  %%2, %%0", 2 + operand_length (info->src), info->operands);
+  if (use_mod)
+  {
+    put_insn ("mov  %s, %%3", 2 + operand_length (info->dst_two), info->operands, reg_names[REGNO(info->dst)+1]);
+  }
+}
+
+
+/*=============================================================================
+  Make XOR instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_xor (struct insn_info *info)
+{
+  put_insn ("xor  %%2, %%0", 2 + operand_length (info->src) + operand_length (info->dst),
+                             info->operands);
+}
+
+
+/*=============================================================================
+  Make ZERO EXTEND instructions
+
+  Inputs : info - Record describing current instruction
+
+  Returns: None
+=============================================================================*/
+static void
+define_zextend (struct insn_info *info)
+{
+  /* Not much to do here, just perform a copy if needed */
+  if (REGNO (info->src) != REGNO (info->dst))
+  {
+    put_insn ("mov  %1, %0", 2 + operand_length (info->src) + operand_length (info->dst),
+                             info->operands);
+  }
+}
+
+
+/*=============================================================================
+  Main body for defining instructions
+
+  Inputs : insn     - RTX record for instruction
+           operands - List of RTX records for instruction operands
+           code     - RTL code for instruction
+
+  Returns: Number of bytes needed for instruction
+=============================================================================*/
+int
+tms9900_insn_info (rtx_insn *insn, rtx *operands, int code)
+{
+  typedef void (*insn_func) (struct insn_info *info);
+
+  /* Record usqed for instruction handler table */
+  struct insn_rec
+  {
+    int code;
+    insn_func func;
+    int dst;
+    int src;
+    int dst_pre;
+    int dst_two;
+  };
+
+  static rtx ops[4];
+  static struct insn_rec insn_list[] =
+  {
+    /* Code       Function         Dst  Src  Pre  Two
+       ---------  ---------------  ---  ---  ---  ---*/
+    {ABS,         define_abs,      0,   999, 1,   999},
+    {AND,         define_and,      0,   2,   1,   3  },
+    {-AND,        define_and,      0,   2,   1,   999},
+    {ASHIFT,      define_ashift,   0,   2,   1,   999},
+    {ASHIFTRT,    define_ashiftrt, 0,   2,   1,   999},
+    {CALL,        define_call,     1,   999, 999, 999},
+    {-CALL,       define_call,     0,   999, 999, 999},
+    {COMPARE,     define_compare,  0,   1,   999, 999},
+    {DIV,         define_div,      0,   2,   1,   3  },
+    {EQ,          define_branch,   999, 999, 999, 999},
+    {IOR,         define_ior,      0,   2,   1,   999},
+    {LSHIFTRT,    define_lshiftrt, 0,   2,   1,   999},
+    {MINUS,       define_minus,    0,   2,   1,   999},
+    {MULT,        define_mult,     0,   2,   1,   999},
+    {NEG,         define_neg,      0,   999, 1,   999},
+    {NOT,         define_not,      0,   999, 1,   999},
+    {PLUS,        define_plus,     0,   2,   1,   999},
+    {RETURN,      define_return,   999, 999, 999, 999},
+    {ROTATERT,    define_rotatert, 0,   2,   1,   999},
+    {SET,         define_set,      0,   1,   999, 999},
+    {SIGN_EXTEND, define_sextend,  0,   1,   999, 999},
+    {UDIV,        define_udiv,     0,   2,   1,   3  },
+    {XOR,         define_xor,      0,   2,   1,   999},
+    {ZERO_EXTEND, define_zextend,  0,   1,   999, 999},
+    {0}
+  };
+
+  struct insn_rec *irec;
+  struct insn_info info = {};
+  int byte_length = 0;
+
+  memcpy (ops, operands, sizeof (ops));
+  for (irec = &insn_list[0]; irec->code != 0; irec++)
+  {
+    if (irec->code == code)
+    {
+      /* Found match */
+      info.code = code;
+      info.insn = insn;
+      info.operands = operands;
+
+      if (irec->dst     < 4) info.dst     = operands[irec->dst];
+      if (irec->src     < 4) info.src     = operands[irec->src];
+      if (irec->dst_pre < 4) info.dst_pre = operands[irec->dst_pre];
+      if (irec->dst_two < 4) info.dst_two = operands[irec->dst_two];
+
+      /* Handle instruction */
+      put_insn_start (&byte_length);
+      fixup_pre_all (&info);
+      (*irec->func) (&info);
+      fixup_post (&info);
+
+      break;
+    }
+  }
+
+  update_reg_info (&info);
+  return (byte_length);
+}
+
+
+/*=============================================================================
+===============================================================================
+
+                         Code used for target macros
+
+===============================================================================
+=============================================================================*/
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_ASCII (STREAM, PTR, LEN)
+     A C statement to output to the stdio stream STREAM an assembler
+     instruction to assemble a string constant containing the LEN bytes
+     at PTR.  PTR will be a C expression of type 'char *' and LEN a C
+     expression of type 'int'.
+=============================================================================*/
+void
+tms9900_output_ascii (FILE* stream,
+                      const char* ptr,
+                      int len)
+{
+  int i;
+  int in_text = 0;
+  for (i = 0; i < len; i++)
+  {
+    int c = *ptr++;
+    if (ISPRINT(c))
+    {
+      /* Start TEXT statement */
+      if (in_text == 0)
+      {
+        fprintf (stream, "\ttext '");
+        in_text = 1;
+      }
+      putc (c, stream);
+      if (c == '\'')
+      {
+        putc (c, stream);
+      }
+    }
+    else
+    {
+      /* Close TEXT statement */
+      if (in_text == 1)
+      {
+        fprintf (stream, "'\n");
+        in_text = 0;
+      }
+      /* Handle non-printable characters by inlining BYTE constants*/
+      fprintf (stream, "\tbyte\t%d\n", (unsigned char)c);
+    }
+  }
+
+  /* Close TEXT statement if needed */
+  if (in_text == 1)
+  {
+    fprintf (stream, "'\n");
+  }
+}
+
+
+/*=============================================================================
+ -- Macro: CONSTANT_ADDRESS_P (X)
+     A C expression that is 1 if the RTX X is a constant which is a
+     valid address.
+=============================================================================*/
+int
+tms9900_constant_address_p (rtx x)
+{
+  enum rtx_code code = GET_CODE (x);
+  int ret = 0;
+
+  if ((code == CONST) ||
+      (code == CONST_INT) ||
+      (code == CODE_LABEL) ||
+      (code == SYMBOL_REF))
+  {
+    ret = true;
+  }
+
+  else if (code == PLUS)
+  {
+    ret = (tms9900_constant_address_p (XEXP (x, 0)) &&
+           tms9900_constant_address_p (XEXP (x, 1)));
+  }
+
+  return (ret);
+}
+
+
+/*=============================================================================
+ -- Macro: INIT_CUMULATIVE_ARGS (CUM, FNTYPE, LIBNAME, FNDECL,
+          N_NAMED_ARGS)
+     A C statement (sans semicolon) for initializing the variable CUM
+     for the state at the beginning of the argument list.  The variable
+     has type 'CUMULATIVE_ARGS'.  The value of FNTYPE is the tree node
+     for the data type of the function which will receive the args, or 0
+     if the args are to a compiler support library function.  For direct
+     calls that are not libcalls, FNDECL contain the declaration node of
+     the function.  FNDECL is also set when 'INIT_CUMULATIVE_ARGS' is
+     used to find arguments for the function being compiled.
+     N_NAMED_ARGS is set to the number of named arguments, including a
+     structure return address if it is passed as a parameter, when
+     making a call.  When processing incoming arguments, N_NAMED_ARGS is
+     set to -1.
+
+     When processing a call to a compiler support library function,
+     LIBNAME identifies which one.  It is a 'symbol_ref' rtx which
+     contains the name of the function, as a string.  LIBNAME is 0 when
+     an ordinary C function call is being processed.  Thus, each time
+     this macro is called, either LIBNAME or FNTYPE is nonzero, but
+     never both of them at once.
+=============================================================================*/
+void
+tms9900_init_cumulative_args (CUMULATIVE_ARGS *pca)
+{
+  /* Varargs vectors are treated the same as long long. Using
+     named_count avoids having to change the way 'named' is handled */
+  pca->named_count = 0;
+  pca->nregs = 0;
+}
+
+
+/*=============================================================================
+ -- Macro: INITIAL_ELIMINATION_OFFSET (FROM-REG, TO-REG, OFFSET-VAR)
+     This macro returns the initial difference between the specified
+     pair of registers.  The value would be computed from information
+     such as the result of 'get_frame_size ()' and the tables of
+     registers 'df_regs_ever_live_p' and 'call_used_regs'.
+=============================================================================*/
+int
+tms9900_initial_elimination_offset (int from,
+                                    int to)
+{
+  /*  Stack Layout:
+   *  --------------
+   *    [Arguments]
+   *    . <- Arg Pointer (Old Stack Pointer)
+   *    [Saved Regs]
+   *    [Locals]
+   *    . <- Frame Pointer
+   *    [Outgoing Arguments]
+   *    . <- stack pointer
+   */
+
+  int locals_size = get_frame_size ().to_constant ();
+  int regs_size = tms9900_get_saved_reg_size ();
+  int args_size = crtl->outgoing_args_size.to_constant ();
+
+  if ((from == ARG_POINTER_REGNUM) && (to == HARD_SP_REGNUM))
+  {
+    return (regs_size + locals_size + args_size);
+  }
+
+  if ((from == FRAME_POINTER_REGNUM) && (to == HARD_SP_REGNUM))
+  {
+    return (args_size);
+  }
+
+  if ((from == ARG_POINTER_REGNUM) && (to == FRAME_POINTER_REGNUM))
+  {
+    return (regs_size + locals_size);
+  }
+
+  return (0);
+}
+
+
+/*=============================================================================
+ -- Target Hook: int TARGET_ADDRESS_COST (rtx ADDRESS, machine_mode
+          MODE, addr_space_t AS, bool SPEED)
+   Return cost of accessing the supplied operand.  Registers are free.
+   Anything else starts with a cost of two.  Add to that for memory
+   references the memory accesses of the addressing mode (if any) plus
+   the data reference; for other operands just the memory access (if
+   any) for the mode.
+=============================================================================*/
+int
+tms9900_address_cost (rtx addr, machine_mode mode ATTRIBUTE_UNUSED, addr_space_t as ATTRIBUTE_UNUSED,
+                      bool speed ATTRIBUTE_UNUSED)
+{
+  int cost = 2;
+
+  if (GET_CODE (addr) != REG)
+  {
+    cost += 2;
+  }
+
+  return cost;
+}
+
+
+/*=============================================================================
+ -- Target Hook: bool TARGET_ASM_INTEGER (rtx X, unsigned int SIZE, int
+          ALIGNED_P)
+     The 'assemble_integer' function uses this hook to output an integer
+     object.  X is the object's value, SIZE is its size in bytes and
+     ALIGNED_P indicates whether it is aligned.  The function should
+     return 'true' if it was able to output the object.  If it returns
+     false, 'assemble_integer' will try to split the object into smaller
+     parts.
+=============================================================================*/
+#undef  TARGET_ASM_INTEGER
+#define TARGET_ASM_INTEGER tms9900_asm_integer
+
+bool
+tms9900_asm_integer (rtx x,
+                     unsigned int size,
+                     int aligned_p)
+{
+  unsigned int value;
+  int i;
+
+  if (!aligned_p)
+  {
+    if (GET_CODE (x) == CONST_INT)
+    {
+      value = INTVAL (x);
+      fprintf (asm_out_file, "\tbyte\t");
+      for (i = size - 1; i >= 1; i--)
+      {
+        fprintf (asm_out_file, "0x%x,", (value >> (i*8)) & 0xff);
+      }
+      fprintf (asm_out_file, "0x%x", value & 0xff);
+      return true;
+    }
+  }
+  return default_assemble_integer (x,size,1);
+}
+
+
+/*=============================================================================
+ -- Target Hook: void TARGET_ASM_FUNCTION_EPILOGUE (FILE *FILE)
+     If defined, a function that outputs the assembler code for exit
+     from a function.  The epilogue is responsible for restoring the
+     saved registers and stack pointer to their values when the function
+     was called, and returning control to the caller.  This macro takes
+     the same argument as the macro 'TARGET_ASM_FUNCTION_PROLOGUE', and
+     the registers to restore are determined from 'regs_ever_live' and
+     'CALL_USED_REGISTERS' in the same way.
+=============================================================================*/
+#undef TARGET_ASM_FUNCTION_EPILOGUE
+#define TARGET_ASM_FUNCTION_EPILOGUE tms9900_asm_function_epilogue
+
+void
+tms9900_asm_function_epilogue (FILE *out_file)
+{
+  FILE *old_out_file;
+  struct const_block *cblock;
+  int data_idx;
+  int size;
+  int mask;
+  int regs_size = tms9900_get_saved_reg_size ();
+
+  /* Set new asm file */
+  old_out_file = asm_out_file;
+  asm_out_file = out_file;
+
+  /* Iterate over constant blocks for this function */
+  for (cblock = &const_block_list[0];
+       cblock < &const_block_list[sizeof (const_block_list) / sizeof (const_block_list[0])];
+       cblock++)
+  {
+    /* Emit block data */
+    if ((cblock->label != NULL) &&
+        (GET_CODE (cblock->label) == CODE_LABEL))
+    {
+      size = GET_MODE_SIZE (cblock->mode).to_constant();
+      mask = (1 << (8 * size)) - 1;
+      put_label (cblock->label);
+      fprintf (asm_out_file, "\n");
+
+      /* Emit values in this block */
+      for (data_idx = 0; data_idx < cblock->end; data_idx++)
+      {
+        fprintf(asm_out_file, "\t%s ", cblock->name);
+        rtx value = cblock->data[data_idx];
+        if (GET_CODE (value) == CONST_INT)
+          fprintf (asm_out_file, ">%x", (INTVAL (value) & mask));
+        else
+          tms9900_print_operand (asm_out_file, cblock->data[data_idx], 0);
+        fprintf(asm_out_file, "\n");
+      }
+      fprintf(asm_out_file, "\teven\n");
+    }
+    cblock->label = NULL;
+  }
+
+  asm_out_file = old_out_file;
+}
+
+
+/*=============================================================================
+ -- Target Hook: rtx TARGET_FUNCTION_ARG (cumulative_args_t CA, const
+          function_arg_info &ARG)
+     Return an RTX indicating whether function argument ARG is passed in
+     a register and if so, which register.  Argument CA summarizes all
+     the previous arguments.
+
+     The return value is usually either a 'reg' RTX for the hard
+     register in which to pass the argument, or zero to pass the
+     argument on the stack.
+
+     The value of the expression can also be a 'parallel' RTX.  This is
+     used when an argument is passed in multiple locations.  The mode of
+     the 'parallel' should be the mode of the entire argument.  The
+     'parallel' holds any number of 'expr_list' pairs; each one
+     describes where part of the argument is passed.  In each
+     'expr_list' the first operand must be a 'reg' RTX for the hard
+     register in which to pass this part of the argument, and the mode
+     of the register RTX indicates how large this part of the argument
+     is.  The second operand of the 'expr_list' is a 'const_int' which
+     gives the offset in bytes into the entire argument of where this
+     part starts.  As a special exception the first 'expr_list' in the
+     'parallel' RTX may have a first operand of zero.  This indicates
+     that the entire argument is also stored on the stack.
+
+     The last time this hook is called, it is called with 'MODE ==
+     VOIDmode', and its result is passed to the 'call' or 'call_value'
+     pattern as operands 2 and 3 respectively.
+
+     The usual way to make the ISO library 'stdarg.h' work on a machine
+     where some arguments are usually passed in registers, is to cause
+     nameless arguments to be passed on the stack instead.  This is done
+     by making 'TARGET_FUNCTION_ARG' return 0 whenever NAMED is 'false'.
+
+     You may use the hook 'targetm.calls.must_pass_in_stack' in the
+     definition of this macro to determine if this argument is of a type
+     that must be passed in the stack.  If 'REG_PARM_STACK_SPACE' is not
+     defined and 'TARGET_FUNCTION_ARG' returns nonzero for such an
+     argument, the compiler will abort.  If 'REG_PARM_STACK_SPACE' is
+     defined, the argument will be computed in the stack and then loaded
+     into a register.
+=============================================================================*/
+#undef  TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG tms9900_function_arg
+
+rtx
+tms9900_function_arg (cumulative_args_t ca,
+                      const function_arg_info &arg)
+{
+  CUMULATIVE_ARGS *pca = get_cumulative_args (ca);
+  int mode_size = GET_MODE_SIZE (arg.mode).to_constant ();
+
+  if (arg.mode == VOIDmode)
+  {
+    /* Pick an arbitrary value for operand 2 of the call insn.  */
+    return const0_rtx;
+  }
+
+  if (/* Vararg argument, must live on stack */
+      !arg.named ||
+      /* No more argument registers left */
+      pca->nregs >= TMS9900_ARG_REGS ||
+      /* Argument doesn't completely fit in arg registers */
+      (mode_size + pca->nregs) > TMS9900_ARG_REGS)
+  {
+    return NULL_RTX;
+  }
+
+  /* Allocate registers for argument */
+  return gen_rtx_REG (arg.mode, pca->nregs + HARD_R1_REGNUM);
+}
+
+
+/*=============================================================================
+ -- Target Hook: void TARGET_FUNCTION_ARG_ADVANCE (cumulative_args_t CA,
+          const function_arg_info &ARG)
+     This hook updates the summarizer variable pointed to by CA to
+     advance past argument ARG in the argument list.  Once this is done,
+     the variable CUM is suitable for analyzing the _following_ argument
+     with 'TARGET_FUNCTION_ARG', etc.
+
+     This hook need not do anything if the argument in question was
+     passed on the stack.  The compiler knows how to track the amount of
+     stack space used for arguments without any special help.
+=============================================================================*/
+#undef  TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE tms9900_function_arg_advance
+
+void
+tms9900_function_arg_advance (cumulative_args_t ca,
+                              const function_arg_info &arg)
+{
+  int arg_bytes;
+  CUMULATIVE_ARGS *pca = get_cumulative_args (ca);
+
+  if (arg.mode == BLKmode)
+  {
+     /* Argument is a structured block */
+     arg_bytes = int_size_in_bytes (arg.type);
+  }
+  else
+  {
+     /* Argument is a single data record */
+     arg_bytes = GET_MODE_SIZE (arg.mode).to_constant ();
+  }
+  pca->nregs += ((arg_bytes + 1) / UNITS_PER_WORD) * REGS_PER_WORD;
+  return;
+}
+
+
+/*=============================================================================
+ -- Target Hook: pad_direction TARGET_FUNCTION_ARG_PADDING (machine_mode
+          MODE, const_tree TYPE)
+     This hook determines whether, and in which direction, to pad out an
+     argument of mode MODE and type TYPE.  It returns 'PAD_UPWARD' to
+     insert padding above the argument, 'PAD_DOWNWARD' to insert padding
+     below the argument, or 'PAD_NONE' to inhibit padding.
+
+     The _amount_ of padding is not controlled by this hook, but by
+     'TARGET_FUNCTION_ARG_ROUND_BOUNDARY'.  It is always just enough to
+     reach the next multiple of that boundary.
+
+     This hook has a default definition that is right for most systems.
+     For little-endian machines, the default is to pad upward.  For
+     big-endian machines, the default is to pad downward for an argument
+     of constant size shorter than an 'int', and upward otherwise.
+=============================================================================*/
+#undef  TARGET_FUNCTION_ARG_PADDING
+#define TARGET_FUNCTION_ARG_PADDING tms9900_function_arg_padding
+
+pad_direction
+tms9900_function_arg_padding (enum machine_mode mode,
+                              const_tree type)
+{
+  if (type != 0 && AGGREGATE_TYPE_P (type))
+  {
+    return PAD_UPWARD;
+  }
+
+  /* Fall back to the default. */
+  return default_function_arg_padding (mode, type);
+}
+
+
+/*=============================================================================
+ -- Target Hook: rtx TARGET_FUNCTION_VALUE (const_tree RET_TYPE,
+          const_tree FN_DECL_OR_TYPE, bool OUTGOING)
+
+     Define this to return an RTX representing the place where a
+     function returns or receives a value of data type RET_TYPE, a tree
+     node representing a data type.  FN_DECL_OR_TYPE is a tree node
+     representing 'FUNCTION_DECL' or 'FUNCTION_TYPE' of a function being
+     called.  If OUTGOING is false, the hook should compute the register
+     in which the caller will see the return value.  Otherwise, the hook
+     should return an RTX representing the place where a function
+     returns a value.
+
+     On many machines, only 'TYPE_MODE (RET_TYPE)' is relevant.
+     (Actually, on most machines, scalar values are returned in the same
+     place regardless of mode.)  The value of the expression is usually
+     a 'reg' RTX for the hard register where the return value is stored.
+     The value can also be a 'parallel' RTX, if the return value is in
+     multiple places.  See 'TARGET_FUNCTION_ARG' for an explanation of
+     the 'parallel' form.  Note that the callee will populate every
+     location specified in the 'parallel', but if the first element of
+     the 'parallel' contains the whole return value, callers will use
+     that element as the canonical location and ignore the others.  The
+     m68k port uses this type of 'parallel' to return pointers in both
+     '%a0' (the canonical location) and '%d0'.
+
+     If 'TARGET_PROMOTE_FUNCTION_RETURN' returns true, you must apply
+     the same promotion rules specified in 'PROMOTE_MODE' if VALTYPE is
+     a scalar type.
+
+     If the precise function being called is known, FUNC is a tree node
+     ('FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This
+     makes it possible to use a different value-returning convention for
+     specific functions when all their calls are known.
+
+     Some target machines have "register windows" so that the register
+     in which a function returns its value is not the same as the one in
+     which the caller sees the value.  For such machines, you should
+     return different RTX depending on OUTGOING.
+
+     'TARGET_FUNCTION_VALUE' is not used for return values with
+     aggregate data types, because these are returned in another way.
+     See 'TARGET_STRUCT_VALUE_RTX' and related macros, below.
+=============================================================================*/
+#undef  TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE tms9900_function_value
+
+rtx
+tms9900_function_value (const_tree valtype,
+                        const_tree func ATTRIBUTE_UNUSED,
+                        bool outgoing ATTRIBUTE_UNUSED)
+{
+  return gen_rtx_REG (TYPE_MODE (valtype), HARD_R1_REGNUM);
+}
+
+
+/*=============================================================================
+ -- Target Hook: bool TARGET_HARD_REGNO_MODE_OK (unsigned int REGNO,
+          machine_mode MODE)
+     This hook returns true if it is permissible to store a value of
+     mode MODE in hard register number REGNO (or in several registers
+     starting with that one).  The default definition returns true
+     unconditionally.
+
+     You need not include code to check for the numbers of fixed
+     registers, because the allocation mechanism considers them to be
+     always occupied.
+
+     On some machines, double-precision values must be kept in even/odd
+     register pairs.  You can implement that by defining this hook to
+     reject odd register numbers for such modes.
+
+     The minimum requirement for a mode to be OK in a register is that
+     the 'movMODE' instruction pattern support moves between the
+     register and other hard register in the same class and that moving
+     a value into the register and back out not alter it.
+
+     all narrower integer modes, it is not necessary on any machine for
+     this hook to distinguish between these modes, provided you define
+     patterns 'movhi', etc., to take advantage of this.  This is useful
+     because of the interaction between 'TARGET_HARD_REGNO_MODE_OK' and
+     'TARGET_MODES_TIEABLE_P'; it is very desirable for all integer
+     modes to be tieable.
+
+     Many machines have special registers for floating point arithmetic.
+     Often people assume that floating point machine modes are allowed
+     only in floating point registers.  This is not true.  Any registers
+     that can hold integers can safely _hold_ a floating point machine
+     mode, whether or not floating arithmetic can be done on it in those
+     registers.  Integer move instructions can be used to move the
+     values.
+
+     On some machines, though, the converse is true: fixed-point machine
+     modes may not go in floating registers.  This is true if the
+     floating registers normalize any value stored in them, because
+     storing a non-floating value there would garble it.  In this case,
+     'TARGET_HARD_REGNO_MODE_OK' should reject fixed-point machine modes
+     in floating registers.  But if the floating registers do not
+
+     automatically normalize, if you can store any bit pattern in one
+     and retrieve it unchanged without a trap, then any machine mode may
+     go in a floating register, so you can define this hook to say so.
+
+     The primary significance of special floating registers is rather
+     that they are the registers acceptable in floating point arithmetic
+     instructions.  However, this is of no concern to
+     'TARGET_HARD_REGNO_MODE_OK'.  You handle it by writing the proper
+     constraints for those instructions.
+
+     On some machines, the floating registers are especially slow to
+     access, so that it is better to store a value in a stack frame than
+     in such a register if floating point arithmetic is not being done.
+     As long as the floating registers are not in class 'GENERAL_REGS',
+     they will not be used unless some pattern's constraint asks for
+     one.
+=============================================================================*/
+#undef  TARGET_HARD_REGNO_MODE_OK
+#define TARGET_HARD_REGNO_MODE_OK tms9900_hard_regno_mode_ok
+
+bool
+tms9900_hard_regno_mode_ok (unsigned int regno,
+                            machine_mode mode)
+{
+  unsigned int ok_mask = 0;
+  unsigned int reg_mask = 0;
+  unsigned int modesize = GET_MODE_BITSIZE (mode).to_constant ();
+
+  if (mode == CCmode)
+  {
+    ok_mask = 0x10000;
+  }
+  else if (mode == DImode)
+  {
+    ok_mask = 0x107f;  /* R0 through R7, and R12 */
+  }
+  else if (mode == SImode)
+  {
+    ok_mask = 0x71ff;  /* All but R10, R11, R15 */
+  }
+  else if (modesize <= 16)
+  {
+    ok_mask = 0xffff;  /* All general-purpose registers */
+  }
+
+  if (regno < FIRST_PSEUDO_REGISTER)
+  {
+    reg_mask = (1 << regno);
+  }
+
+  return ((ok_mask & reg_mask) != 0);
+}
+
+
+/*=============================================================================
+ -- Target Hook: unsigned int TARGET_HARD_REGNO_NREGS (unsigned int
+          REGNO, machine_mode MODE)
+     This hook returns the number of consecutive hard registers,
+     starting at register number REGNO, required to hold a value of mode
+     MODE.  This hook must never return zero, even if a register cannot
+     hold the requested mode - indicate that with
+     'TARGET_HARD_REGNO_MODE_OK' and/or 'TARGET_CAN_CHANGE_MODE_CLASS'
+     instead.
+
+     The default definition returns the number of words in MODE.
+=============================================================================*/
+#undef  TARGET_HARD_REGNO_NREGS
+#define TARGET_HARD_REGNO_NREGS tms9900_hard_regno_nregs
+
+unsigned int
+tms9900_hard_regno_nregs (unsigned int regno,
+                          machine_mode mode)
+{
+  unsigned int nregs = 1;
+
+  if (regno < HARD_CC_REGNUM)
+  {
+    nregs = CEIL (GET_MODE_SIZE (mode).to_constant (), UNITS_PER_WORD);
+  }
+
+  return (nregs);
+}
+
+
+/*=============================================================================
+ -- Target Hook: bool TARGET_LEGITIMATE_ADDRESS_P (machine_mode MODE,
+          rtx X, bool STRICT)
+     A function that returns whether X (an RTX) is a legitimate memory
+     address on the target machine for a memory operand of mode MODE.
+
+     Legitimate addresses are defined in two variants: a strict variant
+     and a non-strict one.  The STRICT parameter chooses which variant
+     is desired by the caller.
+
+     The strict variant is used in the reload pass.  It must be defined
+     so that any pseudo-register that has not been allocated a hard
+     register is considered a memory reference.  This is because in
+     contexts where some kind of register is required, a pseudo-register
+     with no hard register must be rejected.  For non-hard registers,
+     the strict variant should look up the 'reg_renumber' array; it
+     should then proceed using the hard register number in the array, or
+     treat the pseudo as a memory reference if the array holds '-1'.
+
+     The non-strict variant is used in other passes.  It must be defined
+     to accept all pseudo-registers in every context where some kind of
+     register is required.
+
+     Normally, constant addresses which are the sum of a 'symbol_ref'
+     and an integer are stored inside a 'const' RTX to mark them as
+     constant.  Therefore, there is no need to recognize such sums
+     specifically as legitimate addresses.  Normally you would simply
+     recognize any 'const' as legitimate.
+
+     Usually 'PRINT_OPERAND_ADDRESS' is not prepared to handle constant
+     sums that are not marked with 'const'.  It assumes that a naked
+     'plus' indicates indexing.  If so, then you _must_ reject such
+     naked constant sums as illegitimate addresses, so that none of them
+     will be given to 'PRINT_OPERAND_ADDRESS'.
+
+     On some machines, whether a symbolic address is legitimate depends
+     on the section that the address refers to.  On these machines,
+     define the target hook 'TARGET_ENCODE_SECTION_INFO' to store the
+     information into the 'symbol_ref', and then check for it here.
+     When you see a 'const', you will have to look inside it to find the
+     'symbol_ref' in order to determine the section.  *Note Assembler
+     Format::.
+
+     Some ports are still using a deprecated legacy substitute for this
+     hook, the 'GO_IF_LEGITIMATE_ADDRESS' macro.  This macro has this
+     syntax:
+
+          #define GO_IF_LEGITIMATE_ADDRESS (MODE, X, LABEL)
+
+     and should 'goto LABEL' if the address X is a valid address on the
+     target machine for a memory operand of mode MODE.
+
+     Compiler source files that want to use the strict variant of this
+     macro define the macro 'REG_OK_STRICT'.  You should use an '#ifdef
+     REG_OK_STRICT' conditional to define the strict variant in that
+     case and the non-strict variant otherwise.
+
+     Using the hook is usually simpler because it limits the number of
+     files that are recompiled when changes are made.
+=============================================================================*/
+#undef  TARGET_LEGITIMATE_ADDRESS_P
+#define TARGET_LEGITIMATE_ADDRESS_P tms9900_legitimate_address_p
+bool
+tms9900_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx address, bool strict ATTRIBUTE_UNUSED)
+{
+  struct addr_parts parsed = {0};
+
+  return (parse_operand_address (address, &parsed));
+}
+
+
+/*=============================================================================
+-- Target Hook: rtx_insn * TARGET_MD_ASM_ADJUST (vec<rtx>& OUTPUTS,
+          vec<rtx>& INPUTS, vec<machine_mode>& INPUT_MODES, vec<const
+          char *>& CONSTRAINTS, vec<rtx>& CLOBBERS, HARD_REG_SET&
+          CLOBBERED_REGS, location_t LOC)
+     This target hook may add "clobbers" to CLOBBERS and CLOBBERED_REGS
+     for any hard regs the port wishes to automatically clobber for an
+     asm.  The OUTPUTS and INPUTS may be inspected to avoid clobbering a
+     register that is already used by the asm.  LOC is the source
+     location of the asm.
+
+     It may modify the OUTPUTS, INPUTS, INPUT_MODES, and CONSTRAINTS as
+     necessary for other pre-processing.  In this case the return value
+     is a sequence of insns to emit after the asm.  Note that changes to
+     INPUTS must be accompanied by the corresponding changes to
+     INPUT_MODES.
+=============================================================================*/
+#undef  TARGET_MD_ASM_ADJUST
+#define TARGET_MD_ASM_ADJUST tms9900_md_asm_adjust
+
+rtx_insn*
+tms9900_md_asm_adjust (vec<rtx> &, vec<rtx> &, vec<machine_mode> &,
+                       vec<const char *> &, vec<rtx> &clobbers,
+                       HARD_REG_SET &clobbered_regs, location_t)
+{
+  clobbers.safe_push (gen_rtx_REG (CCmode, CC_REGNUM));
+  SET_HARD_REG_BIT (clobbered_regs, CC_REGNUM);
+  return (NULL);
+}
+
+
+/*=============================================================================
+ -- Target Hook: bool TARGET_MODES_TIEABLE_P (machine_mode MODE1,
+           machine_mode MODE2)
+     This hook returns true if a value of mode MODE1 is accessible in
+     mode MODE2 without copying.
+
+     If 'TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and
+     'TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are always the same for any
+     R, then 'TARGET_MODES_TIEABLE_P (MODE1, MODE2)' should be true.  If
+     they differ for any R, you should define this hook to return false
+     unless some other mechanism ensures the accessibility of the value
+     in a narrower mode.
+
+     You should define this hook to return true in as many cases as
+     possible since doing so will allow GCC to perform better register
+     allocation.  The default definition returns true unconditionally.
+=============================================================================*/
+#undef  TARGET_MODES_TIEABLE_P
+#define TARGET_MODES_TIEABLE_P tms9900_modes_tieable_p
+
+bool
+tms9900_modes_tieable_p (machine_mode mode1 ATTRIBUTE_UNUSED,
+                         machine_mode mode2 ATTRIBUTE_UNUSED)
+{
+  bool ret = true;
+  if ((mode1 == QImode) ||
+      (mode2 == QImode))
+  {
+    ret = false;
+  }
+  return (ret);
+}
+
+
+/*=============================================================================
+  All aggregate types or types larger than four bytes which are
+  to be passsed by value are silently copied to the stack and
+  then passed by reference.
+
+ -- Target Hook: bool TARGET_PASS_BY_REFERENCE (cumulative_args_t CUM,
+          const function_arg_info &ARG)
+     This target hook should return 'true' if argument ARG at the
+     position indicated by CUM should be passed by reference.  This
+     predicate is queried after target independent reasons for being
+     passed by reference, such as 'TREE_ADDRESSABLE (ARG.type)'.
+
+     If the hook returns true, a copy of that argument is made in memory
+     and a pointer to the argument is passed instead of the argument
+     itself.  The pointer is passed in whatever way is appropriate for
+     passing a pointer to that type.
+=============================================================================*/
+#undef  TARGET_PASS_BY_REFERENCE
+#define TARGET_PASS_BY_REFERENCE tms9900_pass_by_reference
+
+bool
+tms9900_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,
+                           const function_arg_info &arg)
+{
+  int size = 0;
+  if (arg.type)
+  {
+    if (AGGREGATE_TYPE_P (arg.type))
+    {
+      return (true);
+    }
+    size = int_size_in_bytes (arg.type);
+  }
+  else
+  {
+    size = GET_MODE_SIZE (arg.mode).to_constant ();
+  }
+  return (size > 4);
+}
+
+
+/*=============================================================================
+ -- Macro: PRINT_OPERAND_ADDRESS (STREAM, MODE, X)
+     A C compound statement to output to stdio stream STREAM the
+     assembler syntax for an instruction operand that is a memory
+     reference whose address is X.  X is an RTL expression.
+=============================================================================*/
+#undef  TARGET_PRINT_OPERAND_ADDRESS
+#define TARGET_PRINT_OPERAND_ADDRESS tms9900_print_operand_address
+
+void
+tms9900_print_operand_address (FILE *file,
+                               machine_mode mode ATTRIBUTE_UNUSED,
+                               register rtx addr)
+{
+  struct addr_parts parsed = {0};
+  int label_offset = (OPF_LABEL | OPF_OFFSET);
+
+  parse_operand_address (addr, &parsed);
+
+  /* Dereference memory address */
+  if (parsed.flags & label_offset)
+  {
+    fprintf (file, "@");
+
+    if ((parsed.flags & label_offset) == label_offset)
+    {
+      fprintf (file, "(");
+    }
+
+    if (parsed.flags & OPF_LABEL)
+    {
+      output_addr_const (file, parsed.label);
+    }
+
+    if (parsed.flags & OPF_OFFSET)
+    {
+      if (parsed.flags & OPF_LABEL)
+      {
+        fprintf (file, "+>%x)", (parsed.offset & 0xffff));
+      }
+      else
+      {
+        fprintf (file, ">%x", (parsed.offset & 0xffff));
+      }
+    }
+
+    if (parsed.flags & OPF_REG)
+    {
+      fprintf (file, "(%s)", reg_names[parsed.regno]);
+    }
+  }
+  else if (parsed.flags & OPF_POSTINC)
+  {
+    fprintf (file, "*%s+", reg_names[parsed.regno]);
+  }
+
+  else if (parsed.flags & OPF_REG)
+  {
+    fprintf (file, "*%s", reg_names[parsed.regno]);
+  }
+}
+
+
+/*=============================================================================
+ -- Macro: PRINT_OPERAND (STREAM, X, CODE)
+     A C compound statement to output to stdio stream STREAM the
+     assembler syntax for an instruction operand X.  X is an RTL
+     expression.
+
+     CODE is a value that can be used to specify one of several ways of
+     printing the operand.  It is used when identical operands must be
+     printed differently depending on the context.  CODE comes from the
+     '%' specification that was used to request printing of the operand.
+     If the specification was just '%DIGIT' then CODE is 0; if the
+     specification was '%LTR DIGIT' then CODE is the ASCII code for LTR.
+=============================================================================*/
+#undef  TARGET_PRINT_OPERAND
+#define TARGET_PRINT_OPERAND tms9900_print_operand
+
+void
+tms9900_print_operand (FILE *file,
+                       rtx x,
+                       int code)
+{
+  if (code == '#')
+  {
+    fprintf (file, "#");
+  }
+
+  else if (GET_CODE (x) == REG)
+  {
+    fprintf (file, "%s", reg_names[REGNO (x)]);
+  }
+
+  else if (GET_CODE (x) == PC)
+  {
+    fprintf (file, "$");
+  }
+
+  else if (GET_CODE (x) == MEM)
+  {
+    tms9900_print_operand_address (file, GET_MODE (x), XEXP (x, 0));
+  }
+
+  else if (GET_CODE (x) == CONST_INT)
+  {
+    fprintf (file, ">%x", (INTVAL (x) & 0xffff));
+  }
+
+  else
+  {
+    output_addr_const (file, x);
+  }
+}
+
+
+/*=============================================================================
+ -- Target Hook: bool TARGET_TRULY_NOOP_TRUNCATION (poly_uint64 OUTPREC,
+          poly_uint64 INPREC)
+     This hook returns true if it is safe to "convert" a value of INPREC
+     bits to one of OUTPREC bits (where OUTPREC is smaller than INPREC)
+     by merely operating on it as if it had only OUTPREC bits.  The
+     default returns true unconditionally, which is correct for most
+     machines.  When 'TARGET_TRULY_NOOP_TRUNCATION' returns false, the
+     machine description should provide a 'trunc' optab to specify the
+     RTL that performs the required truncation.
+
+     If 'TARGET_MODES_TIEABLE_P' returns false for a pair of modes,
+     suboptimal code can result if this hook returns true for the
+     corresponding mode sizes.  Making this hook return false in such
+     cases may improve things.
+=============================================================================*/
+#undef  TARGET_TRULY_NOOP_TRUNCATION
+#define TARGET_TRULY_NOOP_TRUNCATION tms9900_truly_noop_truncation
+
+bool
+tms9900_truly_noop_truncation (poly_uint64 outprec ATTRIBUTE_UNUSED,
+                               poly_uint64 inprec ATTRIBUTE_UNUSED)
+{
+  /* Do no truncation if byte values are used */
+  return ((inprec.to_constant () >= 16) &&
+          (outprec.to_constant () >= 16));
+}
+
+
+/*=============================================================================
+===============================================================================
+
+                           Code used by *.md files
+
+===============================================================================
+=============================================================================*/
+
+
+/*=============================================================================
+  Determine if address satisfies constraint letter
+
+  Inputs : address - Address to examine
+           letter  - Constraint letter
+
+  Returns: 0 - Address does not satisfy constraint
+           1 - Address does satisfy constraint
+=============================================================================*/
+bool
+tms9900_address_ok_for_letter (rtx address, const char letter)
+{
+  int type = tms9900_address_type (address);
+  return (((letter == 'Q') && (type == TMS9900_ADDR_INDEX)) ||
+          ((letter == 'R') && (type == TMS9900_ADDR_INDIRECT)) ||
+          ((letter == '>') && (type == TMS9900_ADDR_POSTINC)));
+}
+
+
+/*=============================================================================
+  Emit code needed for a function epilogue
+
+  Inputs : is_sibcall - Is this a leaf functon?
+
+  Returns: None
+=============================================================================*/
+void
+tms9900_expand_epilogue (bool is_sibcall)
+{
+  /*  Stack Layout:
+   *  --------------
+   *    [Arguments]
+   *    . <- Arg Pointer (Old Stack Pointer)
+   *    [Frame]
+   *    . <- Frame Pointer
+   *    [Saved Regs]
+   *    Old stack pointer
+   *    . <- stack pointer
+   *
+   * Epilogue Format:
+   * -----------------
+   *   mov  r10, r0
+   *   mov *r0+, r10  --.- Restore LR and old SP
+   *   mov *r0+, r11  --'
+   *   mov *r0+, r9   --.
+   *   mov *r0+, r13    |- Save Register Values (If Needed)
+   *   mov *r0+, r14    |
+   *   mov *r0,  r15  --'
+   *   b *r11         ---- Return to caller
+   *
+   * Note: The last MOV does not use post-increment
+   */
+
+  int *regno;
+
+  /* Determine frame size */
+  int locals_size = get_frame_size ().to_constant ();
+  int regs_size = tms9900_get_saved_reg_size ();
+  int args_size = crtl->outgoing_args_size.to_constant ();
+  int frame_size = locals_size + regs_size + args_size;
+
+  if (frame_size > 0)
+  {
+    /* Emit "ai r10, frame_size-regs_size" */
+    emit_insn (gen_addhi3 (stack_pointer_rtx, stack_pointer_rtx,
+                           GEN_INT (frame_size - regs_size)));
+
+    /* Restore non-volatile registers */
+    for (regno = &nvolregs[0]; *regno != 0; regno++)
+    {
+      if (tms9900_should_save_reg (*regno))
+      {
+        /* Emit "mov *r10+, rx" */
+        emit_insn (gen_movhi (
+            gen_rtx_REG (HImode, *regno),
+            gen_rtx_MEM (HImode, gen_rtx_POST_INC (HImode, stack_pointer_rtx))));
+      }
+    }
+  }
+
+  if (!is_sibcall)
+  {
+    /* Emit the return instruction "b *R11" */
+    emit_insn (gen_rtx_UNSPEC (HImode,
+                               gen_rtvec (1, gen_rtx_REG (HImode, HARD_R11_REGNUM)),
+                               UNSPEC_RETURN));
+  }
+}
+
+
+/*=============================================================================
+  Emit code needed for a function prologue
+
+  Inputs : None
+
+  Returns: None
+=============================================================================*/
+void
+tms9900_expand_prologue (void)
+{
+  int reg_bytes = 0;
+  int *regno;
+  struct const_block *block;
+  unsigned int block_idx;
+  int locals_size;
+  int regs_size;
+  int args_size;
+  int frame_size;
+
+  /* Erase register states */
+  memset (&reg_state, 0, sizeof (reg_state));
+
+  /* Determine frame size */
+  locals_size = get_frame_size ().to_constant ();
+  regs_size = tms9900_get_saved_reg_size ();
+  args_size = crtl->outgoing_args_size.to_constant ();
+  frame_size = locals_size + regs_size + args_size;
+
+  if (frame_size > 0)
+  {
+    /* Set frame pointer */
+    if (frame_pointer_needed)
+    {
+      /* Emit "mov sp, fp" */
+      emit_insn (gen_movhi (frame_pointer_rtx,
+                            stack_pointer_rtx));
+
+      /* Emit "ai fp, -regs_size-locals_size" */
+      emit_insn (gen_addhi3 (frame_pointer_rtx, frame_pointer_rtx,
+                             GEN_INT (-regs_size -locals_size)));
+    }
+
+    /* Emit "ai sp, -regs_size " */
+    emit_insn (gen_addhi3 (stack_pointer_rtx, stack_pointer_rtx,
+                           GEN_INT (-regs_size)));
+
+    /* Save non-volatile registers */
+    for (regno = &nvolregs[0]; *regno != 0; regno++)
+    {
+      if (tms9900_should_save_reg (*regno))
+      {
+        regs_size -= HARD_REG_SIZE;
+        if ((regs_size == 0) &&
+            (frame_pointer_needed == 0))
+        {
+          /* Emit "mov rx, *r10" */
+          emit_insn (gen_movhi (
+              gen_rtx_MEM (HImode, stack_pointer_rtx),
+              gen_rtx_REG (HImode, *regno)));
+        }
+        else
+        {
+          /* Emit "mov rx, *r10+" */
+          emit_insn (gen_movhi (
+              gen_rtx_MEM (HImode, gen_rtx_POST_INC (HImode, stack_pointer_rtx)),
+              gen_rtx_REG (HImode, *regno)));
+        }
+      }
+    }
+
+    /* Emit "ai sp, -frame_size " */
+    emit_insn (gen_addhi3 (stack_pointer_rtx, stack_pointer_rtx,
+                           GEN_INT (-frame_size + HARD_REG_SIZE)));
+  }
+
+  /* Initialize constant blocks for this function */
+  for (block_idx = 0;
+       block_idx < sizeof (const_block_list) /
+                   sizeof (const_block_list[0]);
+       block_idx++)
+  {
+    /* Check block params */
+    block = &const_block_list[block_idx];
+    block->end = 0;
+    block->label = NULL;
+  }
+}
+
+
+
+
+/*=============================================================================
+  Emit instructions to perform a jump
+
+  Inputs : length - Length of branch instructions
+
+  Returns: Instructions needed for jump
+=============================================================================*/
+const char*
+tms9900_output_jump (int length)
+{
+  switch (length)
+  {
+    case 2: return ("jmp  %l0");
+    case 4: return ("b    @%l0");
+    default: gcc_unreachable ();
+  }
+}
+
+
+/*=============================================================================
+  Emit instruction text
+
+  Inputs : insn     - RTX record describing this instruction
+           operands - Array of RTX records for instruction operands
+           code     - RTL code describing instruction
+
+  Returns: String passed to "define_insn" expression
+=============================================================================*/
+char*
+tms9900_define_insn (rtx_insn *insn, rtx *operands, int code)
+{
+  if (insn_state != IST_TEXT)
+  {
+    /* We just started composing instruction text, reset register states */
+    memset (reg_state, 0, sizeof (reg_state));
+    insn_state = IST_TEXT;
+  }
+
+  /* Handle instruction */
+  tms9900_insn_info (insn, operands, code);
+  return ("");
+}
+
+
+/*=============================================================================
+  Get instruction length
+
+  Inputs : insn     - RTX record describing this instruction
+           operands - Array of RTX records for instruction operands
+           code     - RTL code describing instruction
+
+  Returns: Number of bytes required for instruction
+=============================================================================*/
+int
+tms9900_insn_length (rtx_insn *insn, rtx *operands, int code)
+{
+  /* Set out file to NULL so we won't emit instructions */
+  FILE *old_out_file = asm_out_file;
+  int length = 0;
+
+  asm_out_file = NULL;
+
+  /* The whole program is run through in order first to get the lengths
+     so we don't need to do anything special with the register states */
+  if (insn_state != IST_LENGTH)
+  {
+    /* We started calculating instruction lengths, reset register states */
+    memset (reg_state, 0, sizeof (reg_state));
+    insn_state = IST_LENGTH;
+  }
+
+  /* Handle instruction */
+  length = tms9900_insn_info (insn, operands, code);
+
+  /* Restore out file so we can emit instructions again */
+  asm_out_file = old_out_file;
+  return (length);
+}
+
+
+/* Define target record */
+struct gcc_target targetm = TARGET_INITIALIZER;
+
diff -rupN gcc-12.1.0-original/gcc/config/tms9900/tms9900.h gcc-12.1.0/gcc/config/tms9900/tms9900.h
--- gcc-12.1.0-original/gcc/config/tms9900/tms9900.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-12.1.0/gcc/config/tms9900/tms9900.h	2024-03-13 00:00:04.698224896 -0400
@@ -0,0 +1,1062 @@
+/* Definitions of target machine for GNU compiler.
+   Texas Instruments TMS9900
+   Copyright (C) 2009
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.
+*/
+
+#ifndef GCC_TMS9900_H
+#define GCC_TMS9900_H
+
+
+/* Forward type declaration for prototype definitions.
+   rtx_ptr is equivalent to rtx. Can't use the same name. */
+//struct rtx_def;
+//typedef struct rtx_def *rtx_ptr;
+
+
+//union tree_node;
+//typedef union tree_node *tree_ptr;
+
+
+/* We can't declare enum machine_mode forward nor include 'machmode.h' here.
+   Prototypes defined here will use an int instead. It's better than no
+   prototype at all. */
+//typedef int enum_machine_mode;
+
+
+/* Define a data type for recording info about an argument list
+   during the scan of that argument list.  This data type should
+   hold all necessary information about the function itself
+   and about the args processed so far, enough to enable macros
+   such as FUNCTION_ARG to determine where the next arg should go. */
+typedef struct tms9900_args
+{
+  int nregs;        /* Number of registers used so far */
+  int named_count;  /* Number of named arguments (for varargs) */  
+} CUMULATIVE_ARGS;
+
+//extern short *reg_renumber;  /* defined in local_alloc.c */
+
+
+#include "tms9900-protos.h"
+
+
+/*****************************************************************************
+**
+** GCC Compiler Specification
+**
+*****************************************************************************/
+
+
+#undef ENDFILE_SPEC
+
+/* Options to pass to the assembler */
+#ifndef ASM_SPEC
+#define ASM_SPEC ""
+#endif
+
+/* Options for the linker. 
+   We need to tell the linker to target elf format.
+   This can be overridden by -Wl option of gcc. */
+#ifndef LINK_SPEC
+#define LINK_SPEC "-m elf32_tms9900"
+#endif
+
+/* More linker options, these are used at the beginning of the command */
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC ""
+
+/* More linker options, used at the end of the command string */
+#ifndef LIB_SPEC
+#define LIB_SPEC ""
+#endif
+
+/* Options to pass to CC1 and other language front ends */
+#ifndef CC1_SPEC
+#define CC1_SPEC ""
+#endif
+
+/* Options to pass to the C Preprocessor */
+#ifndef CPP_SPEC
+#define CPP_SPEC ""
+#endif
+
+/* Names to predefine in the preprocessor for this target machine. */
+#define TARGET_CPU_CPP_BUILTINS()    \
+  do                                 \
+  {                                  \
+    builtin_define_std ("tms9900");  \
+  }                                  \
+  while (0)
+
+
+/*****************************************************************************
+**
+** Run-time Target Specification
+**
+*****************************************************************************/
+
+/* Run-time compilation parameters selecting different hardware subsets. */
+#define TARGET_OP_TIME (optimize && optimize_size == 0)
+#define TARGET_RELAX   (TARGET_NO_DIRECT_MODE)
+
+/* Define this macro as a C expression for the initializer of an
+   array of string to tell the driver program which options are
+   defaults for this target and thus do not need to be handled
+   specially when using `MULTILIB_OPTIONS'. */
+#ifndef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS { "tms9900" }
+#endif
+
+/* Target machine storage layout */
+
+/* Define this as 1 if most significant byte of a word is the lowest numbered. */
+#define BYTES_BIG_ENDIAN 	1
+
+/* Define this as 1 if most significant bit is lowest numbered
+   in instructions that operate on numbered bit-fields. */
+#define BITS_BIG_ENDIAN         0
+
+/* Define this as 1 if most significant word of a multiword number is lowest numbered. */
+#define WORDS_BIG_ENDIAN 	1
+
+/* Width of a word, in units (bytes). */
+#define UNITS_PER_WORD		2
+
+/* Definition of size_t.  This is really an unsigned short as the
+   TMS9900 only handles a 64K address space. */
+#define SIZE_TYPE               "short unsigned int"
+
+/* A C expression for a string describing the name of the data type
+   to use for the result of subtracting two pointers.  The typedef
+   name `ptrdiff_t' is defined using the contents of the string.
+   The TMS9900 only has a 64K address space. */
+#define PTRDIFF_TYPE            "short int"
+
+/* Allocation boundary (bits) for storing pointers in memory. */
+#define POINTER_BOUNDARY	16
+
+/* Normal alignment required for function parameters on the stack, in bits.
+   This can't be less than BITS_PER_WORD */
+#define PARM_BOUNDARY		(BITS_PER_WORD)
+
+/* Boundary (bits) on which stack pointer should be aligned. */
+#define STACK_BOUNDARY		16
+
+/* Allocation boundary (bits) for the code of a function. */
+#define FUNCTION_BOUNDARY	16
+
+/* Biggest alignment which, if violated, may cause a fault */
+#define BIGGEST_ALIGNMENT	16
+
+/* Alignment of field after `int : 0' in a structure. */
+#define EMPTY_FIELD_BOUNDARY	16
+
+/* Every structure's size must be a multiple of this. */
+#define STRUCTURE_SIZE_BOUNDARY 16
+
+/* Define this as 1 if instructions will fail to work if given data not
+   on the nominal alignment.  If instructions will merely go slower
+   in that case, do not define this macro. */
+#define STRICT_ALIGNMENT	1
+
+/* An integer expression for the size in bits of the largest integer
+   machine mode that should actually be used.  All integer machine modes of
+   this size or smaller can be used for structures and unions with the
+   appropriate sizes. */
+#define MAX_FIXED_MODE_SIZE	64
+
+/* target machine storage layout */
+
+/* Size (bits) of the type "int" on target machine */
+#define INT_TYPE_SIZE           16
+
+/* Size (bits) of the type "short" on target machine */
+#define SHORT_TYPE_SIZE		16
+
+/* Size (bits) of the type "long" on target machine */
+#define LONG_TYPE_SIZE		32
+
+/* Size (bits) of the type "long long" on target machine */
+#define LONG_LONG_TYPE_SIZE     64
+
+/* A C expression for the size in bits of the type `float' on the
+   target machine. If you don't define this, the default is one word.
+   Don't use default: a word is only 16. */
+#define FLOAT_TYPE_SIZE         32
+
+/* A C expression for the size in bits of the type double on the target
+   machine. If you don't define this, the default is two words.
+   Be IEEE compliant. */
+#define DOUBLE_TYPE_SIZE        64
+
+#define LONG_DOUBLE_TYPE_SIZE   64
+
+/* Define this as 1 if `char' should by default be signed; else as 0. */
+#define DEFAULT_SIGNED_CHAR	1
+
+/* A C expression for a string describing the name of the data type
+   to use for wide characters.  The typedef name `wchar_t' is defined
+   using the contents of the string.
+   
+   Define these to avoid dependence on meaning of `int'.
+   Note that WCHAR_TYPE_SIZE is used in cexp.y,
+   where TARGET_SHORT is not available. */
+#define WCHAR_TYPE              "short int"
+#define WCHAR_TYPE_SIZE         16
+
+/* Standard register usage. */
+#define HARD_REG_SIZE           2
+
+#define REGS_PER_WORD           (UNITS_PER_WORD / HARD_REG_SIZE)
+
+/* Real 16-bit registers */
+#define HARD_R0_REGNUM          0  /* Shift count */
+#define HARD_R1_REGNUM          1
+#define HARD_R2_REGNUM          2
+#define HARD_R3_REGNUM          3
+#define HARD_R4_REGNUM          4
+#define HARD_R5_REGNUM          5
+#define HARD_R6_REGNUM          6
+#define HARD_R7_REGNUM          7
+#define HARD_R8_REGNUM          8
+#define HARD_R9_REGNUM          9
+#define HARD_R10_REGNUM        10  /* Stack pointer  */
+#define HARD_R11_REGNUM        11  /* Return pointer */
+#define HARD_R12_REGNUM        12  /* CRU base       */
+#define HARD_R13_REGNUM        13
+#define HARD_R14_REGNUM        14
+#define HARD_R15_REGNUM        15
+#define HARD_CC_REGNUM         16
+/* Number of registers */
+#define HARD_REGNUM_COUNT      17
+
+/* Stack pointer */
+#define HARD_SP_REGNUM         HARD_R10_REGNUM
+
+/* How to refer to registers in assembler output.  This sequence is indexed
+   by compiler's hard-register-number (see above). */
+#define REGISTER_NAMES \
+{ "r0",  "r1", "r2",  "r3",  "r4",  "r5",  "r6",  "r7",  \
+  "r8",  "r9", "r10", "r11", "r12", "r13", "r14", "r15", \
+  "cc"                                                   \
+}
+
+/* Number of actual hardware registers. The hardware registers are assigned
+   numbers for the compiler from 0 to just below FIRST_PSEUDO_REGISTER. 
+   All registers that the compiler knows about must be given numbers, even
+   those that are not normally considered general registers. */
+#define FIRST_PSEUDO_REGISTER  (HARD_REGNUM_COUNT)
+
+/* 1 for registers that have pervasive standard uses and are not available
+   for the register allocator. */
+#define FIXED_REGISTERS \
+/* 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15  <- Data registers */ \
+  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,                      \
+/* CC */                                                                \
+   1}
+
+/* 0 for registers which must be preserved across function call boundaries */
+#define CALL_USED_REGISTERS \
+/* 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15  <- Data registers */ \
+  {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0,                      \
+/* CC */                                                                \
+   1}
+
+/* Define this macro to change register usage conditional on target flags. */
+//#define TARGET_CONDITIONAL_REGISTER_USAGE 
+
+/* List the order in which to allocate registers.  Each register must be
+   listed once, even those in FIXED_REGISTERS. */
+#define REG_ALLOC_ORDER	\
+   {HARD_R1_REGNUM,  HARD_R2_REGNUM,  HARD_R3_REGNUM,  HARD_R4_REGNUM, \
+    HARD_R5_REGNUM,  HARD_R6_REGNUM,  HARD_R7_REGNUM,  HARD_R8_REGNUM, \
+    HARD_R12_REGNUM, HARD_R0_REGNUM,  HARD_R9_REGNUM,  HARD_R13_REGNUM,\
+    HARD_R14_REGNUM, HARD_R15_REGNUM, HARD_R11_REGNUM,                 \
+    HARD_R10_REGNUM, HARD_CC_REGNUM}
+
+/* Define the classes of registers for register constraints in the
+   machine description.  Also define ranges of constants.
+
+   One of the classes must always be named ALL_REGS and include all hard regs.
+   If there is more than one class, another class must be named NO_REGS
+   and contain no registers.
+
+   The classes must be numbered in nondecreasing order; that is,
+   a larger-numbered class must never be contained completely
+   in a smaller-numbered class.
+
+   For any two classes, it is very desirable that there be another
+   class that represents their union. */
+enum reg_class
+{
+  NO_REGS,        /* Class containing no registers */
+  SHIFT_REGS,     /* Register used for variable shift (SC) */
+  CRU_REGS,       /* Register used for CRU access (CB) */
+  BASE_REGS,      /* Registers which may be used as a memory base */
+  DATA_REGS,      /* All general-purpose registers */
+  CC_REGS,        /* Condition flags */
+  ALL_REGS,       /* All registers, including fakes */
+  LIM_REG_CLASSES
+};
+
+/* The name GENERAL_REGS must be the name of a class (or an alias for
+   another name such as ALL_REGS).  This is the class of registers
+   that is allowed by "g" or "r" in a register constraint.
+   Also, registers outside this class are allocated only when
+   instructions express preferences for them. */
+#define GENERAL_REGS	       DATA_REGS
+
+/* The number of distict register classes */
+#define N_REG_CLASSES	       ((int) LIM_REG_CLASSES)
+
+/* Give names of register classes as strings for dump file. */
+#define REG_CLASS_NAMES \
+{ "NO_REGS",    \
+  "SHIFT_REGS", \
+  "CRU_REGS",   \
+  "BASE_REGS",  \
+  "DATA_REGS",  \
+  "CC_REGS"     \
+  "ALL_REGS" }
+
+/* An initializer containing the contents of the register classes,
+   as integers which are bit masks.  The Nth integer specifies the
+   contents of class N.  The way the integer MASK is interpreted is
+   that register R is in the class if `MASK & (1 << R)' is 1. */
+
+#define REG_CLASS_CONTENTS \
+  {{ 0x00000000 },  /* NO_REGS                    */ \
+   { 0x00000001 },  /* SHIFT_REGS (R0)            */ \
+   { 0x00001000 },  /* CRU_REGS   (R12)           */ \
+   { 0x0000FFFE },  /* BASE_REGS  (All except R0) */ \
+   { 0x0000FFFF },  /* DATA_REGS  (All registers) */ \
+   { 0x00010000 },  /* CC_REGS    (Condition reg) */ \
+   { 0x0001FFFF }}  /* ALL_REGS                   */
+
+/* Set up a C expression whose value is a register class containing hard
+   register REGNO */
+#define REGNO_REG_CLASS(REGNO) \
+  (( REGNO == HARD_R0_REGNUM )  ? SHIFT_REGS : ( \
+   ( REGNO == HARD_R12_REGNUM)  ? CRU_REGS   : ( \
+   ( REGNO == HARD_CC_REGNUM )  ? CC_REGS    : ( \
+   ( REGNO <= HARD_R15_REGNUM)  ? BASE_REGS  : ( \
+   NO_REGS)))))
+
+/* A C expression that places additional restrictions of the register
+   class to use when it is necessary to copy value X into a register
+   in class CLASS. Some values may require the use of a more restrictive
+   class.*/
+#define PREFERRED_RELOAD_CLASS(X,CLASS)	CLASS
+
+/* Return the maximum number of consecutive registers needed to represent
+   mode MODE in a register of class CLASS. */
+#define CLASS_MAX_NREGS(CLASS, MODE) \
+   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* Stack layout; function entry, exit and calling. */
+
+/* Define this if pushing a word on the stack
+   makes the stack pointer a smaller address. */
+#define STACK_GROWS_DOWNWARD   1
+
+/* Define this to nonzero if the nominal address of the stack frame
+   is at the high-address end of the local variables;
+   that is, each additional local variable allocated
+   goes at a more negative offset in the frame.
+
+   Define to 0 for TMS9900, the frame pointer is the bottom
+   of local variables. */
+#define FRAME_GROWS_DOWNWARD   0
+
+/* Offset of first parameter from the argument pointer register value. */
+#define FIRST_PARM_OFFSET(FNDECL) 0
+
+/* After the prologue, RA is at 0(AP) in the current frame. */
+#define RETURN_ADDR_RTX(COUNT, FRAME)     \
+  ((COUNT) == 0	                          \
+   ? gen_rtx_MEM (Pmode, arg_pointer_rtx) \
+   : 0)
+
+/* Before the prologue, the top of the frame is at 2(sp). */
+#define INCOMING_FRAME_SP_OFFSET        0
+
+/* The location of the incoming return address at the start of a function */
+#define INCOMING_RETURN_ADDR_RTX	gen_rtx_REG (HImode, HARD_R11_REGNUM)
+
+/* Register to use for pushing function arguments. */
+#define STACK_POINTER_REGNUM		HARD_SP_REGNUM
+
+/* Base register for access to local variables of the function. */
+#define FRAME_POINTER_REGNUM		HARD_R9_REGNUM
+
+/* Base register for access to arguments of the function. */
+#define ARG_POINTER_REGNUM		HARD_R7_REGNUM
+
+/* Register in which static-chain is passed to a function. */
+#define STATIC_CHAIN_REGNUM	        HARD_R9_REGNUM
+
+/* Definitions for register eliminations.
+
+   This is an array of structures.  Each structure initializes one pair
+   of eliminable registers.  The "from" register number is given first,
+   followed by "to".  Eliminations of the same "from" register are listed
+   in order of preference.
+
+   The pseudo arg pointer and pseudo frame pointer registers can always
+   be eliminated; they are replaced with either the stack or the real
+   frame pointer. */
+#define ELIMINABLE_REGS \
+  {{ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\
+   {ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM},\
+   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}
+
+/* Define the offset between two registers, one to be eliminated, and the other
+   its replacement, at the start of a routine. */
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
+   { OFFSET = tms9900_initial_elimination_offset (FROM, TO); }
+
+/* Passing Function Arguments on the Stack. */
+
+/* A C expression.  If nonzero, push insns will be used to pass
+   outgoing arguments.  If the target machine does not have a push
+   instruction, set it to zero.  That directs GCC to use an alternate
+   strategy: to allocate the entire argument block and then store the
+   arguments into it.  When `PUSH_ARGS' is nonzero, `PUSH_ROUNDING'
+   must be defined too. */
+#define PUSH_ARGS 0
+
+/* Passing Arguments in Registers. */
+
+/* The number of argument registers we can use (R1..R6) */
+#define TMS9900_ARG_REGS (HARD_R7_REGNUM - HARD_R1_REGNUM)
+
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  The value is tested only in functions
+   that have frame pointers. No definition is equivalent to always zero. */
+#define EXIT_IGNORE_STACK 0
+
+/* Generating Code for Profiling. */
+#define TRAMPOLINE_SIZE       8
+#define TRAMPOLINE_ALIGNMENT 16
+
+/* The TMS9900 can only do post increment */
+#define HAVE_POST_INCREMENT  (1)
+#define HAVE_PRE_INCREMENT   (0)
+#define HAVE_POST_DECREMENT  (0)
+#define HAVE_PRE_DECREMENT   (0)
+#define HAVE_POST_MODIFY_REG (0)
+
+/* The name of the class to which a valid base register must belong.
+   A base register is one used in an address which is the register
+   value plus a displacement. */
+#define BASE_REG_CLASS       BASE_REGS
+
+/* The class value for index registers. */
+#define INDEX_REG_CLASS	     NO_REGS
+
+
+/* Maximum number of registers that can appear in a valid memory address */
+#define MAX_REGS_PER_ADDRESS 1
+
+
+/* Nonzero if access to memory by bytes is slow and undesirable. */
+#define SLOW_BYTE_ACCESS     0
+
+/* Defining the Output Assembler Language. */
+
+/* A default list of other sections which we might be "in" at any given
+   time.  For targets that use additional sections (e.g. .tdesc) you
+   should override this definition in the target-specific file which
+   includes this file. */
+
+/* Output before read-only data. */
+#define TEXT_SECTION_ASM_OP    ("\tpseg")
+
+/* Output before writable data. */
+#define DATA_SECTION_ASM_OP    ("\tdseg")
+
+/* Output before uninitialized data. */
+#define BSS_SECTION_ASM_OP     ("\tcseg")
+
+/* Define this macro to be an expression with a nonzero value if jump tables
+   (for tablejump insns) should be output in the text section, along with the
+   assembler instructions. Otherwise, the readonly data section is used. */
+#define JUMP_TABLES_IN_TEXT_SECTION (1)
+
+/* Comment character */
+#define ASM_COMMENT_START      "*"
+
+/* Output to assembler file text saying following lines
+   may contain character constants, extra white space, comments, etc. */
+#define ASM_APP_ON             "* Begin inline assembler code\n"
+
+/* Output to assembler file text saying following lines
+   no longer contain unusual constructs. */
+#define ASM_APP_OFF            "* End of inline assembler code\n"
+
+/* Advance to the next word boundary */
+#undef ALIGN_ASM_OP
+#define ALIGN_ASM_OP           "\teven\t"
+
+/* Assembler Commands for Exception Regions. */
+
+/* Default values provided by GCC should be ok. Assuming that DWARF-2
+   frame unwind info is ok for this platform. */
+#define DWARF2_DEBUGGING_INFO  1
+
+/* This flag is true if the target supports `TARGET_ASM_NAMED_SECTION'. */
+#define TARGET_HAVE_NAMED_SECTIONS 1
+
+/* Output assembly directives to switch to section NAME.  The section
+   should have attributes as specified by FLAGS, which is a bit mask
+   of the `SECTION_*' flags defined in `output.h'.  If ALIGN is
+   nonzero, it contains an alignment in bytes to be used for the
+   section, otherwise some target default should be used.  Only
+   targets that must specify an alignment within the section
+   directive need pay attention to ALIGN - we will still use
+   `ASM_OUTPUT_ALIGN'. */
+#define TARGET_ASM_NAMED_SECTION   default_elf_asm_named_section
+
+/* Directive to give a symbol global scope */
+#define GLOBAL_ASM_OP              "\n\tdef\t"
+
+/* Miscellaneous Parameters. */
+
+/* Specify the machine mode that this machine uses
+   for the index in the tablejump instruction. */
+#define CASE_VECTOR_MODE       Pmode
+
+/* Max number of bytes we can move from memory to memory in one
+   reasonably fast instruction. */
+#define MOVE_MAX               2
+
+/* MOVE_RATIO is the number of move instructions that is better than a
+   block move.  Make this small, since the code size grows very
+   large with each move. */
+#define MOVE_RATIO(SPEED)      3
+
+/* Define if shifts truncate the shift count which implies one can omit
+   a sign-extension or zero-extension of a shift count. */
+#define SHIFT_COUNT_TRUNCATED  1
+
+/* Specify the machine mode that pointers have. After generation of rtl, the
+   compiler makes no further distinction between pointers and any other
+   objects of this machine mode. */
+#define Pmode                  HImode
+
+/* An alias for the machine mode used for memory references to
+   functions being called, in `call' RTL expressions.  On most CISC
+   machines, where an instruction can begin at any byte address, this
+   should be `QImode'.  On most RISC machines, where all instructions
+   have fixed size and alignment, this should be a mode with the same
+   size and alignment as the machine instruction words - typically
+   `SImode' or `HImode'. */
+#define FUNCTION_MODE          HImode
+
+/* Put references to global constructors in a .init section. The crt0 code
+   will invoke these constructors at startup, before calling main. */
+#define INIT_SECTION_ASM_OP    "\t.section\t.init"
+
+#undef  SIZE_ASM_OP
+#define SIZE_ASM_OP            "\t.size\t"
+
+#undef  TYPE_ASM_OP
+#define TYPE_ASM_OP            "\t.type\t"
+
+#undef  TYPE_OPERAND_FMT
+#define TYPE_OPERAND_FMT       "@%s"
+
+
+
+//---------------------Target Macros ------------------------------------
+
+
+/*=============================================================================
+ -- Macro: ACCUMULATE_OUTGOING_ARGS
+     A C expression.  If nonzero, the maximum amount of space required
+     for outgoing arguments will be computed and placed into
+     'crtl->outgoing_args_size'.  No space will be pushed onto the stack
+     for each call; instead, the function prologue should increase the
+     stack frame size by this amount.
+=============================================================================*/
+#undef ACCUMULATE_OUTGOING_ARGS
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+
+/*=============================================================================
+ -- Macro: PAD_VARARGS_DOWN
+     If defined, a C expression which determines whether the default
+     implementation of va_arg will attempt to pad down before reading
+     the next argument, if that argument is smaller than its aligned
+     space as controlled by 'PARM_BOUNDARY'.  If this macro is not
+     defined, all such arguments are padded down if 'BYTES_BIG_ENDIAN'
+     is true.
+=============================================================================*/
+#undef PAD_VARARGS_DOWN
+#define PAD_VARARGS_DOWN \
+  (tms9900_function_arg_padding (TYPE_MODE (type), type) == PAD_DOWNWARD)
+
+
+/*=============================================================================
+ -- Macro: FUNCTION_ARG_REGNO_P (REGNO)
+     A C expression that is nonzero if REGNO is the number of a hard
+     register in which function arguments are sometimes passed.  This
+     does _not_ include implicit arguments such as the static chain and
+     the structure-value address.  On many machines, no registers can be
+     used for this purpose since all function arguments are pushed on
+     the stack.
+=============================================================================*/
+#define FUNCTION_ARG_REGNO_P(REGNO) \
+  (((REGNO) >= HARD_R1_REGNUM) && ((REGNO) <= HARD_R6_REGNUM))
+
+
+/*=============================================================================
+ -- Macro: LIBCALL_VALUE (MODE)
+     A C expression to create an RTX representing the place where a
+     library function returns a value of mode MODE.
+=============================================================================*/
+#define LIBCALL_VALUE(MODE) \
+  gen_rtx_REG (MODE, HARD_R1_REGNUM)
+
+
+/*=============================================================================
+ -- Macro: FUNCTION_VALUE_REGNO_P (REGNO)
+     A C expression that is nonzero if REGNO is the number of a hard
+     register in which the values of called function may come back.
+=============================================================================*/
+#define FUNCTION_VALUE_REGNO_P(REGNO) \
+  ((REGNO) == HARD_R1_REGNUM)
+
+
+/*=============================================================================
+ -- Macro: FUNCTION_PROFILER (FILE, LABELNO)
+     A C statement or compound statement to output to FILE some
+     assembler code to call the profiling subroutine 'mcount'.
+=============================================================================*/
+#define FUNCTION_PROFILER(FILE, LABELNO)  \
+  fprintf (FILE, "\tli   LP%d\n\tbl   @mcount\n", (LABELNO))
+
+
+/*=============================================================================
+ -- Macro: REGNO_OK_FOR_BASE_P (NUM)
+     A C expression which is nonzero if register number NUM is suitable
+     for use as a base register in operand addresses.
+=============================================================================*/
+#ifdef REG_OK_STRICT           
+#define REGNO_OK_FOR_BASE_P(X)  \
+  (((X) >= HARD_R1_REGNUM) &&   \
+   ((X) <= HARD_R15_REGNUM))
+#else
+#define REGNO_OK_FOR_BASE_P(X)  \
+  (1)
+#endif
+
+
+/*=============================================================================
+ -- Macro: REGNO_OK_FOR_INDEX_P (NUM)
+     A C expression which is nonzero if register number NUM is suitable
+     for use as an index register in operand addresses.  It may be
+     either a suitable hard register or a pseudo register that has been
+     allocated such a hard register.
+=============================================================================*/
+#define REGNO_OK_FOR_INDEX_P(NUM) (0)
+
+
+/*=============================================================================
+ -- Macro: REGISTER_MOVE_COST (MODE, FROM, TO)
+     A C expression for the cost of moving data of mode MODE from a
+     register in class FROM to one in class TO.  The classes are
+     expressed using the enumeration values such as 'GENERAL_REGS'.  A
+     value of 2 is the default; other values are interpreted relative to
+     that.
+=============================================================================*/
+#define REGISTER_MOVE_COST(MODE, FROM, TO) (2)
+
+
+/*=============================================================================
+ -- Macro: MEMORY_MOVE_COST (MODE, CLASS, IN)
+     A C expression for the cost of moving data of mode MODE between a
+     register of class CLASS and memory; IN is zero if the value is to
+     be written to memory, nonzero if it is to be read in.  This cost is
+     relative to those in 'REGISTER_MOVE_COST'.  If moving between
+     registers and memory is more expensive than between two registers,
+     you should define this macro to express the relative cost.
+=============================================================================*/
+#define MEMORY_MOVE_COST(MODE, CLASS, IN) 8
+
+
+/*=============================================================================
+ -- Macro: BRANCH_COST (SPEED_P, PREDICTABLE_P)
+     A C expression for the cost of a branch instruction.  A value of 1
+     is the default; other values are interpreted relative to that.
+     Parameter SPEED_P is true when the branch in question should be
+     optimized for speed.
+=============================================================================*/
+#define BRANCH_COST(SPEED_P, PREDICTABLE_P) 0
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_EXTERNAL (STREAM, DECL, NAME)
+     A C statement (sans semicolon) to output to the stdio stream STREAM
+     any text necessary for declaring the name of an external symbol
+     named NAME which is referenced in this compilation but not defined.
+     The value of DECL is the tree node for the declaration.
+=============================================================================*/
+#undef ASM_OUTPUT_EXTERNAL
+#define ASM_OUTPUT_EXTERNAL(FILE,DECL,NAME)  \
+  {                                          \
+    fputs ("\n\tref\t", FILE);               \
+    assemble_name (FILE, NAME);              \
+    fputs ("\n", FILE);                      \
+  }
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_LABEL (STREAM, NAME)
+     A C statement (sans semicolon) to output to the stdio stream STREAM
+     the assembler definition of a label named NAME.  Use the expression
+     'assemble_name (STREAM, NAME)' to output the name itself; before
+     and after that, output the additional assembler syntax for defining
+     the name, and a newline.  A default definition of this macro is
+     provided which is correct for most systems.
+=============================================================================*/
+#define ASM_OUTPUT_LABEL(FILE,NAME)  \
+  {                                  \
+    assemble_name ((FILE), (NAME));  \
+    fputc ('\n', (FILE));            \
+  }
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_INTERNAL_LABEL (STREAM, NAME)
+     Identical to 'ASM_OUTPUT_LABEL', except that NAME is known to refer
+     to a compiler-generated label.  The default definition uses
+     'assemble_name_raw', which is like 'assemble_name' except that it
+     is more efficient.
+=============================================================================*/
+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,NAME)  \
+  {                                           \
+    assemble_name ((FILE), (NAME));           \
+    fputc ('\n', (FILE));                     \
+  }
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_ADDR_DIFF_ELT (STREAM, BODY, VALUE, REL)
+     A C statement to output to the stdio stream STREAM an assembler
+     pseudo-instruction to generate a difference between two labels.
+     VALUE and REL are the numbers of two internal labels.
+=============================================================================*/
+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \
+  fprintf (FILE, "\t%s\tL%d-L%d\n", integer_asm_op (2, TRUE), VALUE, REL)
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_ADDR_VEC_ELT (STREAM, VALUE)
+     This macro should be provided on machines where the addresses in a
+     dispatch table are absolute.
+=============================================================================*/
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \
+  fprintf (FILE, "\t%s\tL%d\n", integer_asm_op (2, TRUE), VALUE)
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_ALIGN (STREAM, POWER)
+     A C statement to output to the stdio stream STREAM an assembler
+     command to advance the location counter to a multiple of 2 to the
+     POWER bytes.  POWER will be a C expression of type 'int'.
+=============================================================================*/
+#define ASM_OUTPUT_ALIGN(STREAM, POWER)  \
+  switch (POWER)                         \
+  {                                      \
+    case 0:                              \
+      break;                             \
+    case 1:                              \
+      fprintf (STREAM, "\teven\n");      \
+      break;                             \
+    default:                             \
+      gcc_unreachable ();                \
+  }
+
+/*=============================================================================
+ -- Macro: ASM_GENERATE_INTERNAL_LABEL (STRING, PREFIX, NUM)
+     A C statement to store into the string STRING a label whose name is
+     made from the string PREFIX and the number NUM.
+=============================================================================*/
+#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM) \
+  sprintf (STRING, "*%s%ld", PREFIX, (long)(NUM))
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_SKIP (STREAM, NBYTES)
+     A C statement to output to the stdio stream STREAM an assembler
+     instruction to advance the location counter by NBYTES bytes.  Those
+     bytes should be zero when loaded.  NBYTES will be a C expression of
+     type 'unsigned HOST_WIDE_INT'.
+=============================================================================*/
+#define ASM_OUTPUT_SKIP(STREAM, NBYTES) \
+  fprintf(STREAM, "\tbss %lu\n", NBYTES);
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_ALIGNED_BSS (STREAM, DECL, NAME, SIZE, ALIGNMENT)
+     A C statement (sans semicolon) to output to the stdio stream STREAM
+     the assembler definition of uninitialized global DECL named NAME
+     whose size is SIZE bytes.  The variable ALIGNMENT is the alignment
+     specified as the number of bits.
+=============================================================================*/
+#define ASM_OUTPUT_ALIGNED_BSS(STREAM, DECL, NAME, SIZE, ALIGNMENT)  \
+  if (ALIGNMENT > 1)                                                 \
+  {                                                                  \
+    fprintf ((STREAM), "\n\teven\n");                                \
+  }                                                                  \
+  asm_output_aligned_bss ((STREAM), (DECL), (NAME), (SIZE), (ALIGNMENT));
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_ALIGNED_COMMON (STREAM, NAME, SIZE, ALIGNMENT)
+     Like 'ASM_OUTPUT_COMMON' except takes the required alignment as a
+     separate, explicit argument.  If you define this macro, it is used
+     in place of 'ASM_OUTPUT_COMMON', and gives you more flexibility in
+     handling the required alignment of the variable.  The alignment is
+     specified as the number of bits.
+=============================================================================*/
+#define ASM_OUTPUT_ALIGNED_COMMON(STREAM, NAME, SIZE, ALIGNMENT)  \
+  do                                                              \
+  {                                                               \
+    switch_to_section (bss_section);                              \
+    if (ALIGNMENT > 1)                                            \
+    {                                                             \
+      fprintf ((STREAM), "\n\teven");                             \
+    }                                                             \
+    fprintf ((STREAM), "\n\tdef %s\n", (NAME));                   \
+    assemble_name ((STREAM), (NAME));                             \
+    fprintf ((STREAM), "\n\tbss %u\n", (int)(SIZE));              \
+  } while (0)
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_LOCAL (STREAM, NAME, SIZE, ROUNDED)
+     A C statement (sans semicolon) to output to the stdio stream STREAM
+     the assembler definition of a local-common-label named NAME whose
+     size is SIZE bytes.  The variable ROUNDED is the size rounded up to
+     whatever alignment the caller wants.
+=============================================================================*/
+#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ROUNDED)  \
+  do                                                           \
+  {                                                            \
+    switch_to_section (bss_section);                           \
+    if (ROUNDED > 1)                                           \
+    {                                                          \
+      fprintf ((STREAM), "\n\teven\n");                        \
+    }                                                          \
+    assemble_name ((STREAM), (NAME));                          \
+    fprintf ((STREAM), "\n\tbss %u\n", (int)(SIZE));           \
+  } while (0)
+
+
+/*=============================================================================
+ -- Macro: ASM_DECLARE_FUNCTION_SIZE (STREAM, NAME, DECL)
+     A C statement (sans semicolon) to output to the stdio stream STREAM
+     any text necessary for declaring the size of a function which is
+     being defined.  The argument NAME is the name of the function.  The
+     argument DECL is the 'FUNCTION_DECL' tree node representing the
+     function.
+=============================================================================*/
+#define ASM_DECLARE_FUNCTION_SIZE(STREAM, NAME, DECL)  \
+  do                                                   \
+  {                                                    \
+    if (!flag_inhibit_size_directive)                  \
+    {                                                  \
+      ASM_OUTPUT_MEASURED_SIZE (STREAM, NAME);         \
+    }                                                  \
+  } while (0)
+
+
+/*=============================================================================
+ -- Macro: ASM_DECLARE_OBJECT_NAME (STREAM, NAME, DECL)
+     A C statement (sans semicolon) to output to the stdio stream STREAM
+     any text necessary for declaring the name NAME of an initialized
+     variable which is being defined.  This macro must output the label
+     definition (perhaps using 'ASM_OUTPUT_LABEL').  The argument DECL
+     is the 'VAR_DECL' tree node representing the variable.
+=============================================================================*/
+#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL)                      \
+  do                                                                     \
+  {                                                                      \
+    ASM_OUTPUT_TYPE_DIRECTIVE (STREAM, NAME, "object");                  \
+    size_directive_output = 0;                                           \
+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))                \
+    {                                                                    \
+      size_directive_output = 1;                                         \
+      ASM_OUTPUT_SIZE_DIRECTIVE (STREAM, NAME,                           \
+                                 int_size_in_bytes (TREE_TYPE (DECL)));  \
+    }                                                                    \
+    ASM_OUTPUT_LABEL(STREAM, NAME);                                         \
+  } while (0)
+
+
+/*=============================================================================
+ -- Macro: ASM_FINISH_DECLARE_OBJECT (STREAM, DECL, TOPLEVEL, ATEND)
+     A C statement (sans semicolon) to finish up declaring a variable
+     name once the compiler has processed its initializer fully and thus
+     has had a chance to determine the size of an array when controlled
+     by an initializer.  This is used on systems where it's necessary to
+     declare something about the size of the object.
+=============================================================================*/
+#undef  ASM_FINISH_DECLARE_OBJECT
+#define ASM_FINISH_DECLARE_OBJECT(STREAM, DECL, TOPLEVEL, ATEND)  \
+  do                                                              \
+  {                                                               \
+    const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);       \
+    HOST_WIDE_INT size;                                           \
+    if ((!flag_inhibit_size_directive) &&                         \
+        (DECL_SIZE (DECL)) &&                                     \
+        (! ATEND) &&                                              \
+        (TOPLEVEL) &&                                             \
+        (DECL_INITIAL (DECL) == error_mark_node) &&               \
+        (!size_directive_output) &&                               \
+        ((size = int_size_in_bytes (TREE_TYPE (DECL))) > 0))      \
+    {                                                             \
+     size_directive_output = 1;                                   \
+     ASM_OUTPUT_SIZE_DIRECTIVE (STREAM, name, size);              \
+    }                                                             \
+  } while (0)
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_ASCII (STREAM, PTR, LEN)
+     A C statement to output to the stdio stream STREAM an assembler
+     instruction to assemble a string constant containing the LEN bytes
+     at PTR.  PTR will be a C expression of type 'char *' and LEN a C
+     expression of type 'int'.
+
+     If the assembler has a '.ascii' pseudo-op as found in the Berkeley
+     Unix assembler, do not define the macro 'ASM_OUTPUT_ASCII'.
+=============================================================================*/
+#undef  ASM_OUTPUT_ASCII
+#define ASM_OUTPUT_ASCII tms9900_output_ascii
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_DWARF_DELTA (STREAM, SIZE, LABEL1, LABEL2)
+     A C statement to issue assembly directives that create a difference
+     LAB1 minus LAB2, using an integer of the given SIZE.
+=============================================================================*/
+//#undef  ASM_OUTPUT_DWARF_DELTA
+//#define ASM_OUTPUT_DWARF_DELTA tms9900_asm_output_dwarf_delta
+
+
+/*=============================================================================
+ -- Macro: ASM_OUTPUT_DWARF_OFFSET (STREAM, SIZE, LABEL, OFFSET,
+          SECTION)
+     A C statement to issue assembly directives that create a
+     section-relative reference to the given LABEL plus OFFSET, using an
+     integer of the given SIZE.  The label is known to be defined in the
+     given SECTION.
+=============================================================================*/
+//#undef  ASM_OUTPUT_DWARF_OFFSET
+//#define ASM_OUTPUT_DWARF_OFFSET tms9900_asm_output_dwarf_offset
+
+
+/*=============================================================================
+ -- Macro: CONSTANT_ADDRESS_P (X)
+     A C expression that is 1 if the RTX X is a constant which is a
+     valid address.  On most machines the default definition of
+     '(CONSTANT_P (X) && GET_CODE (X) != CONST_DOUBLE)' is acceptable,
+     but a few machines are more restrictive as to which constant
+     addresses are supported.
+=============================================================================*/
+#undef  CONSTANT_ADDRESS_P
+#define CONSTANT_ADDRESS_P  tms9900_constant_address_p
+
+
+/*=============================================================================
+ -- Macro: INIT_CUMULATIVE_ARGS (CUM, FNTYPE, LIBNAME, FNDECL,
+                                 N_NAMED_ARGS)
+     A C statement (sans semicolon) for initializing the variable CUM
+     for the state at the beginning of the argument list.  The variable
+     has type 'CUMULATIVE_ARGS'.  The value of FNTYPE is the tree node
+     for the data type of the function which will receive the args, or 0
+     if the args are to a compiler support library function.  For direct
+     calls that are not libcalls, FNDECL contain the declaration node of
+     the function.  FNDECL is also set when 'INIT_CUMULATIVE_ARGS' is
+     used to find arguments for the function being compiled.
+     N_NAMED_ARGS is set to the number of named arguments, including a
+     structure return address if it is passed as a parameter, when
+     making a call.  When processing incoming arguments, N_NAMED_ARGS is
+     set to -1.
+=============================================================================*/
+#undef  INIT_CUMULATIVE_ARGS
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS)  \
+  tms9900_init_cumulative_args (& (CUM))
+
+
+/*=============================================================================
+ -- Macro: INITIAL_ELIMINATION_OFFSET (FROM-REG, TO-REG, OFFSET-VAR)
+     This macro returns the initial difference between the specified
+     pair of registers.  The value would be computed from information
+     such as the result of 'get_frame_size ()' and the tables of
+     registers 'df_regs_ever_live_p' and 'call_used_regs'.
+=============================================================================*/
+#undef  INITIAL_ELIMINATION_OFFSET
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
+  ((OFFSET) = tms9900_initial_elimination_offset ((FROM), (TO)))
+
+
+/*=============================================================================
+ -- Macro: EH_RETURN_DATA_REGNO (N)
+     A C expression whose value is the Nth register number used for data
+     by exception handlers, or 'INVALID_REGNUM' if fewer than N
+     registers are usable.
+=============================================================================*/
+#undef EH_RETURN_DATA_REGNO
+#define EH_RETURN_DATA_REGNO(N) \
+  ((N) < 4 ? (N) + HARD_R1_REGNUM : INVALID_REGNUM)
+
+
+#undef EH_RETURN_HANDLER_RTX
+#define EH_RETURN_HANDLER_RTX \
+  gen_rtx_MEM (Pmode, plus_constant (HImode, stack_pointer_rtx, \
+				     crtl->outgoing_args_size))
+
+/*=============================================================================
+ -- Target Hook: int TARGET_ADDRESS_COST (rtx ADDRESS, machine_mode
+          MODE, addr_space_t AS, bool SPEED)
+     This hook computes the cost of an addressing mode that contains
+     ADDRESS.  If not defined, the cost is computed from the ADDRESS
+     expression and the 'TARGET_RTX_COST' hook.
+=============================================================================*/
+#undef  TARGET_ADDRESS_COST
+#define TARGET_ADDRESS_COST tms9900_address_cost
+
+
+/*============================================================================
+ -- Target Hook: unsigned int TARGET_FLAGS_REGNUM
+     If the target has a dedicated flags register, and it needs to use
+     the post-reload comparison elimination pass, or the delay slot
+     filler pass, then this value should be set appropriately.
+=============================================================================*/
+#undef  TARGET_FLAGS_REGNUM
+#define TARGET_FLAGS_REGNUM HARD_CC_REGNUM
+
+#endif
+
diff -rupN gcc-12.1.0-original/gcc/config/tms9900/tms9900.md gcc-12.1.0/gcc/config/tms9900/tms9900.md
--- gcc-12.1.0-original/gcc/config/tms9900/tms9900.md	1969-12-31 19:00:00.000000000 -0500
+++ gcc-12.1.0/gcc/config/tms9900/tms9900.md	2024-03-13 00:00:04.698224896 -0400
@@ -0,0 +1,1002 @@
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+
+(include "predicates.md")
+(include "constraints.md")
+
+
+;; SI is 32 bit
+;; HI is 16 bit
+;; QI is 8 bit
+
+
+;; Put most specific and/or optimized patterns first
+
+;; future instructions
+;;   udivmodM4
+;;   parityM2
+;;   one_cmplM1
+;;   cbranchMODE4
+;;   call_value
+;;
+;;   addM3
+;;   subM3
+;;   mulM3
+;;   divM3
+;;   udivM3
+;;   modM3
+;;   umodM3
+;;   andM3
+;;   orM3
+;;   xorM3
+;;   mulhisi3
+;;   mulqihi3
+;;   mulsidi3
+;;   umulqisi3
+;;   umulhisi3
+;;   umulsidi3
+;;   smulM3_highpart
+;;   umulM3_highpart
+;;   divmodM4
+;;   udivmodM4
+;;   ashlM3
+;;   ashrM3
+;;   LshrM3
+;;   rotlM3
+;;   rotrM3
+;;   bswapM2
+;;   negM2
+;;   absM2
+;;   call
+;;   nop
+;;   indirect_jump
+;;   casesi
+;;   tablejump
+;;   sibcall_epilogue
+;;
+;;   put widest optional modes before narrower modes
+
+
+;;=============================================================================
+;;  Description of class IDs
+;;  Constant integer constraints.
+;;    'I' is for 32-bit value xxxx0000
+;;    'J' is for 32-bit value 0000xxxx
+;;    'K' is for 32-bit value xxxxxxxx
+;;    'L' is for 2 or -2
+;;    'M' is for -1
+;;    'N' is for 1
+;;    'O' is for 0
+;;    'P' is for 00FF
+;;
+;;  Memory addressing constraints.
+;;    'Q' is for memory references that require an extra word after the opcode.
+;;    'R' is for memory references which are encoded within the opcode.
+;;
+;;  Register constraints.
+;;    'B' is for full-width registers
+;;    'C' is for R12, the CRU base register
+;;    'S' is for R0, the shift count register
+;;
+;;=============================================================================
+
+
+;;=============================================================================
+;;  UNSPEC Definitions
+;;=============================================================================
+(define_constants [
+  (CC_REGNUM      16)
+  (JUMP_MAX       256)
+  (JUMP_MIN      -252)
+  (UNSPEC_RETURN  0)
+  ])
+
+
+;;=============================================================================
+;;  Attribute Definitions
+;;=============================================================================
+
+;; Attributes for user assembly blocks
+;; We can't know the true length, so assume something big
+(define_asm_attributes [
+  (set_attr "length" "256")
+  ])
+
+;; Length default is 1 word each
+(define_attr "length" "" (const_int 1))
+
+
+;;=============================================================================
+;;  Substitution Definitions
+;;=============================================================================
+
+(define_subst "cc_set"
+  [(set (match_operand 0 "") (match_operand 1 ""))
+   (clobber (reg CC_REGNUM))]
+  ""
+  [(set (reg:CC CC_REGNUM)
+        (compare:CC (match_dup 1) (const_int 0)))
+   (set (match_dup 0) (match_dup 1))]
+)
+
+
+(define_subst_attr "cc_set" "cc_set" "" "_cc_set")
+(define_mode_iterator REGint [QI HI])
+
+
+;;=============================================================================
+;;  Function Calls
+;;=============================================================================
+
+
+;;-----------------------------------------------------------------------------
+;; Jump to a subroutine which does not return a value
+(define_insn "call"
+  [(call (match_operand:HI 0 "move_operand" "R,Q")
+         (match_operand:HI 1 "move_operand" "g,g"))
+  ]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, -CALL));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, -CALL)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+;; Jump to a subroutine which returns a value
+(define_insn "call_value"
+  [(set (match_operand 0 "" "")
+        (call (match_operand:HI 1 "move_operand" "R,Q")
+              (match_operand:HI 2 "move_operand" "g,g")))
+  ]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, CALL));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, CALL)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+;; Define function prologue
+(define_expand "prologue"
+  [(const_int 0)]
+  ""
+{
+  tms9900_expand_prologue();
+  DONE;
+})
+
+
+;;-----------------------------------------------------------------------------
+;; Define function epilogue
+(define_expand "epilogue"
+  [(const_int 0)]
+  ""
+{
+  tms9900_expand_epilogue(false);
+  DONE;
+})
+
+
+;;-----------------------------------------------------------------------------
+;; Define function epilogue for tail calls
+(define_expand "sibcall_epilogue"
+  [(const_int 0)]
+  ""
+{
+  tms9900_expand_epilogue(true);
+  DONE;
+})
+
+
+;;-----------------------------------------------------------------------------
+;; Define function return
+(define_insn "*rt"
+  [(unspec [(match_operand:HI 0 "move_operand" "")] UNSPEC_RETURN)]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, RETURN));
+  }
+)
+
+
+;;=============================================================================
+;; Test Instructions
+;;=============================================================================
+
+(define_insn "*compare<mode>"
+  [(set (reg:CC CC_REGNUM)
+        (compare:CC (match_operand:REGint 0 "nonimmediate_operand" "")
+                    (match_operand:REGint 1 "move_operand" "")))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, COMPARE));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, COMPARE)"))]
+)
+
+
+;;=============================================================================
+;; Branch Instructions
+;; need to test
+;;=============================================================================
+
+
+;;-----------------------------------------------------------------------------
+(define_insn_and_split "cbranch<mode>4"
+  [(set (pc)
+        (if_then_else (match_operator 0 "ordered_comparison_operator"
+                       [(match_operand:REGint 1 "nonimmediate_operand" "rR>Q")
+                        (match_operand:REGint 2 "move_operand" "rR>Qi")])
+                      (label_ref (match_operand 3 "" ""))
+                      (pc)))]
+  ""
+  "#"
+  "reload_completed"
+  [(set (reg:CC CC_REGNUM)
+        (compare:CC (match_dup 1) (match_dup 2)))
+   (set (pc)
+        (if_then_else (match_op_dup 0
+                      [(reg:CC CC_REGNUM) (const_int 0)])
+                      (label_ref (match_dup 3))
+                      (pc)))]
+  "")
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "*branch"
+  [(set (pc)
+        (if_then_else (match_operator 0 "comparison_operator"
+                       [(reg:CC CC_REGNUM) (const_int 0)])
+                      (label_ref (match_operand 1 "" ""))
+                      (pc)))]
+  "reload_completed"
+  {
+    return (tms9900_define_insn (insn, operands, EQ));
+  }
+;;  [(set (attr "length")
+;;        (symbol_ref "tms9900_insn_length (insn, operands, EQ)"))]
+
+
+  [(set (attr "length")
+    (if_then_else
+      (ior (lt (minus (match_dup 1)
+                      (pc))
+               (const_int JUMP_MIN))
+           (gt (minus (match_dup 1)
+                      (pc))
+               (const_int JUMP_MAX)))
+      (if_then_else
+        (match_test "((GET_CODE (operands[0]) == LT) ||
+                      (GET_CODE (operands[0]) == GTU))")
+        (const_int 8)
+        (const_int 6))
+      (if_then_else
+        (match_test "((GET_CODE (operands[0]) == GE) ||
+                      (GET_CODE (operands[0]) == LEU))")
+        (const_int 4)
+        (const_int 2))
+   ))]
+)
+
+
+;;=============================================================================
+;;  Jump Operations
+;; need to test
+;;=============================================================================
+
+
+;;=============================================================================
+;; Unconditional jump to label
+(define_insn "jump"
+  [(set (pc)
+        (label_ref (match_operand 0 "" "")))]
+  ""
+  "*
+  return tms9900_output_jump(get_attr_length(insn));"
+
+  [(set (attr "length") (if_then_else (ior (le (minus (match_dup 0)
+                                                      (pc))
+                                               (const_int JUMP_MIN))
+                                           (ge (minus (match_dup 0)
+                                                      (pc))
+                                               (const_int JUMP_MAX)))
+                                      (const_int 4)
+                                      (const_int 2)))])
+
+
+;;-----------------------------------------------------------------------------
+;; Unconditional jump using pointer
+(define_insn "indirect_jump"
+  [(set (pc)
+        (match_operand:HI 0 "nonimmediate_operand" "r,Q"))]
+  ""
+  "b    %0"
+  [(set_attr "length" "2,4")])
+
+
+;;-----------------------------------------------------------------------------
+;; Unconditional jump using jump table
+(define_insn "tablejump"
+  [(clobber (match_scratch:HI 2 "=r,r"))
+   (set (pc)
+        (match_operand:HI 0 "nonimmediate_operand" "rR,Q"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  {
+    output_asm_insn("mov  %0, %2", operands);
+    output_asm_insn("b    *%2",    operands);
+    return("");
+  }
+  [(set_attr "length" "4,6")])
+
+
+;;=============================================================================
+;;  Bit Shift Operations
+;;=============================================================================
+
+
+;;=============================================================================
+;; Arithmetic shift left
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "ashlsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ashift:SI (match_operand:SI 1 "register_operand" "0,0")
+                   (match_operand:HI 2 "shift_count_operand" "S,i")))
+   (clobber (match_scratch:HI 3 "=&r,&r"))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, ASHIFT));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, ASHIFT)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+;;        (ashift:REGint (match_operand:REGint 1 "register_operand" "0,0")
+(define_insn "ashl<mode>3<cc_set>"
+  [(set (match_operand:REGint 0 "register_operand" "=r,r")
+        (ashift:REGint (match_operand:REGint 1 "move_operand" "rR>Q,rR>Q")
+                       (match_operand:HI 2 "shift_count_operand" "S,i")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, ASHIFT));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, ASHIFT)"))]
+)
+
+
+;;=============================================================================
+;; Arithmetic shift right
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "ashrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ashiftrt:SI (match_operand:SI 1 "register_operand" "0,0")
+                     (match_operand:HI 2 "shift_count_operand" "S,i")))
+   (clobber (match_scratch:HI 3 "=&r,&r"))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, ASHIFTRT));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, ASHIFTRT)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+;;        (ashiftrt:REGint (match_operand:REGint 1 "register_operand" "0,0")
+(define_insn "ashr<mode>3<cc_set>"
+  [(set (match_operand:REGint 0 "register_operand" "=r,r")
+        (ashiftrt:REGint (match_operand:REGint 1 "move_operand" "rR>Q,rR>Q")
+                         (match_operand:HI 2 "shift_count_operand" "S,i")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, ASHIFTRT));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, ASHIFTRT)"))]
+)
+
+
+;;=============================================================================
+;; Logical shift right
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "lshrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (lshiftrt:SI (match_operand:SI 1 "register_operand" "0,0")
+                     (match_operand:HI 2 "shift_count_operand" "S,i")))
+   (clobber (match_scratch:HI 3 "=&r,&r"))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, LSHIFTRT));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, LSHIFTRT)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+;;        (lshiftrt:REGint (match_operand:REGint 1 "register_operand" "0,0")
+(define_insn "lshr<mode>3<cc_set>"
+  [(set (match_operand:REGint 0 "register_operand" "=r,r")
+        (lshiftrt:REGint (match_operand:REGint 1 "move_operand" "rR>Q,rR>Q")
+                         (match_operand:HI 2 "shift_count_operand" "S,i")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, LSHIFTRT));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, LSHIFTRT)"))]
+)
+
+
+;;=============================================================================
+;; Rotate
+
+(define_insn "rotrhi3<cc_set>"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+        (rotatert:HI (match_operand:HI 1 "register_operand" "0,0")
+                     (match_operand:HI 2 "shift_count_operand" "+S,i")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, ROTATERT));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, ROTATERT)"))]
+)
+
+
+;;=============================================================================
+;;  Bitwise Operations
+;; need to test
+;;=============================================================================
+
+
+;;=============================================================================
+;; And
+
+(define_insn "and<mode>3<cc_set>"
+  [(clobber (match_scratch:REGint 3 "=r"))
+   (set (match_operand:REGint 0 "nonimmediate_operand" "=rR>Q")
+        (and:REGint (match_operand:REGint 1 "nonimmediate_operand" "%0")
+                    (match_operand:REGint 2 "nonimmediate_operand" "rR>Q")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, AND));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, AND)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "*andi<mode>3<cc_set>"
+  [(set (match_operand:REGint 0 "nonimmediate_operand" "=rR>Q")
+        (and:REGint (match_operand:REGint 1 "nonimmediate_operand" "%0")
+                    (match_operand:REGint 2 "immediate_operand" "i")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, -AND));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, -AND)"))]
+)
+
+
+;;=============================================================================
+;; Or
+
+(define_insn "ior<mode>3<cc_set>"
+  [(set (match_operand:REGint 0 "nonimmediate_operand" "=rR>Q")
+        (ior:REGint (match_operand:REGint 1 "nonimmediate_operand" "%0")
+                    (match_operand:REGint 2 "move_operand" "rR>Qi")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, IOR));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, IOR)"))]
+)
+
+
+;;=============================================================================
+;; Xor
+
+(define_insn "xor<mode>3<cc_set>"
+  [(set (match_operand:REGint 0 "register_operand" "=r,r")
+        (xor:REGint (match_operand:REGint 1 "register_operand" "%0,0")
+                    (match_operand:REGint 2 "nonimmediate_operand" "rR>,Q")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, XOR));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, XOR)"))]
+)
+
+
+;;=============================================================================
+;; Not
+
+(define_insn "one_cmpl<mode>2<cc_set>"
+  [(set (match_operand:REGint 0 "nonimmediate_operand" "=rR>,Q")
+        (not:REGint (match_operand:REGint 1 "nonimmediate_operand" "0,0")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, NOT));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, NOT)"))]
+)
+
+
+;;=============================================================================
+;;  Arithmetic Operations
+;; need to test
+;;=============================================================================
+
+
+;;=============================================================================
+;; Add
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "addsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR>Q")
+        (plus:SI (match_operand:SI 1 "nonimmediate_operand" "rR>Q")
+                 (match_operand:SI 2 "move_operand" "rR>Qi")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, PLUS));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, PLUS)"))]
+)
+
+
+(define_insn "add<mode>3<cc_set>"
+  [(set (match_operand:REGint 0 "nonimmediate_operand" "=rR>Q")
+        (plus:REGint (match_operand:REGint 1 "nonimmediate_operand" "rR>Q")
+                     (match_operand:REGint 2 "move_operand" "rR>Qi")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, PLUS));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, PLUS)"))]
+)
+
+
+;;=============================================================================
+;; Subtract
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "subsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR>Q")
+        (minus:SI (match_operand:SI 1 "nonimmediate_operand" "0")
+                  (match_operand:SI 2 "move_operand" "rR>Qi")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, MINUS));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, MINUS)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "sub<mode>3<cc_set>"
+  [(set (match_operand:REGint 0 "nonimmediate_operand" "=rR>Q")
+        (minus:REGint (match_operand:REGint 1 "nonimmediate_operand" "0")
+                      (match_operand:REGint 2 "subtrahend_operand" "rR>Qi")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, MINUS));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, MINUS)"))]
+)
+
+
+;;=============================================================================
+;; Multiply
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "mulsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
+        (mult:SI (match_operand:SI 1 "register_operand" "0,0,0")
+                 (match_operand:SI 2 "nonimmediate_operand"  "r,R,Q")))
+   (clobber (match_scratch:HI 3 "=r,r,r"))
+   (clobber (match_scratch:HI 4 "=r,r,r"))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, MULT));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, MULT)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "*do_mul"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (mult:SI (match_operand:HI 1 "register_operand" "%r,r")
+                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, MULT));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, MULT)"))]
+)
+
+(define_expand "mulhi3"
+  [(set (match_dup 3)
+        (mult:SI (match_operand:HI 1 "register_operand" "%r,r")
+                 (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
+   (set (match_operand:HI 0 "register_operand" "=r,r")
+        (subreg:HI (match_dup 3) 2))]
+  ""
+  "operands[3] = force_reg(SImode, GEN_INT(0));"
+)
+
+
+;;=============================================================================
+;; Divide and Modulus
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "udivmodhi4"
+  [(parallel [
+     (set (match_operand:HI 0 "register_operand" "=r,r")
+          (udiv:HI (match_operand:SI 1 "register_operand" "0,0")
+                   (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
+     (set (match_operand:HI 3 "register_operand" "=r,r")
+          (mod:HI (match_dup 1)
+                  (match_dup 2)))])]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, UDIV));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, UDIV)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "divmodhi4"
+  [(parallel [
+     (clobber (match_scratch:HI 4 "+r,r"))
+     (clobber (match_scratch:SI 5 "+r,r"))
+     (set (match_operand:HI 0 "register_operand" "=r,r")
+          (div:HI (match_operand:HI 1 "register_operand" "0,0")
+                  (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
+     (set (match_operand:HI 3 "register_operand" "=r,r")
+          (mod:HI (match_dup 1)
+                  (match_dup 2)))])]
+  "reload_completed"
+  {
+    return (tms9900_define_insn (insn, operands, DIV));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, DIV)"))]
+)
+
+
+(define_insn "divmodhi4_hiqi"
+;;  [(parallel [
+;;     (clobber (match_scratch:HI 4 "+r,r"))
+;;     (clobber (match_scratch:SI 5 "+r,r"))
+;;     (set (match_operand:HI 0 "register_operand" "=r,r")
+;;          (div:HI (match_operand:HI 1 "register_operand" "0,0")
+;;                  (match_operand:QI 2 "nonimmediate_operand" "rR>,Q")))
+;;     (set (match_operand:HI 3 "register_operand" "=r,r")
+;;          (mod:HI (match_dup 1)
+;;                  (match_dup 2)))])]
+
+
+
+
+  [(parallel [
+     (clobber (match_scratch:HI 4 "+r,r"))
+     (clobber (match_scratch:SI 5 "+r,r"))
+     (set (match_operand:HI 0 "register_operand" "=r,r")
+          (div:HI (match_operand:HI 1 "register_operand" "0,0")
+                  (sign_extend:HI
+                               (match_operand:QI 2 "nonimmediate_operand" "rR>,Q"))
+))
+     (set (match_operand:HI 3 "register_operand" "=r,r")
+          (mod:HI (match_dup 1)
+(sign_extend:HI (match_dup 2))))
+])]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, DIV));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, DIV)"))]
+)
+
+;;-----------------------------------------------------------------------------
+(define_insn "udivmodsihi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ior:SI
+          (ashift:SI
+            (zero_extend:SI
+              (udiv:HI (match_operand:SI 1 "register_operand" "0,0")
+                       (match_operand:HI 2 "nonimmediate_operand" "rR>,Q")))
+            (const_int 16))
+          (zero_extend:SI
+            (mod:HI (match_dup 1)
+                    (match_dup 2)))))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, UDIV));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, UDIV)"))]
+)
+
+
+;;=============================================================================
+;; Absolute Value
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "abssi2"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR>,Q")
+        (abs:SI (match_operand:SI 1 "nonimmediate_operand" "0,0")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, ABS));
+  }
+)
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "abshi2<cc_set>"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>,Q")
+        (abs:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, ABS));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, ABS)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "absqi2<cc_set>"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (abs:QI (match_operand:HI 1 "register_operand" "0")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, ABS));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, ABS)"))]
+)
+
+
+;;=============================================================================
+;; Negate
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rR>Q")
+        (neg:SI (match_operand:SI 1 "nonimmediate_operand" "0")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, NEG));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, NEG)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "neghi2<cc_set>"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rR>Q")
+        (neg:HI (match_operand:HI 1 "nonimmediate_operand" "0")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, NEG));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, NEG)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "negqi2<cc_set>"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+        (neg:QI (match_operand:QI 1 "register_operand" "0")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, NEG));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, NEG)"))]
+)
+
+
+;;=============================================================================
+;;  Move Operations
+;;=============================================================================
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "movsi"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=rRQ>")
+        (match_operand:SI 1 "move_operand" "rRQ>i"))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, SET));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, SET)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "mov<mode><cc_set>"
+  [(set (match_operand:REGint 0 "nonimmediate_operand" "=rRQ>")
+        (match_operand:REGint 1 "move_operand" "rRQi>"))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, SET));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, SET)"))]
+)
+
+
+;;-----------------------------------------------------------------------------
+(define_insn "mov<mode>_no_cc"
+  [(set (match_operand:REGint 0 "nonimmediate_operand" "=rRQ>")
+        (match_operand:REGint 1 "move_operand" "rRQi>"))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, SET));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, SET)"))]
+)
+
+
+
+
+(define_insn "movsi2hi<cc_set>"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rRQ>")
+        (subreg:HI (match_operand:SI 1 "move_operand" "rRQ>i") 2))
+   (use (match_dup 1))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, SET));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, SET)"))]
+)
+
+
+;;=============================================================================
+;; Type Conversions
+;; need to test
+;;=============================================================================
+
+
+;;=============================================================================
+;; Zero Extend
+
+(define_insn "zero_extendqihi2<cc_set>"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (zero_extend:HI (match_operand:QI 1 "register_operand" "r")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, ZERO_EXTEND));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, ZERO_EXTEND)"))]
+)
+
+
+;;=============================================================================
+;; Sign Extend
+
+(define_insn "extendqihi2<cc_set>"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+        (sign_extend:HI (match_operand:QI 1 "register_operand" "r")))
+   (clobber (reg:CC CC_REGNUM))]
+  ""
+  {
+    return (tms9900_define_insn (insn, operands, SIGN_EXTEND));
+  }
+  [(set (attr "length")
+        (symbol_ref "tms9900_insn_length (insn, operands, SIGN_EXTEND)"))]
+)
+
+
+;;=============================================================================
+;; Other Instructions
+;; need to test
+;;=============================================================================
+
+
+;;=============================================================================
+;; No-op
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop"
+  [(set_attr "length" "2")])
+
+
+;;=============================================================================
+;;  Optimizations For Comparisons
+;;=============================================================================
+
+
+;;=============================================================================
+;;  Optimizations For Byte Compares
+;;=============================================================================
+
+
+;;=============================================================================
+;;  Optimizations For Bit Shift And Cast
+;;=============================================================================
+
+
diff -rupN gcc-12.1.0-original/gcc/config/tms9900/tms9900-protos.h gcc-12.1.0/gcc/config/tms9900/tms9900-protos.h
--- gcc-12.1.0-original/gcc/config/tms9900/tms9900-protos.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-12.1.0/gcc/config/tms9900/tms9900-protos.h	2024-03-13 00:00:04.698224896 -0400
@@ -0,0 +1,69 @@
+/* Definitions of target machine for GNU compiler, for the TMS9900
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+
+#ifndef GCC_TMS9900_PROTOS_H
+#define GCC_TMS9900_PROTOS_H
+
+#ifdef __cplusplus
+extern bool          tms9900_address_ok_for_letter      (rtx operand, char letter);
+extern void          tms9900_expand_epilogue            (bool is_sibcall);
+extern void          tms9900_expand_prologue            (void);
+extern pad_direction tms9900_function_arg_padding       (machine_mode mode, const_tree type);
+extern void          tms9900_init_cumulative_args       (CUMULATIVE_ARGS *cum);
+extern int           tms9900_initial_elimination_offset (int from, int to);
+extern int           tms9900_insn_length                (rtx_insn *insn, rtx *operands, int code);
+extern const char   *tms9900_output_branch              (rtx *operands, int length);
+extern const char   *tms9900_output_jump                (int length);
+extern char*         tms9900_define_insn                (rtx_insn *insn, rtx *operands, int code);
+
+void
+tms9900_output_ascii (FILE* stream,
+                      const char* ptr,
+                      int len);
+
+bool
+tms9900_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx address, bool strict ATTRIBUTE_UNUSED);
+
+
+//void
+//tms9900_asm_output_dwarf_delta (FILE *file,
+//                                int size,
+//                                const char *label1,
+//                                const char *label2);
+//
+//void
+//tms9900_asm_output_dwarf_offset (FILE *file,
+//                                 int size,
+//                                 const char * label,
+//                                 section *base);
+
+
+extern int
+tms9900_constant_address_p (rtx x);
+
+
+extern void
+tms9900_print_operand (FILE *file,
+                       rtx x,
+                       int code);
+
+#endif
+
+#endif
+
diff -rupN gcc-12.1.0-original/gcc/config.gcc gcc-12.1.0/gcc/config.gcc
--- gcc-12.1.0-original/gcc/config.gcc	2022-05-06 03:30:56.000000000 -0400
+++ gcc-12.1.0/gcc/config.gcc	2024-03-13 00:00:04.702224933 -0400
@@ -563,6 +563,8 @@ tilegx*-*-*)
 tilepro*-*-*)
 	cpu_type=tilepro
 	;;
+tms9900-*-*)
+	;;
 esac
 
 tm_file=${cpu_type}/${cpu_type}.h
@@ -3498,6 +3500,9 @@ tilepro*-*-linux*)
 	cxx_target_objs="${cxx_target_objs} tilepro-c.o"
 	extra_headers="feedback.h"
 	;;
+tms9900-*-*)
+	target_has_targetm_common="no"
+	;;
 v850-*-rtems*)
 	target_cpu_default="TARGET_CPU_generic"
 	tm_file="elfos.h v850/v850.h"
diff -rupN gcc-12.1.0-original/gcc/DEV-PHASE gcc-12.1.0/gcc/DEV-PHASE
--- gcc-12.1.0-original/gcc/DEV-PHASE	2022-05-06 03:30:56.000000000 -0400
+++ gcc-12.1.0/gcc/DEV-PHASE	2024-03-13 00:11:01.948387664 -0400
@@ -0,0 +1 @@
+TMS9900 patch 1.0
diff -rupN gcc-12.1.0-original/.gitignore gcc-12.1.0/.gitignore
--- gcc-12.1.0-original/.gitignore	2022-05-06 03:30:56.000000000 -0400
+++ gcc-12.1.0/.gitignore	2024-03-13 00:00:23.418400233 -0400
@@ -6,6 +6,7 @@
 *~
 .#*
 *#
+.*.swp
 
 *.flt
 *.gmo
@@ -22,7 +23,8 @@
 
 autom4te.cache
 config.cache
-config.h
+# GCC does not support in-tree builds, do not conceal a stray config.h:
+# config.h
 config.intl
 config.log
 config.status
diff -rupN gcc-12.1.0-original/libgcc/config/tms9900/lib1funcs.S gcc-12.1.0/libgcc/config/tms9900/lib1funcs.S
--- gcc-12.1.0-original/libgcc/config/tms9900/lib1funcs.S	1969-12-31 19:00:00.000000000 -0500
+++ gcc-12.1.0/libgcc/config/tms9900/lib1funcs.S	2024-03-13 00:00:09.582270640 -0400
@@ -0,0 +1,820 @@
+/******************************************************************************
+*                               __clzM2
+*******************************************************************************
+* Return the number of leading 0-bits in a value, starting at the most
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : r1 - Value to test
+*
+* Returns: r1 - Number of zero bits
+******************************************************************************/
+
+#ifdef L_clzqi2
+/*********************************************************/
+/*                     __clzqi2                          */
+/*********************************************************/
+  def __clzqi2
+__clzqi2:
+  movb r1, r2  /* Move value into position, set condition flags */
+  clr  r1      /* Set minimum bit count, flags unchanged */
+  jgt  do_clz  /* If val==0, return undefined, if val<0, MSB set, return 0*/
+  b    *r11
+do_clz:
+  b    @__clz
+#endif
+
+
+#ifdef L_clzhi2
+/*********************************************************/
+/*                     __clzhi2                          */
+/*********************************************************/
+  def __clzhi2
+__clzhi2:
+  mov  r1, r2  /* Move value into position, set condition flags */
+  clr  r1      /* Set minimum bit count, flags unchanged */
+  jgt  do_clz  /* If val==0, return undefined, if val<0, MSB set, return 0*/
+  b *r11
+do_clz:
+  b    @__clz
+#endif
+
+
+#ifdef L_clzsi2
+/*********************************************************/
+/*                     __clzsi2                          */
+/*********************************************************/
+  def __clzsi2
+__clzsi2:
+  mov  r1, r1   /* Test MSW for set bits */
+  jlt  ret_0    /* Upper bit of MSW set, return zero */
+  jgt  clz_msw  /* Count leading zeroes in MSW */
+
+clz_lsw:
+  li   r1, 16   /* MSW was zero, initialize count to 16 */
+  mov  r2, r2   /* Test bits in LSW */
+  jlt  ret_16   /* Upper bit of LSW set, return sisxteen */
+  jgt  do_clz   /* Count leading zeroes of LSW */
+
+ret_0:
+  clr  r1
+ret_16:
+  b    *r11
+
+clz_msw:
+  mov  r1, r2  /* Move MSW into test position */
+  clr  r1      /* Initialize count to zero */
+do_clz:
+  b    @__clz
+#endif
+
+
+#ifdef L_clz
+/******************************************************************************
+*                               __clz
+*******************************************************************************
+* Return the number of leading 0-bits in a 16-bit value, starting at the most 
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : R1 - Minimum posible bit count
+*          R2 - Value to test
+*
+* Returns: R1 - Number of zero bits
+*******************************************************************************/
+  def __clz
+/*
+* We will shift left until we find a set bit
+*
+* Example 1, zero leading bits:
+*   C Val   N
+*   - ----  -
+*   . 1000  0
+*
+* Example 2, one leading bit:
+*   C Val   N
+*   - ----  -
+*   . 0100  4
+*   1 00..  2->1
+*
+* Example 3, two leading bits:
+*   C Val   N
+*   - ----  -
+*   0 0010  4
+*   0 10..  2
+*
+* If we got here, there is at least one bit set in supplied value
+*/
+__clz:
+  inct r1      /* Assume two zero bits, double count implied bit */
+  sla  r2, 2   /* Move next two bits into test position, set flags */
+  joc  bottom  /* Upper test bit set, exit */
+  jgt  __clz   /* Upper and lower test bits clear, loop */
+  
+  /* Clean up after loop */
+  inc r1       /* If we got here, negate next instruction */
+bottom:
+  dec r1       /* No cleared bits in last test set, decrement count */
+
+  /* Bit count is in R1, exit */
+  b *r11
+#endif
+
+  
+/******************************************************************************
+*                               __ctzM2
+*******************************************************************************
+* Return the number of trailing 0-bits in a 16-bit value, starting at the least
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Number of zero bits
+******************************************************************************/
+
+#ifdef L_ctzqi2
+/*********************************************************/
+/*                     __ctzqi2                          */
+/*********************************************************/
+  def __ctzqi2
+__ctzqi2:
+  clr  r2
+  movb r1, r2  /* Move value to R2, clearing low bits */
+  jeq  bottom  /* If all bits clear, stop now, return zero */
+  li   r1, 8   /* Max possible zero bits */
+  b    @__ctz  /* Examine provided value */
+bottom:
+  b *r11
+#endif
+
+
+#ifdef L_ctzhi2
+/*********************************************************/
+/*                     __ctzhi2                          */
+/*********************************************************/
+  def __ctzhi2
+__ctzhi2:
+  mov r1, r2  /* Move value to R2, set condition flags */
+  jeq bottom  /* If all bits clear, stop now, return zero */
+  li  r1, 16  /* Max possible zero bits */
+  b   @__ctz  /* Examine provided value */
+bottom:
+  b *r11
+#endif
+
+
+#ifdef L_ctzsi2
+/*********************************************************/
+/*                     __ctzsi2                          */
+/*********************************************************/
+  def __ctzsi2
+__ctzsi2:
+  mov  r2, r2     /* Check low word for set bits */
+  jeq  lsw_clear 
+
+  /* There are set bits in the low word */
+  li   r1, 16     /* Maximum number of possible zero bits */
+  b    @__ctz     /* Examine provided value */
+
+  /* All bits clear in the low word, no need to test them */
+lsw_clear:
+  mov  r1, r2     /* Move high word into test position */
+  jeq  bottom     /* If all bits clear, stop now, return zero */
+  li   r1, 32     /* Maximum number of possible zero bits */
+  b    @__ctz     /* Examine provided value */
+
+bottom:
+  b *r11
+#endif
+
+
+#if L_ctz
+/******************************************************************************
+*                               __ctz
+*******************************************************************************
+* Return the number of trailing 0-bits in a 16-bit value, starting at the least 
+* significant bit position.  If the value is zero, the result is undefined.
+*
+* Inputs : R1 - Maximum posible bit count
+*          R2 - Value to test
+*
+* Returns: R1 - Number of zero bits
+******************************************************************************/
+  def __ctz
+
+/*
+* We will shift left until all leading set bits are shifted out of the value
+*
+* Exmaple 1, zero trailing bits:
+*   C Val   N
+*   - ----  -
+*   . 0001  4
+*   0 01..  2
+*   1 ....  0
+*
+* Exmaple 2, one trailing bit:
+*   C Val   N
+*   - ----  -
+*   . 0010  4
+*   0 10..  2
+*   0 ....  1
+*
+* Exmaple 3, two trailing bits:
+*   C Val   N
+*   - ----  -
+*   0 0100  4
+*   1 00..  2
+*/
+
+  /* Test loop, check two uppermost bits at a time */
+__ctz:
+  dect r1      /* Assume both bits are set */
+  sla  r2, 2   /* Shift two bits into test position */
+  jne  __ctz   /* Still have set bits, keep looping */
+
+  /* Correct for last two test bits */
+  joc  bottom  /* If carry bit set, lower test bit was set */
+  inc  r1      /* lower test bit was clear, increment bit count */
+bottom:
+  b *r11
+#endif
+
+
+/******************************************************************************
+*                               __ffsM2
+*******************************************************************************
+* Return the index of the least significant set bit in a value, or zero 
+* if the value is zero.  The least significant bit is index one.
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Index to lowest set bit
+******************************************************************************/
+
+
+#ifdef L_ffsqi2
+/*********************************************************/
+/*                     __ffsqi2                          */
+/*********************************************************/
+  def __ffsqi2
+__ffsqi2:
+  movb r1, r1     /* Check for zero value */
+  jeq  done       /* If so, exit now */
+  mov  r11, r3    /* Move return pointer, it won't be affected by next call */
+  bl   @__ctzqi2  /* Count trailing zero bits */
+  inc  r1         /* Least sig. bit is in position trailing_count +1 */
+  b    *r3        /* Return to caller */
+done:
+  clr  r1         /* Return zero value */
+  b    *r11
+#endif
+
+
+#ifdef L_ffshi2
+/*********************************************************/
+/*                     __ffshi2                          */
+/*********************************************************/
+  def __ffshi2
+__ffshi2:
+  mov r11, r3     /* Move return pointer, it won't be affected by next call */
+  mov r1, r1      /* Check for zero value */
+  jeq done        /* If so, exit now */
+  bl  @__ctzhi2   /* Count trailing zero bits */
+  inc r1          /* Least sig. bit is in position trailing_count +1 */
+done:
+  b   *r3         /* Return to caller */
+#endif
+
+
+#ifdef L_ffssi2
+/*********************************************************/
+/*                     __ffssi2                          */
+/*********************************************************/
+  def __ffssi2
+__ffssi2:
+  mov r11, r3     /* Move return pointer, it won't be affected by next call */
+  mov r1, r4
+  soc r2, r4      /* Check for zero value */
+  jeq done        /* If so, exit now */
+  bl  @__ctzsi2   /* Count trailing zero bits */
+  inc r1          /* Least sig. bit is in position trailing_count +1 */
+done:
+  b   *r3         /* Return to caller */
+  def __modsi3
+#endif
+
+
+#ifdef L_parity
+/******************************************************************************
+*                               __parityM2
+*******************************************************************************
+* Return the value zero if the number of bits set in the given value is even,
+* and the value one otherwise.
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Number of zero bits
+******************************************************************************/
+
+/* Test an 8-bit value */
+  def __parityqi2
+__parityqi2:
+  seto r3
+  jmp byte1
+
+/* Test a 16-bit value */
+  def __parityhi2
+__parityhi2:
+  clr r3
+  jmp byte2
+
+/* Test a 32-bit value */
+  def __paritysi2
+__paritysi2:
+  clr  r3
+  movb r2, r2
+  jop pre_byte3
+  inv r3
+pre_byte3:
+  swpb r2
+byte3:
+  movb r2, r2
+  jop byte2
+  inv r3
+byte2:
+  movb r1, r1
+  jop pre_byte1
+  inv r3
+pre_byte1:
+  swpb r1
+byte1:
+  movb r1, r1
+  jop done
+  inv r3
+done:
+  neg r3
+  mov r3, r1
+  bl *r11
+#endif
+
+
+/******************************************************************************
+*                               __popcountM2
+*******************************************************************************
+* Return the number of set bits in a value
+*
+* Inputs : R1 - Value to test
+*
+* Returns: R1 - Number of set bits
+******************************************************************************/
+
+
+#ifdef L_popcountqi2
+/*********************************************************/
+/*                   __popcountqi2                       */
+/*********************************************************/
+  def __popcountqi2
+__popcountqi2:
+  clr  r2           /* Clear lower unused bits */
+  movb r1, r2       /* Move value into test position */
+  clr  r1           /* Clear bit count */
+  b    @__popcount  /* Find set bit count */
+#endif
+
+
+#ifdef L_popcounthi2
+/*********************************************************/
+/*                   __popcounthi2                       */
+/*********************************************************/
+  def __popcounthi2
+__popcounthi2:
+  mov  r1, r2       /* Move value into test position */
+  clr  r1           /* Clear bit count */
+  b    @__popcount  /* Find set bit count */
+#endif
+
+
+#ifdef L_popcountsi2
+/*********************************************************/
+/*                   __popcountsi2                       */
+/*********************************************************/
+  def __popcountsi2
+__popcountsi2:
+  mov  r11, r4      /* Move Return value where it will be safe */
+  mov  r1, r3       /* Move MSW to safe position */
+  clr  r1           /* Clear bit count */
+  bl   @__popcount  /* Find LSW set bit count */
+  mov  r3, r2       /* Move MSW into test position */
+  bl   @__popcount  /* Find MSW set bit count */
+  b    *r4          /* Return to caller */
+#endif
+
+
+#ifdef L_popcount
+/******************************************************************************
+*                               __popcount
+*******************************************************************************
+* Return the number of set bits in a 16-bit value
+*
+* Inputs : R1 - Current bit count
+*          R2 - Value to test
+*
+* Returns: R1 - Number of set bits
+******************************************************************************/
+  def __popcount
+__popcount:
+  mov  r2,r2   /* Check for zero value */  
+  jeq  done    /* If zero, exit now */
+top:
+  inc  r1      /* Increment bit count */
+  mov  r2, r0  /* \                           */
+  neg  r0      /* | Equvilent to r2 &= (r2-1) */
+  szc  r0, r2  /* /                           */
+  jne  top     /* Keep looping until all bits counted */
+done:
+  b    *r11    /* Return to caller */
+#endif
+
+
+#ifdef L_divmodsi3
+/******************************************************************************
+*                               __divmodsi3
+*******************************************************************************
+* Calculate the signed quotient and modulus of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*           R5     - Address for modulus
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __divmodsi3
+__divmodsi3:
+  /* Save modulo addess */
+  mov  r5, @-6(r10)
+
+  /* Save return register */
+  mov  r11, @-2(r10)
+  bl   @__divmodstart
+
+  /* Caclulate result */
+calc:
+  bl   @__udivmod32
+
+  /* Negate modulus if needed */
+  mov  @-4(r10), r0
+  jlt  savemod
+  inv  r3
+  neg  r4
+  jnc  savemod
+  inc  r3
+  
+  /* Save modulus */
+savemod:
+  mov  @-6(r10), r0
+  mov  r3, *r0
+  mov  r4, *r0+
+
+  /* Complete operatons */
+  b    @__divmodend
+#endif
+
+
+#ifdef L_divsi3
+/******************************************************************************
+*                               __divsi3
+*******************************************************************************
+* Calculate the signed quotient of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __divsi3
+__divsi3:
+  /* Save return register */
+  mov  r11, @-2(r10)
+  bl   @__divmodstart
+
+  /* Caclulate result */
+calc:
+  bl   @__udivmod32
+  b    @__divmodend
+#endif
+
+
+#ifdef L_modsi3
+/******************************************************************************
+*                               __modsi3
+*******************************************************************************
+* Calculate the signed modulus of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit modulus
+******************************************************************************/
+  def __modsi3
+__modsi3:
+  /* Save return register */
+  mov  r11, @-2(r10)
+  bl   @__divmodstart
+
+  /* Caclulate result */
+calc:
+  bl   @__udivmod32
+  mov  r3, r1
+  mov  r4, r2
+  b    @__divmodend
+#endif
+
+
+#ifdef L_divmod_common
+/******************************************************************************
+*                               __divmodstart
+*******************************************************************************
+* Common code for the start of all signed division and modulo calculations
+*
+* Inputs:  [R1,R2] - Signed 32-bit numerator
+*          [R3,R4] - Signed 32-bit denominator
+*
+* Returns: [R1,R2] - Positive 32-bit quotient
+*          [R3,R4] - Positive 32-bit denominator
+*          sp-4    - Sign of result
+******************************************************************************/
+  def __divmodstart
+__divmodstart:
+  /* Make numerator positive */
+  mov  r1, r5
+  jlt  negnum
+  jmp  testden
+negnum:
+  inv  r1
+  neg  r2
+  jnc  testden
+  inc  r1
+
+  /* Make denominator positive */
+testden:
+  xor  r3, r5
+  mov  r5, @-4(r10)
+  mov  r3, r3
+  jlt  negden
+  jmp  done
+negden:
+  inv  r3
+  neg  r4
+  jnc  done
+  inc  r3
+done:
+  b    *r11
+
+
+/******************************************************************************
+*                               __divmodend
+*******************************************************************************
+* Common code for the end of all signed division and modulo calculations
+*
+* Inputs:  [R1,R2] - Positive 32-bit quotient
+*          [R3,R4] - Positive 32-bit denominator
+*          sp-2    - Return pointer
+*          sp-4    - Sign of result
+*          
+* Returns: [R1,R2] - Signed 32-bit result
+******************************************************************************/
+  def __divmodend
+__divmodend:
+  /* Restore return register */
+  mov  @-2(r10), r11
+
+  /* Do we need to negate the result? */
+  mov  @-4(r10), r0
+  jlt  makeneg  
+  b    *r11        # Nope, exit now
+
+  /* Negate result and return */
+makeneg:  
+  inv  r1
+  neg  r2
+  jnc  jmp1
+  inc  r1
+jmp1:
+  b    *r11
+#endif
+
+
+#ifdef L_udivmodsi3
+/******************************************************************************
+*                             __udivmodsi3
+*******************************************************************************
+* Calculate the unsigned quotient and remainder of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*           R5     - Address to place 32-bit remainder
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __udivmodsi3
+__udivmodsi3:
+  /* Save pointer and return address */
+  mov  r5,  @-2(r10)
+  mov  r11, @-4(r10)
+
+  /* Do some math */
+  bl   @__udivmodsi
+  
+  /* Save remainder */
+  mov  @-2(r10), r0
+  mov  r3, *r0+
+  mov  r4, *r0
+  mov  @-4(r10), r11
+  b    *r11
+#endif
+
+
+#ifdef L_udivsi3
+/******************************************************************************
+*                               __udivsi3
+*******************************************************************************
+* Calculate the unsigned quotient of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit quotient
+******************************************************************************/
+  def __udivsi3
+__udivsi3:
+  /* Fall through to next routine */
+
+
+/******************************************************************************
+*                               __udivmod32
+*******************************************************************************
+* Calculate the unsigned quotient and remainder of the two values provided.
+* This is used by all the 32-bit division and modulus functions.
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit quotient
+*          [R3,R4] - 32-bit remainder
+******************************************************************************/
+  def __udivmod32
+__udivmod32:
+  /* Check size of denominator */
+  mov  r3, r3      /* Is the upper word of denominator used? */
+  jne  den32       /* If so, jump to 32-bit code */
+
+  /* Handle 16-bit denominator */
+  /* Zero extend numerator */
+  clr  r0
+  mov  r1, r1
+  jeq  num16       /* If numerator is only 16 bits, skip the first DIV */
+
+  /* Perform calculation */
+  div  r4, r0
+num16:
+  div  r4, r1
+
+  /* Move results into return position */
+  mov  r2, r4      /* LSW of remainder */
+                   /* MSW of remainder still zero */
+  mov  r1, r2      /* LSW of result */
+  mov  r0, r1      /* MSW of result */
+  b    *r11
+
+den32:
+  /*
+  * Handle 32-bit denominator
+  *
+  *      A1*N + A1
+  * Q = ---------
+  *      B1*N + B2
+  *
+  * N = 0x10000
+  *
+  * Divide top and bottom by 2*B1 to make the denominator a 16-bit quantity
+  *
+  *        A1*N + A2
+  *       ---------
+  *          2*B1
+  * Q = ---------------
+  *        N     B2
+  *       --- + ---
+  *        2    2*B1
+  *
+  * This will result in some rounding error which must be corrected for.
+  * We will call the approximate value P, and the rounding error E. 
+  *
+  * Q - P = E
+  *
+  * Analysis of the error shows that E must be either 0 or -1. We will calculate
+  * the remainder to determine E and so correct P.
+  *
+  * R = (A1*N + A2) - P*(B1*N + B2)
+  *
+  * If R is negative, P is too large by one and we will apply the correction.
+  * Otherwise, P is correct and we can use the value directly.
+  */
+
+  /* Move arguments into test position */
+  mov  r1, r0      /* [r0,r12] <- [A1,A2] = numerator */
+  mov  r2, r12
+
+  mov  r3, r7      /* [r7,r8] <- [B1,B2] = deominator */
+  mov  r4, r8
+
+  /* Calculate V = (N/2 + B2/(2*B1)) */
+  clr  r1          /* [r1,r2] <- [C1,C2] = B2/2 */
+  mov  r8, r2
+  srl  r2, 1
+
+  div  r7, r1      /* r1 <- v = [C1,C2]/B1 */
+  ai   r1, 0x8000  /* v += 0x8000 */
+
+  /* Calculate U = (A1*N + A2)/(2*B1) */
+  mov  r0, r2      /* [r2,r3] <- [U1,U2] = [A1,A2] */
+  mov  r12, r3
+
+  srl  r2, 1       /* [U1,U2] = [A1,A2]/2 */
+  srl  r3, 1
+  jnc  jmp1
+  ori  r3, 0x8000
+jmp1:
+
+  clr  r4          /* [U1,U2] = [U1,U2]/B1 */
+  mov  r2, r5
+  div  r7, r4
+  mov  r3, r6
+  div  r7, r5
+  mov  r4, r2
+  mov  r5, r3
+
+  div  r1, r2      /* r2 <- P = [U1,U2]/V */
+
+  /* Calculate remainder  [m1,m2]=[a1,a2]-[b1,b2]*p */
+  mov  r7, r3      /* [r3,r4] <- [U1,U2] = B1*p */
+  mpy  r2, r3
+
+  mov  r8, r5      /* [r5,r6] <- [D1,D2] = B2*P */
+  mpy  r2, r5
+
+  a    r4, r5      /* [D1,D2] += [U2,0] */
+
+  mov  r0, r3      /* [M1,M2] = [A1,A2] */
+  mov  r12, r4
+
+  s    r5, r3      /* [M1,M2] -= [D1,D2] */
+  s    r6, r4
+  joc  jmp2
+  dec  r3
+jmp2:
+
+  /*
+  * Results now in return position, prepare for exit
+  *   [r1,r2] <- quotient
+  *   [r3,r4] <- remainder
+  */
+  clr  r1          /* Set upper word of quotient, we know it will be zero */
+  mov  r3, r3      /* if(remainder >= 0) P is correct */
+  jlt  jmp3
+  b    *r11
+jmp3:
+
+  /* Correct result for rounding error */
+  dec  r2          /* P -= 1 */
+
+  /* Correct remainder for rounding error */
+  a    r7, r3      /* [M1,M2] += [B1,B2] */
+  a    r8, r4
+  jnc  jmp4
+  inc  r3
+jmp4:
+
+  /* Return value */
+  b    *r11
+#endif
+
+
+#ifdef L_umodsi3
+/******************************************************************************
+*                               __umodsi3
+*******************************************************************************
+* Calculate the unsigned modulus of the two values provided
+*
+* Inputs:  [R1,R2] - 32-bit numerator
+*          [R3,R4] - 32-bit denominator
+*
+* Returns: [R1,R2] - 32-bit modulus
+******************************************************************************/
+  def __umodsi3
+__umodsi3:
+  mov  r11, @-2(r10)
+  bl   @__udivmod32
+  mov  r3, r1
+  mov  r4, r2
+  mov  @-2(r10), r11
+  b    *r11
+#endif
+
diff -rupN gcc-12.1.0-original/libgcc/config/tms9900/t-tms9900 gcc-12.1.0/libgcc/config/tms9900/t-tms9900
--- gcc-12.1.0-original/libgcc/config/tms9900/t-tms9900	1969-12-31 19:00:00.000000000 -0500
+++ gcc-12.1.0/libgcc/config/tms9900/t-tms9900	2024-03-13 00:00:09.582270640 -0400
@@ -0,0 +1,9 @@
+LIB1ASMSRC = tms9900/lib1funcs.S
+LIB1ASMFUNCS = _clzqi2 _clzhi2 _clzsi2 _clz\
+               _ctzqi2 _ctzhi2 _ctzsi2 _ctz\
+               _ffsqi2 _ffshi2 _ffssi2\
+               _parityqi2 _parityhi2 _paritysi2 _parity\
+               _popcountqi2 _popcounthi2 _popcountsi2 _popcount\
+               _udivmodsi3 _udivsi3 _umodsi3\
+               _divmodsi3 _modsi3 _divsi3 _divmod_common
+
diff -rupN gcc-12.1.0-original/libgcc/config.host gcc-12.1.0/libgcc/config.host
--- gcc-12.1.0-original/libgcc/config.host	2022-05-06 03:30:59.000000000 -0400
+++ gcc-12.1.0/libgcc/config.host	2024-03-13 00:00:08.990265095 -0400
@@ -224,6 +224,9 @@ v850*-*-*)
 tic6x-*-*)
 	cpu_type=c6x
 	;;
+tms9900-*-*)
+	cpu_type=tms9900
+	;;
 esac
 
 # Common parts for widely ported systems.
@@ -1492,6 +1495,9 @@ tilepro*-*-linux*)
 	tmake_file="${tmake_file} tilepro/t-crtstuff t-softfp-sfdf t-softfp tilepro/t-tilepro t-slibgcc-libgcc"
 	md_unwind_header=tilepro/linux-unwind.h
         ;;
+tms9900*)
+	tmake_file="$tmake_file tms9900/t-tms9900"
+	;;
 v850*-*-*)
 	tmake_file="${tmake_file} v850/t-v850 t-fdpbit"
 	;;
