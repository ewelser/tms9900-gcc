diff -rupN binutils-2.40-original/bfd/archures.c binutils-2.40/bfd/archures.c
--- binutils-2.40-original/bfd/archures.c	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/bfd/archures.c	2024-03-10 16:38:19.689164511 -0400
@@ -563,6 +563,8 @@ DESCRIPTION
 .#define bfd_mach_amdgcn_gfx1030 0x036
 .#define bfd_mach_amdgcn_gfx1031 0x037
 .#define bfd_mach_amdgcn_gfx1032 0x038
+.  bfd_arch_tms9900,   {* Texas Instruments TMS9900 architecture.  *}
+.#define bfd_mach_tms9900       1
 .  bfd_arch_last
 .  };
 */
@@ -688,6 +690,7 @@ extern const bfd_arch_info_type bfd_tic5
 extern const bfd_arch_info_type bfd_tic6x_arch;
 extern const bfd_arch_info_type bfd_tilegx_arch;
 extern const bfd_arch_info_type bfd_tilepro_arch;
+extern const bfd_arch_info_type bfd_tms9900_arch;
 extern const bfd_arch_info_type bfd_v850_arch;
 extern const bfd_arch_info_type bfd_v850_rh850_arch;
 extern const bfd_arch_info_type bfd_vax_arch;
@@ -774,6 +777,7 @@ static const bfd_arch_info_type * const
     &bfd_tic6x_arch,
     &bfd_tilegx_arch,
     &bfd_tilepro_arch,
+    &bfd_tms9900_arch,
     &bfd_v850_arch,
     &bfd_v850_rh850_arch,
     &bfd_vax_arch,
diff -rupN binutils-2.40-original/bfd/bfd-in2.h binutils-2.40/bfd/bfd-in2.h
--- binutils-2.40-original/bfd/bfd-in2.h	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/bfd/bfd-in2.h	2024-03-10 16:38:19.693164549 -0400
@@ -1865,6 +1865,8 @@ enum bfd_architecture
 #define bfd_mach_amdgcn_gfx1030 0x036
 #define bfd_mach_amdgcn_gfx1031 0x037
 #define bfd_mach_amdgcn_gfx1032 0x038
+  bfd_arch_tms9900,   /* Texas Instruments TMS9900 architecture.  */
+#define bfd_mach_tms9900       1
   bfd_arch_last
   };
 
diff -rupN binutils-2.40-original/bfd/config.bfd binutils-2.40/bfd/config.bfd
--- binutils-2.40-original/bfd/config.bfd	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/bfd/config.bfd	2024-03-10 16:38:19.693164549 -0400
@@ -220,6 +220,7 @@ sparc*)		 targ_archs=bfd_sparc_arch ;;
 spu*)            targ_archs=bfd_spu_arch ;;
 tilegx*)	 targ_archs=bfd_tilegx_arch ;;
 tilepro*)	 targ_archs=bfd_tilepro_arch ;;
+tms9900*)        targ_archs=bfd_tms9900_arch ;;
 v850*)		 targ_archs="bfd_v850_arch bfd_v850_rh850_arch" ;;
 visium*)	 targ_archs=bfd_visium_arch ;;
 x86_64*)	 targ_archs=bfd_i386_arch ;;
@@ -1404,6 +1405,10 @@ case "${targ}" in
     targ_defvec=tilepro_elf32_vec
     ;;
 
+  tms9900-*-*)
+    targ_defvec=tms9900_elf32_vec
+    ;;
+
   ft32*-*-*)
     targ_defvec=ft32_elf32_vec
     ;;
diff -rupN binutils-2.40-original/bfd/configure binutils-2.40/bfd/configure
--- binutils-2.40-original/bfd/configure	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/bfd/configure	2024-03-10 16:38:19.697164584 -0400
@@ -13854,6 +13854,7 @@ do
     tilegx_elf64_be_vec)	 tb="$tb elf64-tilegx.lo elfxx-tilegx.lo elf64.lo $elf" ; target_size=64 ;;
     tilegx_elf64_le_vec)	 tb="$tb elf64-tilegx.lo elfxx-tilegx.lo elf64.lo $elf" ; target_size=64 ;;
     tilepro_elf32_vec)		 tb="$tb elf32-tilepro.lo elf32.lo $elf" ;;
+    tms9900_elf32_vec)		 tb="$tb elf32-tms9900.lo elf32.lo $elf" ;;
     v800_elf32_vec)		 tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     v850_elf32_vec)		 tb="$tb elf32-v850.lo elf32.lo $elf" ;;
     vax_aout_1knbsd_vec)	 tb="$tb vax1knetbsd.lo aout32.lo" ;;
diff -rupN binutils-2.40-original/bfd/cpu-tms9900.c binutils-2.40/bfd/cpu-tms9900.c
--- binutils-2.40-original/bfd/cpu-tms9900.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.40/bfd/cpu-tms9900.c	2024-03-10 16:38:19.697164584 -0400
@@ -0,0 +1,58 @@
+/* BFD library support routines for the TMS9900 architecture.
+   Copyright 2009 Eric Welser
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+const bfd_arch_info_type bfd_tms9900_arch;
+
+/* This routine is provided two arch_infos and
+   returns whether they'd be compatible.  */
+
+static const bfd_arch_info_type *
+compatible (const bfd_arch_info_type *a, const bfd_arch_info_type *b)
+{
+  if (a->arch != b->arch)
+    return NULL;
+
+  if (a->mach == b->mach)
+    return a;
+
+  return (a->arch == bfd_arch_tms9900) ? & bfd_tms9900_arch : NULL;
+}
+
+
+const bfd_arch_info_type bfd_tms9900_arch = 
+{
+  16,                /* Bits per word */
+  16,                /* Bits per address */
+  8,                 /* Bits per byte */
+  bfd_arch_tms9900,  /* Architecture ID */
+  bfd_mach_tms9900,  /* Machine ID */
+  "tms9900",         /* Architecture name */
+  "tms9900",         /* Printable name */
+  0,                 /* Section align power */
+  true,              /* Is this the default machine for this arch? */
+  compatible,        /* Function to determine object file compatibility */
+  bfd_default_scan,  /* Scan function */
+  bfd_arch_default_fill,
+  NULL               /* Next record */
+};
diff -rupN binutils-2.40-original/bfd/doc/archures.texi binutils-2.40/bfd/doc/archures.texi
--- binutils-2.40-original/bfd/doc/archures.texi	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/bfd/doc/archures.texi	2024-03-10 16:38:19.701164621 -0400
@@ -530,6 +530,8 @@ enum bfd_architecture
 #define bfd_mach_amdgcn_gfx1030 0x036
 #define bfd_mach_amdgcn_gfx1031 0x037
 #define bfd_mach_amdgcn_gfx1032 0x038
+  bfd_arch_tms9900,   /* Texas Instruments TMS9900 architecture.  */
+#define bfd_mach_tms9900       1
   bfd_arch_last
   @};
 @end example
diff -rupN binutils-2.40-original/bfd/doc/bfd.info binutils-2.40/bfd/doc/bfd.info
--- binutils-2.40-original/bfd/doc/bfd.info	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/bfd/doc/bfd.info	2024-03-10 16:38:19.705164658 -0400
@@ -1,4 +1,4 @@
-This is bfd.info, produced by makeinfo version 6.8 from bfd.texi.
+This is bfd.info, produced by makeinfo version 6.5 from bfd.texi.
 
 This file documents the BFD library.
 
@@ -8683,6 +8683,8 @@ architecture, containing, for example, 6
      #define bfd_mach_amdgcn_gfx1030 0x036
      #define bfd_mach_amdgcn_gfx1031 0x037
      #define bfd_mach_amdgcn_gfx1032 0x038
+       bfd_arch_tms9900,   /* Texas Instruments TMS9900 architecture.  */
+     #define bfd_mach_tms9900       1
        bfd_arch_last
        };
 
@@ -12008,12 +12010,12 @@ BFD Index
 * bfd_alloc:                             Opening and Closing.
                                                              (line  248)
 * bfd_alt_mach_code:                     Miscellaneous.      (line  306)
-* bfd_arch_bits_per_address:             Architectures.      (line  674)
-* bfd_arch_bits_per_byte:                Architectures.      (line  666)
-* bfd_arch_default_fill:                 Architectures.      (line  756)
-* bfd_arch_get_compatible:               Architectures.      (line  609)
-* bfd_arch_list:                         Architectures.      (line  600)
-* bfd_arch_mach_octets_per_byte:         Architectures.      (line  744)
+* bfd_arch_bits_per_address:             Architectures.      (line  676)
+* bfd_arch_bits_per_byte:                Architectures.      (line  668)
+* bfd_arch_default_fill:                 Architectures.      (line  758)
+* bfd_arch_get_compatible:               Architectures.      (line  611)
+* bfd_arch_list:                         Architectures.      (line  602)
+* bfd_arch_mach_octets_per_byte:         Architectures.      (line  746)
 * BFD_ARELOC_BFIN_ADD:                   howto manager.      (line 1159)
 * BFD_ARELOC_BFIN_ADDR:                  howto manager.      (line 1193)
 * BFD_ARELOC_BFIN_AND:                   howto manager.      (line 1173)
@@ -12064,11 +12066,11 @@ BFD Index
                                                              (line  422)
 * bfd_decode_symclass:                   symbol handling functions.
                                                              (line  116)
-* bfd_default_arch_struct:               Architectures.      (line  621)
-* bfd_default_compatible:                Architectures.      (line  683)
+* bfd_default_arch_struct:               Architectures.      (line  623)
+* bfd_default_compatible:                Architectures.      (line  685)
 * bfd_default_reloc_type_lookup:         howto manager.      (line 3545)
-* bfd_default_scan:                      Architectures.      (line  692)
-* bfd_default_set_arch_mach:             Architectures.      (line  639)
+* bfd_default_scan:                      Architectures.      (line  694)
+* bfd_default_set_arch_mach:             Architectures.      (line  641)
 * bfd_demangle:                          Miscellaneous.      (line  339)
 * bfd_emul_get_commonpagesize:           Miscellaneous.      (line  328)
 * bfd_emul_get_maxpagesize:              Miscellaneous.      (line  317)
@@ -12106,8 +12108,8 @@ BFD Index
 * bfd_generic_relax_section:             howto manager.      (line 3563)
 * bfd_get_alt_debug_link_info:           Opening and Closing.
                                                              (line  320)
-* bfd_get_arch:                          Architectures.      (line  650)
-* bfd_get_arch_info:                     Architectures.      (line  702)
+* bfd_get_arch:                          Architectures.      (line  652)
+* bfd_get_arch_info:                     Architectures.      (line  704)
 * bfd_get_arch_size:                     Miscellaneous.      (line   63)
 * bfd_get_debug_link_info:               Opening and Closing.
                                                              (line  302)
@@ -12117,7 +12119,7 @@ BFD Index
 * bfd_get_file_size:                     Miscellaneous.      (line  428)
 * bfd_get_gp_size:                       Miscellaneous.      (line  106)
 * bfd_get_linker_section:                section prototypes. (line   37)
-* bfd_get_mach:                          Architectures.      (line  658)
+* bfd_get_mach:                          Architectures.      (line  660)
 * bfd_get_mtime:                         Miscellaneous.      (line  389)
 * bfd_get_next_mapent:                   Archives.           (line   57)
 * bfd_get_next_section_by_name:          section prototypes. (line   25)
@@ -12165,7 +12167,7 @@ BFD Index
                                                              (line  133)
 * bfd_link_split_section:                Writing the symbol table.
                                                              (line   43)
-* bfd_lookup_arch:                       Architectures.      (line  710)
+* bfd_lookup_arch:                       Architectures.      (line  712)
 * bfd_make_debug_symbol:                 symbol handling functions.
                                                              (line  106)
 * bfd_make_empty_symbol:                 symbol handling functions.
@@ -12184,7 +12186,7 @@ BFD Index
 * bfd_merge_private_bfd_data:            Writing the symbol table.
                                                              (line  155)
 * bfd_mmap:                              Miscellaneous.      (line  437)
-* bfd_octets_per_byte:                   Architectures.      (line  733)
+* bfd_octets_per_byte:                   Architectures.      (line  735)
 * bfd_openr:                             Opening and Closing.
                                                              (line   37)
 * bfd_openr_iovec:                       Opening and Closing.
@@ -12197,8 +12199,8 @@ BFD Index
 * bfd_open_file:                         File Caching.       (line   51)
 * bfd_perform_relocation:                typedef arelent.    (line  353)
 * bfd_perror:                            Error reporting.    (line   88)
-* bfd_printable_arch_mach:               Architectures.      (line  721)
-* bfd_printable_name:                    Architectures.      (line  581)
+* bfd_printable_arch_mach:               Architectures.      (line  723)
+* bfd_printable_name:                    Architectures.      (line  583)
 * bfd_print_symbol_vandf:                symbol handling functions.
                                                              (line   73)
 * BFD_RELOC_12_PCREL:                    howto manager.      (line   37)
@@ -14667,14 +14669,14 @@ BFD Index
 * BFD_RELOC_Z8K_DISP7:                   howto manager.      (line 2671)
 * BFD_RELOC_Z8K_IMM4L:                   howto manager.      (line 2675)
 * bfd_rename_section:                    section prototypes. (line  167)
-* bfd_scan_arch:                         Architectures.      (line  590)
+* bfd_scan_arch:                         Architectures.      (line  592)
 * bfd_scan_vma:                          Miscellaneous.      (line  135)
 * bfd_sections_find_if:                  section prototypes. (line  197)
 * bfd_section_already_linked:            Writing the symbol table.
                                                              (line   55)
 * bfd_section_list_clear:                section prototypes. (line    7)
 * bfd_set_archive_head:                  Archives.           (line   74)
-* bfd_set_arch_info:                     Architectures.      (line  631)
+* bfd_set_arch_info:                     Architectures.      (line  633)
 * bfd_set_assert_handler:                Error reporting.    (line  179)
 * bfd_set_default_target:                bfd_target.         (line  599)
 * bfd_set_error:                         Error reporting.    (line   58)
@@ -14765,42 +14767,37 @@ Node: Core Files272828
 Node: Targets274852
 Node: bfd_target276827
 Node: Architectures304808
-Node: Opening and Closing336706
-Node: Internal354874
-Node: File Caching354978
-Node: Linker Functions356875
-Node: Creating a Linker Hash Table358549
-Node: Adding Symbols to the Hash Table360288
-Node: Differing file formats361188
-Node: Adding symbols from an object file362913
-Node: Adding symbols from an archive365063
-Node: Performing the Final Link367409
-Node: Information provided by the linker368650
-Node: Relocating the section contents369804
-Node: Writing the symbol table371556
-Node: Hash Tables378647
-Node: Creating and Freeing a Hash Table379845
-Node: Looking Up or Entering a String381095
-Node: Traversing a Hash Table382348
-Node: Deriving a New Hash Table Type383137
-Node: Define the Derived Structures384203
-Node: Write the Derived Creation Routine385284
-Node: Write Other Derived Routines387909
-Node: BFD back ends389224
-Node: What to Put Where389494
-Node: aout389674
-Node: coff395916
-Node: elf424056
-Node: mmo424457
-Node: File layout425327
-Node: Symbol-table431240
-Node: mmo section mapping435003
-Node: GNU Free Documentation License438657
-Node: BFD Index463721
+Node: Opening and Closing336818
+Node: Internal354986
+Node: File Caching355090
+Node: Linker Functions356987
+Node: Creating a Linker Hash Table358661
+Node: Adding Symbols to the Hash Table360400
+Node: Differing file formats361300
+Node: Adding symbols from an object file363025
+Node: Adding symbols from an archive365175
+Node: Performing the Final Link367521
+Node: Information provided by the linker368762
+Node: Relocating the section contents369916
+Node: Writing the symbol table371668
+Node: Hash Tables378759
+Node: Creating and Freeing a Hash Table379957
+Node: Looking Up or Entering a String381207
+Node: Traversing a Hash Table382460
+Node: Deriving a New Hash Table Type383249
+Node: Define the Derived Structures384315
+Node: Write the Derived Creation Routine385396
+Node: Write Other Derived Routines388021
+Node: BFD back ends389336
+Node: What to Put Where389606
+Node: aout389786
+Node: coff396028
+Node: elf424168
+Node: mmo424569
+Node: File layout425439
+Node: Symbol-table431352
+Node: mmo section mapping435115
+Node: GNU Free Documentation License438769
+Node: BFD Index463833
 
 End Tag Table
-
-
-Local Variables:
-coding: utf-8
-End:
diff -rupN binutils-2.40-original/bfd/doc/bfdver.texi binutils-2.40/bfd/doc/bfdver.texi
--- binutils-2.40-original/bfd/doc/bfdver.texi	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/bfd/doc/bfdver.texi	2024-03-10 16:38:19.709164693 -0400
@@ -1,4 +1,4 @@
 @set VERSION 2.40
 @set VERSION_PACKAGE (GNU Binutils) 
-@set UPDATED January 2023
+@set UPDATED April 2023
 @set BUGURL @uref{https://sourceware.org/bugzilla/}
diff -rupN binutils-2.40-original/bfd/elf32-tms9900.c binutils-2.40/bfd/elf32-tms9900.c
--- binutils-2.40-original/bfd/elf32-tms9900.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.40/bfd/elf32-tms9900.c	2024-03-10 16:38:19.709164693 -0400
@@ -0,0 +1,126 @@
+#include "sysdep.h"
+#include "bfd.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/tms9900.h"
+
+
+#ifdef DEBUG_GEN_RELOC
+#define TRACE(str) \
+  fprintf (stderr, "tms9900 bfd reloc lookup %d (%s)\n", code, str)
+#else
+#define TRACE(str)
+#endif
+
+extern const bfd_target tms9900_elf32_vec;
+
+static reloc_howto_type elf_howto_table[]=
+{
+  /* Invalid record, do nothing */
+  HOWTO(R_TMS9900_NONE,             /* type */
+        0,                          /* rightshift */
+        0,                          /* size (0 = none, 1 = byte, 2 = short) */
+        0,                          /* bitsize */
+        false,                      /* pc_relative */
+        0,                          /* bitpos */
+        complain_overflow_bitfield, /* complain on overflow */
+	bfd_elf_generic_reloc,      /* special_function */
+        "R_TMS9900_NONE",           /* name */
+	false,                      /* partial_inplace */
+        0x00000000,                 /* src_mask */
+        0x00000000,                 /* dst_mask */
+        false),                     /* pcrel_offset */
+
+  /* 8-bit offset from current PC, used in jump commands */
+  HOWTO(R_TMS9900_PC8,              /* type */
+        1,                          /* rightshift */
+        1,                          /* size (0 = none, 1 = byte, 2 = short) */
+        8,                          /* bitsize */
+        true,                       /* pc_relative */
+        0,                          /* bitpos */
+        complain_overflow_signed,   /* complain on overflow */
+        bfd_elf_generic_reloc,      /* special_function */
+        "R_TMS9900_PC8",            /* name */
+        false,                      /* partial_inplace */
+        0x00000000,                 /* src_mask */
+        0x000000FF,                 /* dst_mask */
+        true),                      /* pcrel_offset */
+
+  /* Generic 16-bit constant */
+  HOWTO(R_TMS9900_16,               /* type */
+        0,                          /* rightshift */
+        2,                          /* size (0 = none, 1 = byte, 2 = short) */
+        16,                         /* bitsize */
+        false,                      /* pc_relative */
+        0,                          /* bitpos */
+        complain_overflow_bitfield, /* complain on overflow */
+        bfd_elf_generic_reloc,      /* special_function */
+        "R_TMS9900_16",             /* name */
+        false,                      /* partial_inplace */
+        0x00000000,                 /* src_mask */
+        0x0000FFFF,                 /* dst_mask */
+        false),                     /* pcrel_offset */
+};  
+
+
+static reloc_howto_type *
+elf_tms9900_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				bfd_reloc_code_real_type code)
+{
+  switch (code)
+    {
+    case BFD_RELOC_NONE:
+      TRACE ("BFD_RELOC_NONE");
+      return &elf_howto_table[R_TMS9900_NONE];
+
+    case BFD_RELOC_16:
+      TRACE ("BFD_RELOC_16");
+      return &elf_howto_table[R_TMS9900_16];
+
+    case BFD_RELOC_8_PCREL:
+      TRACE ("BFD_RELOC_8_PCREL");
+      return &elf_howto_table[R_TMS9900_PC8];
+
+    default:
+      break;
+    }
+
+  TRACE ("Unknown");
+  return 0;
+}
+
+static reloc_howto_type *
+elf_tms9900_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0; i < sizeof (elf_howto_table) / sizeof (elf_howto_table[0]); i++)
+    if (elf_howto_table[i].name != NULL
+	&& strcasecmp (elf_howto_table[i].name, r_name) == 0)
+      return &elf_howto_table[i];
+
+  return NULL;
+}
+
+static void
+tms9900_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
+		           arelent *cache_ptr,
+		           Elf_Internal_Rela *dst)
+{
+  cache_ptr->howto = &elf_howto_table[ELF32_R_TYPE (dst->r_info)];
+}
+
+#define TARGET_BIG_SYM			tms9900_elf32_vec
+#define TARGET_BIG_NAME			"elf32-tms9900"
+#define ELF_ARCH			bfd_arch_tms9900
+#define ELF_MACHINE_CODE		EM_TMS9900
+#define ELF_MAXPAGESIZE			0x200
+
+#define bfd_elf32_bfd_reloc_type_lookup	      elf_tms9900_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup	      elf_tms9900_reloc_name_lookup
+#define elf_info_to_howto                     tms9900_elf_info_to_howto
+#define elf_info_to_howto_rel                 _bfd_elf_no_info_to_howto
+
+#include "elf32-target.h"
diff -rupN binutils-2.40-original/bfd/Makefile.in binutils-2.40/bfd/Makefile.in
--- binutils-2.40-original/bfd/Makefile.in	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/bfd/Makefile.in	2024-03-10 16:38:19.709164693 -0400
@@ -634,6 +634,7 @@ ALL_MACHINES = \
 	cpu-tic6x.lo \
 	cpu-tilegx.lo \
 	cpu-tilepro.lo \
+        cpu-tms9900.lo \
 	cpu-v850.lo \
 	cpu-v850_rh850.lo \
 	cpu-vax.lo \
@@ -717,6 +718,7 @@ ALL_MACHINES_CFILES = \
 	cpu-tic6x.c \
 	cpu-tilegx.c \
 	cpu-tilepro.c \
+        cpu-tms9900.c \
 	cpu-v850.c \
 	cpu-v850_rh850.c \
 	cpu-vax.c \
@@ -816,6 +818,7 @@ BFD32_BACKENDS = \
 	elf32-tic6x.lo \
 	elf32-tilegx.lo \
 	elf32-tilepro.lo \
+        elf32-tms9900.lo \
 	elf32-v850.lo \
 	elf32-vax.lo \
 	elf32-visium.lo \
@@ -951,6 +954,7 @@ BFD32_BACKENDS_CFILES = \
 	elf32-tic6x.c \
 	elf32-tilegx.c \
 	elf32-tilepro.c \
+        elf32-tms9900.c \
 	elf32-v850.c \
 	elf32-vax.c \
 	elf32-visium.c \
@@ -1169,8 +1173,8 @@ SOURCE_HFILES = \
 	elf32-dlx.h elf32-hppa.h elf32-m68hc1x.h elf32-m68k.h \
 	elf32-metag.h elf32-nds32.h elf32-nios2.h elf32-ppc.h \
 	elf32-rx.h elf32-score.h elf32-sh-relocs.h elf32-spu.h \
-	elf32-tic6x.h elf32-tilegx.h elf32-tilepro.h elf32-v850.h \
-	elf64-hppa.h elf64-ppc.h elf64-tilegx.h \
+	elf32-tic6x.h elf32-tilegx.h elf32-tilepro.h elf32-tms9900.h \
+        elf32-v850.h elf64-hppa.h elf64-ppc.h elf64-tilegx.h \
 	elf-bfd.h elfcode.h elfcore.h elf-hppa.h elf-linker-x86.h \
 	elf-linux-core.h elf-nacl.h elf-s390.h elf-vxworks.h \
 	elfxx-aarch64.h elfxx-ia64.h elfxx-mips.h elfxx-riscv.h \
@@ -1557,6 +1561,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-tic6x.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-tilegx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-tilepro.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-tms9900.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-v850.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-v850_rh850.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-vax.Plo@am__quote@
@@ -1641,6 +1646,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-tic6x.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-tilegx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-tilepro.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-tms9900.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-v850.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-vax.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-visium.Plo@am__quote@
diff -rupN binutils-2.40-original/bfd/targets.c binutils-2.40/bfd/targets.c
--- binutils-2.40-original/bfd/targets.c	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/bfd/targets.c	2024-03-10 16:38:19.709164693 -0400
@@ -924,6 +924,7 @@ extern const bfd_target tilegx_elf32_le_
 extern const bfd_target tilegx_elf64_be_vec;
 extern const bfd_target tilegx_elf64_le_vec;
 extern const bfd_target tilepro_elf32_vec;
+extern const bfd_target tms9900_elf32_vec;
 extern const bfd_target v800_elf32_vec;
 extern const bfd_target v850_elf32_vec;
 extern const bfd_target ft32_elf32_vec;
@@ -1328,6 +1329,7 @@ static const bfd_target * const _bfd_tar
 	&tilegx_elf64_le_vec,
 #endif
 	&tilepro_elf32_vec,
+        &tms9900_elf32_vec,
 
 	&ft32_elf32_vec,
 
diff -rupN binutils-2.40-original/binutils/doc/addr2line.1 binutils-2.40/binutils/doc/addr2line.1
--- binutils-2.40-original/binutils/doc/addr2line.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/addr2line.1	2024-03-10 16:38:19.709164693 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "ADDR2LINE 1"
-.TH ADDR2LINE 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH ADDR2LINE 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rupN binutils-2.40-original/binutils/doc/ar.1 binutils-2.40/binutils/doc/ar.1
--- binutils-2.40-original/binutils/doc/ar.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/ar.1	2024-03-10 16:38:19.709164693 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "AR 1"
-.TH AR 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH AR 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -525,7 +521,7 @@ with a backslash.  The \fIfile\fR may it
 @\fIfile\fR options; any such options will be processed recursively.
 .SH "SEE ALSO"
 .IX Header "SEE ALSO"
-\&\fBnm\fR\|(1), \fBranlib\fR\|(1), and the Info entries for \fIbinutils\fR.
+\&\fInm\fR\|(1), \fIranlib\fR\|(1), and the Info entries for \fIbinutils\fR.
 .SH "COPYRIGHT"
 .IX Header "COPYRIGHT"
 Copyright (c) 1991\-2023 Free Software Foundation, Inc.
diff -rupN binutils-2.40-original/binutils/doc/c++filt.1 binutils-2.40/binutils/doc/c++filt.1
--- binutils-2.40-original/binutils/doc/c++filt.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/c++filt.1	2024-03-10 16:38:19.713164731 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "C++FILT 1"
-.TH C++FILT 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH C++FILT 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rupN binutils-2.40-original/binutils/doc/cxxfilt.man binutils-2.40/binutils/doc/cxxfilt.man
--- binutils-2.40-original/binutils/doc/cxxfilt.man	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/cxxfilt.man	2024-03-10 16:38:19.713164731 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "C++FILT 1"
-.TH C++FILT 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH C++FILT 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rupN binutils-2.40-original/binutils/doc/dlltool.1 binutils-2.40/binutils/doc/dlltool.1
--- binutils-2.40-original/binutils/doc/dlltool.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/dlltool.1	2024-03-10 16:38:19.713164731 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "DLLTOOL 1"
-.TH DLLTOOL 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH DLLTOOL 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -193,7 +189,7 @@ put entries for them in the \fI.def\fR f
 In order to mark a function as being exported from a \s-1DLL,\s0 it needs to
 have an \fB\-export:<name_of_function>\fR entry in the \fB.drectve\fR
 section of the object file.  This can be done in C by using the
-\&\fBasm()\fR operator:
+\&\fIasm()\fR operator:
 .PP
 .Vb 2
 \&          asm (".section .drectve");
@@ -217,7 +213,7 @@ If the \fB\-y\fR option is specified, dl
 library that can be used instead of the normal import library to allow
 a program to link to the dll only as soon as an imported function is
 called for the first time. The resulting executable will need to be
-linked to the static delayimp library containing _\|\fB_delayLoadHelper2()\fR,
+linked to the static delayimp library containing _\|\fI_delayLoadHelper2()\fR,
 which in turn will import LoadLibraryA and GetProcAddress from kernel32.
 .PP
 \&\fBdlltool\fR builds the library file by hand, but it builds the
diff -rupN binutils-2.40-original/binutils/doc/elfedit.1 binutils-2.40/binutils/doc/elfedit.1
--- binutils-2.40-original/binutils/doc/elfedit.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/elfedit.1	2024-03-10 16:38:19.713164731 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "ELFEDIT 1"
-.TH ELFEDIT 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH ELFEDIT 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -260,7 +256,7 @@ with a backslash.  The \fIfile\fR may it
 @\fIfile\fR options; any such options will be processed recursively.
 .SH "SEE ALSO"
 .IX Header "SEE ALSO"
-\&\fBreadelf\fR\|(1), and the Info entries for \fIbinutils\fR.
+\&\fIreadelf\fR\|(1), and the Info entries for \fIbinutils\fR.
 .SH "COPYRIGHT"
 .IX Header "COPYRIGHT"
 Copyright (c) 1991\-2023 Free Software Foundation, Inc.
diff -rupN binutils-2.40-original/binutils/doc/nm.1 binutils-2.40/binutils/doc/nm.1
--- binutils-2.40-original/binutils/doc/nm.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/nm.1	2024-03-10 16:38:19.713164731 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "NM 1"
-.TH NM 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH NM 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -676,7 +672,7 @@ with a backslash.  The \fIfile\fR may it
 @\fIfile\fR options; any such options will be processed recursively.
 .SH "SEE ALSO"
 .IX Header "SEE ALSO"
-\&\fBar\fR\|(1), \fBobjdump\fR\|(1), \fBranlib\fR\|(1), and the Info entries for \fIbinutils\fR.
+\&\fIar\fR\|(1), \fIobjdump\fR\|(1), \fIranlib\fR\|(1), and the Info entries for \fIbinutils\fR.
 .SH "COPYRIGHT"
 .IX Header "COPYRIGHT"
 Copyright (c) 1991\-2023 Free Software Foundation, Inc.
diff -rupN binutils-2.40-original/binutils/doc/objcopy.1 binutils-2.40/binutils/doc/objcopy.1
--- binutils-2.40-original/binutils/doc/objcopy.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/objcopy.1	2024-03-10 16:38:19.713164731 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "OBJCOPY 1"
-.TH OBJCOPY 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH OBJCOPY 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -1237,7 +1233,7 @@ with a backslash.  The \fIfile\fR may it
 @\fIfile\fR options; any such options will be processed recursively.
 .SH "SEE ALSO"
 .IX Header "SEE ALSO"
-\&\fBld\fR\|(1), \fBobjdump\fR\|(1), and the Info entries for \fIbinutils\fR.
+\&\fIld\fR\|(1), \fIobjdump\fR\|(1), and the Info entries for \fIbinutils\fR.
 .SH "COPYRIGHT"
 .IX Header "COPYRIGHT"
 Copyright (c) 1991\-2023 Free Software Foundation, Inc.
diff -rupN binutils-2.40-original/binutils/doc/objdump.1 binutils-2.40/binutils/doc/objdump.1
--- binutils-2.40-original/binutils/doc/objdump.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/objdump.1	2024-03-10 16:38:19.713164731 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "OBJDUMP 1"
-.TH OBJDUMP 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH OBJDUMP 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -1445,7 +1441,7 @@ with a backslash.  The \fIfile\fR may it
 @\fIfile\fR options; any such options will be processed recursively.
 .SH "SEE ALSO"
 .IX Header "SEE ALSO"
-\&\fBnm\fR\|(1), \fBreadelf\fR\|(1), and the Info entries for \fIbinutils\fR.
+\&\fInm\fR\|(1), \fIreadelf\fR\|(1), and the Info entries for \fIbinutils\fR.
 .SH "COPYRIGHT"
 .IX Header "COPYRIGHT"
 Copyright (c) 1991\-2023 Free Software Foundation, Inc.
diff -rupN binutils-2.40-original/binutils/doc/ranlib.1 binutils-2.40/binutils/doc/ranlib.1
--- binutils-2.40-original/binutils/doc/ranlib.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/ranlib.1	2024-03-10 16:38:19.717164766 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "RANLIB 1"
-.TH RANLIB 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH RANLIB 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -214,7 +210,7 @@ with a backslash.  The \fIfile\fR may it
 @\fIfile\fR options; any such options will be processed recursively.
 .SH "SEE ALSO"
 .IX Header "SEE ALSO"
-\&\fBar\fR\|(1), \fBnm\fR\|(1), and the Info entries for \fIbinutils\fR.
+\&\fIar\fR\|(1), \fInm\fR\|(1), and the Info entries for \fIbinutils\fR.
 .SH "COPYRIGHT"
 .IX Header "COPYRIGHT"
 Copyright (c) 1991\-2023 Free Software Foundation, Inc.
diff -rupN binutils-2.40-original/binutils/doc/readelf.1 binutils-2.40/binutils/doc/readelf.1
--- binutils-2.40-original/binutils/doc/readelf.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/readelf.1	2024-03-10 16:38:19.717164766 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "READELF 1"
-.TH READELF 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH READELF 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -893,7 +889,7 @@ with a backslash.  The \fIfile\fR may it
 @\fIfile\fR options; any such options will be processed recursively.
 .SH "SEE ALSO"
 .IX Header "SEE ALSO"
-\&\fBobjdump\fR\|(1), and the Info entries for \fIbinutils\fR.
+\&\fIobjdump\fR\|(1), and the Info entries for \fIbinutils\fR.
 .SH "COPYRIGHT"
 .IX Header "COPYRIGHT"
 Copyright (c) 1991\-2023 Free Software Foundation, Inc.
diff -rupN binutils-2.40-original/binutils/doc/size.1 binutils-2.40/binutils/doc/size.1
--- binutils-2.40-original/binutils/doc/size.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/size.1	2024-03-10 16:38:19.717164766 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "SIZE 1"
-.TH SIZE 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH SIZE 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -299,7 +295,7 @@ with a backslash.  The \fIfile\fR may it
 @\fIfile\fR options; any such options will be processed recursively.
 .SH "SEE ALSO"
 .IX Header "SEE ALSO"
-\&\fBar\fR\|(1), \fBobjdump\fR\|(1), \fBreadelf\fR\|(1), and the Info entries for \fIbinutils\fR.
+\&\fIar\fR\|(1), \fIobjdump\fR\|(1), \fIreadelf\fR\|(1), and the Info entries for \fIbinutils\fR.
 .SH "COPYRIGHT"
 .IX Header "COPYRIGHT"
 Copyright (c) 1991\-2023 Free Software Foundation, Inc.
diff -rupN binutils-2.40-original/binutils/doc/strings.1 binutils-2.40/binutils/doc/strings.1
--- binutils-2.40-original/binutils/doc/strings.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/strings.1	2024-03-10 16:38:19.717164766 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "STRINGS 1"
-.TH STRINGS 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH STRINGS 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -332,7 +328,7 @@ with a backslash.  The \fIfile\fR may it
 @\fIfile\fR options; any such options will be processed recursively.
 .SH "SEE ALSO"
 .IX Header "SEE ALSO"
-\&\fBar\fR\|(1), \fBnm\fR\|(1), \fBobjdump\fR\|(1), \fBranlib\fR\|(1), \fBreadelf\fR\|(1)
+\&\fIar\fR\|(1), \fInm\fR\|(1), \fIobjdump\fR\|(1), \fIranlib\fR\|(1), \fIreadelf\fR\|(1)
 and the Info entries for \fIbinutils\fR.
 .SH "COPYRIGHT"
 .IX Header "COPYRIGHT"
diff -rupN binutils-2.40-original/binutils/doc/strip.1 binutils-2.40/binutils/doc/strip.1
--- binutils-2.40-original/binutils/doc/strip.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/strip.1	2024-03-10 16:38:19.717164766 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "STRIP 1"
-.TH STRIP 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH STRIP 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rupN binutils-2.40-original/binutils/doc/windmc.1 binutils-2.40/binutils/doc/windmc.1
--- binutils-2.40-original/binutils/doc/windmc.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/windmc.1	2024-03-10 16:38:19.717164766 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "WINDMC 1"
-.TH WINDMC 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH WINDMC 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rupN binutils-2.40-original/binutils/doc/windres.1 binutils-2.40/binutils/doc/windres.1
--- binutils-2.40-original/binutils/doc/windres.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/doc/windres.1	2024-03-10 16:38:19.717164766 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "WINDRES 1"
-.TH WINDRES 1 "2023-01-14" "binutils-2.40.00" "GNU Development Tools"
+.TH WINDRES 1 "2023-04-17" "binutils-2.40.00" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -rupN binutils-2.40-original/binutils/readelf.c binutils-2.40/binutils/readelf.c
--- binutils-2.40-original/binutils/readelf.c	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/binutils/readelf.c	2024-03-10 16:38:19.721164803 -0400
@@ -158,6 +158,7 @@
 #include "elf/tic6x.h"
 #include "elf/tilegx.h"
 #include "elf/tilepro.h"
+#include "elf/tms9900.h"
 #include "elf/v850.h"
 #include "elf/vax.h"
 #include "elf/visium.h"
@@ -1116,6 +1117,7 @@ guess_is_rela (unsigned int e_machine)
     case EM_TI_C6000:
     case EM_TILEGX:
     case EM_TILEPRO:
+    case EM_TMS9900:
     case EM_V800:
     case EM_V850:
     case EM_CYGNUS_V850:
@@ -1916,6 +1918,10 @@ dump_relocations (Filedata *filedata,
 	case EM_AMDGPU:
 	  rtype = elf_amdgpu_reloc_type (type);
 	  break;
+
+	case EM_TMS9900:
+	  rtype = elf_tms9900_reloc_type (type);
+	  break;
 	}
 
       if (rtype == NULL)
@@ -2989,6 +2995,7 @@ get_machine_name (unsigned e_machine)
     case EM_ADAPTEVA_EPIPHANY:	return "Adapteva EPIPHANY";
     case EM_CYGNUS_FRV:		return "Fujitsu FR-V";
     case EM_S12Z:               return "Freescale S12Z";
+    case EM_TMS9900:            return "Texas Instruments TMS9900";
 
     default:
       snprintf (buff, sizeof (buff), _("<unknown>: 0x%x"), e_machine);
diff -rupN binutils-2.40-original/config.sub binutils-2.40/config.sub
--- binutils-2.40-original/config.sub	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/config.sub	2024-03-10 16:38:19.721164803 -0400
@@ -187,7 +187,7 @@ case $1 in
 					| ultra | tti* | harris | dolphin | highlevel | gould \
 					| cbm | ns | masscomp | apple | axis | knuth | cray \
 					| microblaze* | sim | cisco \
-					| oki | wec | wrs | winbond)
+					| oki | wec | wrs | winbond | tms9900)
 						basic_machine=$field1-$field2
 						basic_os=
 						;;
@@ -1120,6 +1120,9 @@ case $cpu-$vendor in
 	tx39el-*)
 		cpu=mipstx39el
 		;;
+	tms9900-*)
+		cpu=tms9900
+		;;
 	x64-*)
 		cpu=x86_64
 		;;
diff -rupN binutils-2.40-original/.current_patch binutils-2.40/.current_patch
--- binutils-2.40-original/.current_patch	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.40/.current_patch	2024-03-10 16:38:19.753165097 -0400
@@ -0,0 +1 @@
+binutils-2.40-tms9900-0.0.patch
diff -rupN binutils-2.40-original/gas/config/tc-tms9900.c binutils-2.40/gas/config/tc-tms9900.c
--- binutils-2.40-original/gas/config/tc-tms9900.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.40/gas/config/tc-tms9900.c	2024-03-10 16:38:19.725164841 -0400
@@ -0,0 +1,1302 @@
+/* tc-tms9900.c -- Assemble code for the Texas Instruments TMS9900
+   Copyright 2009 Eric Welser
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "as.h"
+#include "safe-ctype.h"
+#include "subsegs.h"
+
+
+/* Forward declarations, used in "md_pseudo_table" */
+static void tms9900_bss (int unused ATTRIBUTE_UNUSED);
+static void tms9900_seg_bss (int unused ATTRIBUTE_UNUSED);
+static void tms9900_seg_data (int unused ATTRIBUTE_UNUSED);
+static void tms9900_seg_text (int unused ATTRIBUTE_UNUSED);
+static void tms9900_data (int size);
+static void tms9900_text (int size);
+
+
+/* Type identifiers for text constants */
+enum
+{
+  TEXT_DATAONLY = -1,
+  TEXT_PRESIZE  = -2,
+  TEXT_ZEROTERM = -3
+};
+
+/* Type identifiers for text constants */
+enum
+{
+  ARG_NONE,       /* No argument            */
+  ARG_MODE,       /* Addressing mode        */
+  ARG_OFFSET,     /* Branch offset          */
+  ARG_REGISTER,   /* Register number        */
+  ARG_IMMEDIATE,  /* 16-bit immediate value */
+  ARG_SHIFT,      /* Bit shift count        */
+  ARG_CRU_COUNT,  /* CRU bit count          */
+  ARG_CRU_DISP    /* CRU displacement       */
+};
+
+/* Structure used for instruction format list */
+typedef struct _table_t
+{
+  char* name;
+  short opcode;
+  int arg[2];
+} table_t;
+
+/* Structure used for register identifier list */
+static struct reg_entry
+{
+  char* name;
+  int number;
+};
+
+/* Register identifier list, including aliases, in alphabetic order */
+static const struct reg_entry regtable[] =
+{
+  {"cb",  12 },  /* Alias: CRU base */
+  {"lp",  14 },  /* Alias: Old Program Counter register after BLWP */
+  {"lr",  11 },  /* Alias: Return address after BL */
+  {"ls",  15 },  /* Alias: Old Status Register after BLWP */
+  {"lw",  13 },  /* Alias: Old Workspace Register after BLWP */
+  {"r0",   0 },
+  {"r1",   1 },
+  {"r10", 10 },
+  {"r11", 11 },
+  {"r12", 12 },
+  {"r13", 13 },
+  {"r14", 14 },
+  {"r15", 15 },
+  {"r2",   2 },
+  {"r3",   3 },
+  {"r4",   4 },
+  {"r5",   5 },
+  {"r6",   6 },
+  {"r7",   7 },
+  {"r8",   8 },
+  {"r9",   9 },
+  {"sp",  10 }   /* Alias: Stack pointer */
+};
+
+/* Number of unique registers */
+static const int reg_count = 16;
+
+/* Instruction format list, in alphabetic order */
+static const table_t instab[] =
+{
+  { "a",    0xA000, {ARG_MODE,      ARG_MODE}},
+  { "ab",   0xB000, {ARG_MODE,      ARG_MODE}},
+  { "abs",  0x0740, {ARG_MODE,      ARG_NONE}},
+  { "ai",   0x0220, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "andi", 0x0240, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "b",    0x0440, {ARG_MODE,      ARG_NONE}},
+  { "bl",   0x0680, {ARG_MODE,      ARG_NONE}},
+  { "blwp", 0x0400, {ARG_MODE,      ARG_NONE}},
+  { "c",    0x8000, {ARG_MODE,      ARG_MODE}},
+  { "cb",   0x9000, {ARG_MODE,      ARG_MODE}},
+  { "ci",   0x0280, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "ckof", 0x03C0, {ARG_NONE,      ARG_NONE}},
+  { "ckon", 0x03A0, {ARG_NONE,      ARG_NONE}},
+  { "clr",  0x04C0, {ARG_MODE,      ARG_NONE}},
+  { "coc",  0x2000, {ARG_MODE,      ARG_REGISTER}},
+  { "czc",  0x2400, {ARG_MODE,      ARG_REGISTER}},
+  { "dec",  0x0600, {ARG_MODE,      ARG_NONE}},
+  { "dect", 0x0640, {ARG_MODE,      ARG_NONE}},
+  { "div",  0x3C00, {ARG_MODE,      ARG_REGISTER}},
+  { "idle", 0x0340, {ARG_NONE,      ARG_NONE}},
+  { "inc",  0x0580, {ARG_MODE,      ARG_NONE}},
+  { "inct", 0x05C0, {ARG_MODE,      ARG_NONE}},
+  { "inv",  0x0540, {ARG_MODE,      ARG_NONE}},
+  { "jeq",  0x1300, {ARG_OFFSET,    ARG_NONE}},
+  { "jgt",  0x1500, {ARG_OFFSET,    ARG_NONE}},
+  { "jh",   0x1B00, {ARG_OFFSET,    ARG_NONE}},
+  { "jhe",  0x1400, {ARG_OFFSET,    ARG_NONE}},
+  { "jl",   0x1A00, {ARG_OFFSET,    ARG_NONE}},
+  { "jle",  0x1200, {ARG_OFFSET,    ARG_NONE}},
+  { "jlt",  0x1100, {ARG_OFFSET,    ARG_NONE}},
+  { "jmp",  0x1000, {ARG_OFFSET,    ARG_NONE}},
+  { "jnc",  0x1700, {ARG_OFFSET,    ARG_NONE}},
+  { "jne",  0x1600, {ARG_OFFSET,    ARG_NONE}},
+  { "jno",  0x1900, {ARG_OFFSET,    ARG_NONE}},
+  { "joc",  0x1800, {ARG_OFFSET,    ARG_NONE}},
+  { "jop",  0x1C00, {ARG_OFFSET,    ARG_NONE}},
+  { "ldcr", 0x3000, {ARG_MODE,      ARG_CRU_COUNT}},
+  { "li",   0x0200, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "limi", 0x0300, {ARG_IMMEDIATE, ARG_NONE}},
+  { "lrex", 0x03E0, {ARG_NONE,      ARG_NONE}},
+  { "lwpi", 0x02E0, {ARG_IMMEDIATE, ARG_NONE}},
+  { "mov",  0xC000, {ARG_MODE,      ARG_MODE}},
+  { "movb", 0xD000, {ARG_MODE,      ARG_MODE}},
+  { "mpy",  0x3800, {ARG_MODE,      ARG_REGISTER}},
+  { "neg",  0x0500, {ARG_MODE,      ARG_NONE}},
+  { "nop",  0x1000, {ARG_NONE,      ARG_NONE}},  /* Encoded as "jmp 0"  */
+  { "or",   0xE000, {ARG_MODE,      ARG_MODE}},  /* Encoded as "soc"    */
+  { "orb",  0xF000, {ARG_MODE,      ARG_MODE}},  /* Encoded as "socb"   */
+  { "ori",  0x0260, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "rset", 0x0360, {ARG_NONE,      ARG_NONE}},
+  { "rt",   0x045B, {ARG_NONE,      ARG_NONE}},  /* Encoded as "b *r11" */
+  { "rtwp", 0x0380, {ARG_NONE,      ARG_NONE}},
+  { "s",    0x6000, {ARG_MODE,      ARG_MODE}},
+  { "sb",   0x7000, {ARG_MODE,      ARG_MODE}},
+  { "sbo",  0x1D00, {ARG_CRU_DISP,  ARG_NONE}},
+  { "sbz",  0x1E00, {ARG_CRU_DISP,  ARG_NONE}},
+  { "seto", 0x0700, {ARG_MODE,      ARG_NONE}},
+  { "sla",  0x0A00, {ARG_REGISTER,  ARG_SHIFT}},
+  { "soc",  0xE000, {ARG_MODE,      ARG_MODE}},
+  { "socb", 0xF000, {ARG_MODE,      ARG_MODE}},
+  { "sra",  0x0800, {ARG_REGISTER,  ARG_SHIFT}},
+  { "src",  0x0B00, {ARG_REGISTER,  ARG_SHIFT}},
+  { "srl",  0x0900, {ARG_REGISTER,  ARG_SHIFT}},
+  { "stcr", 0x3400, {ARG_MODE,      ARG_CRU_COUNT}},
+  { "stst", 0x02C0, {ARG_REGISTER,  ARG_NONE}},
+  { "stwp", 0x02A0, {ARG_REGISTER,  ARG_NONE}},
+  { "swpb", 0x06C0, {ARG_MODE,      ARG_NONE}},
+  { "szc",  0x4000, {ARG_MODE,      ARG_MODE}},
+  { "szcb", 0x5000, {ARG_MODE,      ARG_MODE}},
+  { "tb",   0x1F00, {ARG_CRU_DISP,  ARG_NONE}},
+  { "x",    0x0480, {ARG_MODE,      ARG_NONE}},
+  { "xop",  0x2C00, {ARG_MODE,      ARG_REGISTER}},
+  { "xor",  0x2800, {ARG_MODE,      ARG_REGISTER}}
+};
+
+/* List of short machine specific GAS options.  */
+const char * md_shortopts = "";
+
+/* List of long machine specific GAS options */
+const struct option md_longopts[] =
+{
+  { NULL, no_argument, NULL, 0 }
+};
+const size_t md_longopts_size = sizeof (md_longopts);
+
+/* Formatting characters for this machine */
+const char EXP_CHARS[] = "eE\0";
+const char FLT_CHARS[] = "RrFf\0";
+const char line_separator_chars[] = "\0";
+const char line_comment_chars[] = "#\0";
+
+/* The TMS9900 assembly format specifies "*" for the start of comments.
+   Unfortunately, that character is also used in register expressions.
+   So we have to manually handle comments here, and cannot rely on GAS's
+   normal comment parsing */
+const char tms9900_comment_chars[] = "#;\0";
+
+/* List of chars besides those in app.c:symbol_chars that can start an
+   operand.  Used to prevent the scrubber eating vital white-space.
+   We use this to determine if the asterisk is the start of a comment */
+const char tms9900_symbol_chars[] = "+*\0";
+
+/* Port specific pseudo ops.  */
+const pseudo_typeS md_pseudo_table[] =
+{
+  { ".bss",  tms9900_seg_bss, 0},
+  { ".data", tms9900_seg_data, 0},
+  { ".text", tms9900_seg_text, 0},
+
+  /* AORG is a commonly-used directive, but we will have to handle that
+     in the linker, since we can't assign a value for the target address
+     from within GAS. */
+  { "aorg",  s_ignore, 0},
+
+  /* TI convention for segments */
+  { "pseg",  tms9900_seg_text, 0},
+  { "pend",  s_ignore, 0},
+  { "cseg",  tms9900_seg_bss, 0},
+  { "cend",  tms9900_seg_text, 0},
+  { "dseg",  tms9900_seg_data, 0},
+  { "dend",  tms9900_seg_text, 0},
+
+  /* Reservation for data values */
+  { "bes",   tms9900_bss, 0},
+  { "bss",   tms9900_bss, 0},
+  { "byte",  tms9900_data, 1},
+  { "data",  tms9900_data, 2},
+  { "def",   s_globl, 0},
+  { "end",   s_ignore, 0},
+  { "even",  s_align_ptwo, 1},
+  { "ref",   s_ignore, 0},
+
+  /* The SYM directive displays a list of all symbols, and their values */
+  { "sym",   s_ignore, 0},
+  { "ntext", tms9900_text, TEXT_PRESIZE},
+  { "text",  tms9900_text, TEXT_DATAONLY},
+  { "textz", tms9900_text, TEXT_ZEROTERM},
+
+
+  /* Aliases for the text drirectives */
+  { "nstring", tms9900_text, TEXT_PRESIZE},
+  { "string",  tms9900_text, TEXT_DATAONLY},
+  { "stringz", tms9900_text, TEXT_ZEROTERM},
+
+  { NULL, 0, 0 }
+};
+
+
+/* This is used as the comparion functon for bsearch */
+static int
+key_cmp (const void * a, const void * b)
+{
+  static const char match_chars[] =
+    {
+      "0123456789"
+      "abcdefghijklnmopqrstuvwxyz"
+      "ABCDEFGHIJKLNMOPQRSTUVWXYZ"
+    };
+
+  const char *str_a = *((const char**)a);
+  const char *str_b = *((const char**)b);
+
+  /* Only match characters used in the bsearch tables */
+  int len_a = strspn (str_a, match_chars);
+  int len_b = strspn (str_b, match_chars);
+  int len = (len_a > len_b ? len_a : len_b);
+
+  return strncasecmp (str_a, str_b, len);
+}
+
+
+/* Skip a span of consecutive whitespace characters */
+static const char *
+skip_space (const char *s)
+{
+  return s + strspn (s, " \t");
+}
+
+
+/* Convert an argument to bits in the opcode for the current instruction */
+static char*
+assemble_mode (const char *line, short* opcode, expressionS* exp)
+{
+  /* Addressing mode encodings for the Ts field of the opcode */
+  static const MODE_DIRECT   = 0x00;  /* EX:  R1 */
+  static const MODE_INDIRECT = 0x10;  /* EX: *R1 */
+  static const MODE_OFFSET   = 0x20;  /* EX: @EXP, @EXP(R1) */
+  static const MODE_POSTINC  = 0x30;  /* EX: *R1+ */
+
+  char *p = (char*)line;
+  int use_paren = 0;  /* No open paren around register */
+  unsigned int char_count;
+  unsigned int reg_num;
+  struct reg_entry* regp;
+
+  *opcode = 0;
+  exp->X_op = O_absent;
+
+  if (*p == '*')
+    {
+      /* Indirect by register */
+      *opcode = MODE_INDIRECT;
+      p++;
+    }
+
+  else if (*p == '@')
+    {
+      /* Offset by expression */
+      *opcode = MODE_OFFSET;
+
+      /* This is an expression, parse it */
+      input_line_pointer = ++p;
+      expression (exp);
+      p = input_line_pointer;
+      if (*p == '(')
+        {
+          use_paren = 1;
+          p++;
+        }
+    }
+
+  if (*p != '*' &&
+      *p != ',' &&
+      *p != 0)
+    {
+      /* This term uses a register, let's find out which one */
+      regp = bsearch (&p, regtable, ARRAY_SIZE (regtable),
+                      sizeof (regtable[0]), key_cmp);
+      if (regp)
+        {
+          /* Handle register names (ex: "r1")*/
+          *opcode |= regp->number;
+          p += strlen (regp->name);
+        }
+      else
+        {
+          /* Handle register numnber (ex: "1") */
+          reg_num = atoi (p);
+          char_count = strspn (p, "0123456789");
+          if ((reg_num < reg_count) && (char_count > 0))
+            {
+              p += char_count;
+              *opcode |= reg_num;
+            }
+          else
+            {
+              printf ("Invalid register starting at \"%s\"\n", p);
+            }
+        }
+    }
+
+  /* Do we have a post-increment register? */
+  if ((*opcode & MODE_INDIRECT) && (*p == '+'))
+    {
+      *opcode |= MODE_POSTINC;
+      p++;
+    }
+
+  /* Cleanup end of parenthesis */
+  if (use_paren == 1)
+    {
+      if (*p == ')')
+        {
+          p++;
+        }
+      else
+        {
+          printf ("Unclosed paren around register\n");
+        }
+    }
+
+  input_line_pointer = p;
+  return p;
+}
+
+
+/* Convert numeric or symbolic data for the object file */
+static void
+tms9900_data (int size)
+{
+  char *u;
+
+  if (is_it_end_of_statement ())
+    {
+      /* Handle instructions which only allocate space */
+      demand_empty_rest_of_line ();
+      if (size > 0)
+        {
+          u = frag_more (size);
+          memset (u, 0, size);
+        }
+    }
+  else
+    {
+      cons (size);
+    }
+}
+
+
+/* Convert a string into a series of bytes for the object file */
+static void
+tms9900_text (int size)
+{
+  const char *p;
+  char *u, quote;
+  int cnt;
+  expressionS exp;
+
+  if (is_it_end_of_statement ())
+    {
+      /* Handle instructions which only allocate space */
+      demand_empty_rest_of_line ();
+      if (size > 0)
+        {
+          u = frag_more (size);
+          memset (u, 0, size);
+        }
+      return;
+    }
+
+  /* Skip to data value */
+  p = skip_space (input_line_pointer);
+
+  do
+    {
+      if (*p == '\"' || *p == '\'')
+	{
+          /* String constant, remove escape codes from string */
+          char q[1024];
+          char *out = q;
+          quote = *p++;
+          if (quote == '\'')
+          {
+            /* TI-style string, only handle escaped quote character
+               EX: 'hello!' */
+            while (p[0] && (p[0] != '\'' || (p[0] == '\'' && p[1] == '\'')))
+              {
+                if (p[0] == '\'' && p[1] == '\'') p++;
+                *out++ = *p++;
+              }
+            if (p[0] == '\'') p++;
+          }
+          else
+          {
+             /* C-style string, handle standard escape sequences
+                EX: "hello!" */
+             int c;
+             input_line_pointer = p;
+             while (is_a_char (c = next_char_of_string ()))
+             {
+               *out++ = c;
+             }
+             p = input_line_pointer;
+          }
+          *out = 0;
+          cnt = out - q;
+
+          /* Check for length and validity */
+          if (size > 0)
+            {
+              if (cnt > size)
+                {
+                  as_warn (_ ("string constant too long"));
+                  cnt = size;
+                }
+              u = frag_more (size);
+              if (size == 2 && cnt == 1) u[1] = q[0];
+                else  memcpy (u, q, cnt);
+            }
+          else if (size == TEXT_DATAONLY)
+            {
+              u = frag_more (cnt);
+              memcpy (u, q, cnt);
+            }
+          else if (size == TEXT_PRESIZE)
+            {
+              if (cnt > 255)
+                {
+                  as_warn (_ ("string constant too long"));
+                  cnt = 255;
+                }
+              u = frag_more (cnt+1);
+              *u = cnt;
+              memcpy (u + 1, q, cnt);
+            }
+          else if (size == TEXT_ZEROTERM)
+            {
+              u = frag_more (cnt + 1);
+              memcpy (u, q, cnt);
+              u[cnt] = 0;
+            }
+          if (!*p)
+            as_warn (_ ("unterminated string"));
+	}
+
+      p = skip_space (p);
+    }
+  while (*p++ == ',');
+  input_line_pointer = (char *)(p-1);
+}
+
+
+/* Handle a "bss" pseudocode to allocate a series of zero bytes */
+static void
+tms9900_bss (int unused ATTRIBUTE_UNUSED)
+{
+  expressionS exp;
+  expression (&exp);
+  if (exp.X_op == O_constant)
+    {
+      char* p = frag_more (exp.X_add_number);
+      memset (p, 0, exp.X_add_number);
+    }
+  else
+    {
+      as_bad (_ ("junk at end of line, first unrecognized character is `%c'"),
+              *input_line_pointer);
+    }
+}
+
+
+/* Handle a ".bss" directive to set the current memory section */
+static void
+tms9900_seg_bss (int unused ATTRIBUTE_UNUSED)
+{
+  subseg_set (bss_section, now_subseg);
+  demand_empty_rest_of_line ();
+}
+
+
+/* Handle a ".data" directive to set the current memory section */
+static void
+tms9900_seg_data (int unused ATTRIBUTE_UNUSED)
+{
+  subseg_set (data_section, now_subseg);
+  demand_empty_rest_of_line ();
+}
+
+
+/* Handle a ".text" directive to set the current memory section */
+static void
+tms9900_seg_text (int unused ATTRIBUTE_UNUSED)
+{
+  subseg_set (text_section, now_subseg);
+  demand_empty_rest_of_line ();
+}
+
+
+/* Assemble an argument of the current instruction */
+static int
+assemble_arg(int argtype, short *opcode, int *op_size, expressionS *exp)
+{
+  /* argtype - type of argument to parse
+     opcode  - bits to insert into opcode
+     op_size - size of opcode bits
+     expr    - expression for branch target or immediate value
+  */
+
+  char *start = input_line_pointer;
+
+  exp->X_op = O_absent;
+  *opcode = 0;
+  *op_size = 0;
+  int valid = 0;
+
+  if (argtype == ARG_MODE)
+    {
+      assemble_mode (input_line_pointer, opcode, exp);
+      *op_size = 6;
+      valid = 1;
+    }
+  else if (argtype != ARG_NONE)
+    {
+      char *ptr = input_line_pointer;
+      expression (exp);
+      switch (argtype)
+        {
+          /* Branch offset */
+          case ARG_OFFSET:
+            if (exp->X_op == O_constant ||
+                exp->X_op == O_symbol)
+              {
+                valid = 1;
+              }
+            if (exp->X_op == O_constant)
+              {
+                *opcode = (exp->X_add_number >> 1) & 0xFF;
+                *op_size = 8;
+                exp->X_op = O_absent;
+              }
+            break;
+
+          /* Register number */
+          case ARG_REGISTER:
+            if (exp->X_op == O_register ||
+               /* The expression parser cannot handle numeric registers.
+                  Instructions like "mov 1,2" must be handled here
+               */
+                (exp->X_op == O_constant &&
+                  (unsigned int)exp->X_add_number < 16))
+              {
+                *opcode = exp->X_add_number;
+                *op_size = 4;
+                exp->X_op = O_absent;
+                valid = 1;
+              }
+            else
+              {
+                as_bad (_ ("not a register '%s'"), start);
+              }
+            break;
+
+          /* 16-bit immediate value */
+          case ARG_IMMEDIATE:
+            if (exp->X_op == O_constant && *ptr++ == '\'')
+              {
+                /* Could be a constant like 'a' or 'ab'
+                   These values can be no longer than two characters.
+                   Since TI escapes the single quote by duplication,
+                   the code below is uglier than it needs to be.
+
+                   Expected translations:
+                     ''     -> 0x0027
+                     ''''   -> 0x0027
+                     '''''' -> 0x2727
+                */
+                int i, val = 0;
+                for (i = 0; i < 2; i++)
+                  {
+                    if (*ptr == '\'' && ptr[1] == '\'') ptr++;
+                    val = (val << 8) | *ptr++;
+                    if ((*ptr == '\'' && ptr[1]!='\'') ||
+                       *ptr == 0    ||
+                       *ptr == '\n') break;
+                  }
+                if (*ptr == '\n' ||
+                    *ptr == 0) as_warn (_ ("unterminated string"));
+                else if (*ptr != '\'' ||
+                         (*ptr == '\'' && ptr[1] == '\''))
+                  {
+                    as_warn (_ ("constant too big"));
+                  }
+
+                /* Use the value we found */
+                exp->X_add_number = val;
+                valid = 1;
+              }
+            else if (exp->X_op == O_constant ||
+                     exp->X_op == O_symbol)
+              {
+                valid = 1;
+              }
+            else
+              {
+                as_bad (_ ("not a constant expression '%s'"), start);
+              }
+            break;
+
+          /* Bit shift count */
+          case ARG_SHIFT:
+            if (exp->X_op == O_constant ||
+                (exp->X_op == O_register && exp->X_add_number == 0))
+              {
+                *opcode = exp->X_add_number;
+                *op_size = 4;
+                exp->X_op = O_absent;
+                valid = 1;
+              }
+            break;
+
+          /* CRU bit count */
+          case ARG_CRU_COUNT:
+            if (exp->X_op == O_constant)
+              {
+                *opcode = exp->X_add_number;
+                *op_size = 4;
+                exp->X_op = O_absent;
+                valid = 1;
+              }
+            else
+              {
+                as_bad (_ ("not a constant expression '%s'"), input_line_pointer);
+              }
+            break;
+
+          /* CRU displacement */
+          case ARG_CRU_DISP:
+            if (exp->X_op == O_constant)
+              {
+                *opcode = exp->X_add_number;
+                *op_size = 8;
+                exp->X_op = O_absent;
+                valid = 1;
+              }
+            else
+              {
+                as_bad (_ ("not a constant expression '%s'"), input_line_pointer);
+              }
+            break;
+        }
+    }
+
+  if(input_line_pointer == start)
+    {
+      as_bad (_ ("missing argument"));
+      return 0;
+    }
+
+  /* If we found an invalid argument, revert everything done here */
+  if(valid == 0)
+    {
+      exp->X_op = O_absent;
+      input_line_pointer = start;
+    }
+  return valid;
+}
+
+
+/* Handler called at the start of a new line of the assembly source file */
+int
+tms9900_start_line_hook (void)
+{
+  /* Elements of code grammar */
+  enum
+    {
+      ST_START,         /* Start of line */
+      ST_LABEL,         /* Code label */
+      ST_PRE_DIRECTIVE, /* Space before directive or mnemonic*/
+      ST_DIRECTIVE,     /* Assembly directive */
+      ST_PRE_OPTION,    /* Space before directive option */
+      ST_OPTION,        /* Directive option */
+      ST_MNEMONIC,      /* Opcode mnemonic */
+      ST_PRE_ARGUMENT,  /* Space before argument */
+      ST_ARGUMENT,      /* Non-string argument */
+      ST_POST_ARGUMENT, /* Space or comma after argument */
+      ST_TI_STRING,     /* TI-style string */
+      ST_GAS_STRING,    /* GAS-style string */
+      ST_POST_STRING,   /* Space or comma after string */
+      ST_COMMENT        /* Comment at end of line */
+    };
+  int state = ST_START;
+  char *p;
+
+  for (p = input_line_pointer; *p && *p != '\n'; ++p)
+    {
+      switch (state)
+        {
+          case ST_START:
+            if (strchr(" \t",*p)) state = ST_PRE_DIRECTIVE;
+            else if (*p == '*') state = ST_COMMENT;
+            else state = ST_LABEL;
+            p--;
+            break;
+
+          case ST_LABEL:
+            if (strchr (" \t",p[1])) state = ST_PRE_DIRECTIVE;
+            break;
+
+          case ST_PRE_DIRECTIVE:
+            if (strchr (" \t",p[1]) == NULL)
+              {
+                if (p[1] == '.') state = ST_DIRECTIVE;
+                else if (p[1] == '*') state = ST_COMMENT;
+                else state = ST_MNEMONIC;
+              }
+            break;
+
+          case ST_DIRECTIVE:
+            if (strchr (" \t",p[1])) state = ST_PRE_OPTION;
+            break;
+
+          case ST_PRE_OPTION:
+            if (strchr (" \t",p[1]) == NULL) state = ST_OPTION;
+            break;
+
+          case ST_OPTION:
+            if (strchr (" \t",p[1])) state = ST_OPTION;
+            if (p[0] == '*') {p--; state = ST_COMMENT;}
+            break;
+
+          case ST_MNEMONIC:
+            if (strchr (" \t",p[1])) state = ST_PRE_ARGUMENT;
+            break;
+
+          case ST_PRE_ARGUMENT:
+            if (strchr(" \t",p[0]) == NULL)
+              {
+                if (p[0] == '\'') state = ST_TI_STRING;
+                else if (p[0] == '"') state = ST_GAS_STRING;
+                else {state = ST_ARGUMENT; p--;}
+              }
+            break;
+
+          case ST_ARGUMENT:
+            if (p[0] == '>' && strchr("0123456789abcdefABCDEF", p[1])) p[0] = '$';
+            if (strchr (" \t,",p[1]))
+              {
+                if (p[0] == '*') {p--; state = ST_COMMENT;}
+                else state = ST_POST_ARGUMENT;
+              }
+            break;
+
+          case ST_POST_ARGUMENT:
+            if (strchr (" \t",p[0]) == NULL)
+              {
+                if (p[0] == ',') state = ST_PRE_ARGUMENT;
+                else {p--; state = ST_COMMENT;}
+              }
+            break;
+
+          case ST_TI_STRING:
+            if (p[0] == '\'' && p[1] == '\'') p++;  /* Skip escaped quote */
+            else if (p[0] == '\'') state = ST_POST_STRING;
+            break;
+
+          case ST_GAS_STRING:
+            if (p[0] == '\\' && p[1] == '"') p++;  /* Skip escaped quote */
+            else if (p[0] == '"') state = ST_POST_STRING;
+            break;
+
+          case ST_POST_STRING:
+            if (strchr(" \t", *p) == NULL)
+              {
+                if (*p == ',') state = ST_PRE_ARGUMENT;
+                else {p--; state = ST_COMMENT;}
+              }
+            break;
+
+          case ST_COMMENT:
+            memset(p, ' ', strcspn(p,"\n"));
+            state = ST_PRE_ARGUMENT;
+            break;
+        }
+    }
+
+  /* Remove trailing whitespace */
+  p = input_line_pointer;
+  p += strcspn (p, "\n");
+  char *line_end = p;
+  while (p > input_line_pointer && strchr (" \t\n", p[0])) p--;
+  if (p > input_line_pointer)
+    {
+      /* Remove characters occupied by trailing whitespace */
+      p++;
+      memmove (p, line_end,strlen (line_end) + 1);
+      memset (&p[strlen(p)], 0, line_end - p);
+    }
+
+  /* Check for <label>[:] [.](EQU|BES) <value>.  */
+  if (is_name_beginner (*input_line_pointer))
+    {
+      char *rest, *line_start;
+      int code;
+      int len = 3;  /* Length of directive */
+      symbolS * symbolP;
+
+      line_start = input_line_pointer;
+      LISTING_NEWLINE ();
+      if (ignore_input ())
+	return 0;
+
+      rest = input_line_pointer + 1;
+
+      if (*rest == ':')
+	++rest;
+      if (*rest == ' ' || *rest == '\t')
+	++rest;
+      if (*rest == '.')
+	++rest;
+      if (strncasecmp (rest, "EQU", 3) == 0)
+	code = 1;
+      else if (strncasecmp (rest, "BES", 3) == 0)
+        code = 2;
+      else
+	code = 0;
+
+      if (code && (rest[len] == ' ' || rest[len] == '\t'))
+	{
+          if (code == 1)
+            {
+              /* This is an EQU operative */
+              /* Handle assignment here.  */
+              input_line_pointer = rest + len;
+              if (line_start[-1] == '\n')
+                bump_line_counters ();
+              /* Make sure we don't redefine an existing equate */
+              if ((symbolP = symbol_find (line_start)) != NULL)
+                {
+                  if (S_IS_DEFINED (symbolP) || symbol_equated_p (symbolP))
+                    as_bad (_("symbol `%s' is already defined"), line_start);
+                }
+              equals (line_start, 1);
+              return 1;
+            }
+          else if (code == 2)
+            {
+              /* This is a BES operative */
+              /* Allocate space */
+              input_line_pointer = rest + 3;
+              tms9900_bss (0);
+              /* Move label to after allocation */
+              while (rest-- > line_start)
+                {
+                  (input_line_pointer--)[-1] = rest[-1];
+                }
+            }
+	}
+      else
+	{
+	  /* Restore line and pointer.  */
+	  input_line_pointer = line_start;
+	}
+    }
+  return 0;
+}
+
+
+/* This is called when an unrecognized symbol is encountered while
+   parsing an expression. */
+int
+tms9900_parse_name (const char* name, struct expressionS* expr)
+{
+    struct reg_entry* regp;
+    regp = bsearch (&name, regtable, ARRAY_SIZE (regtable),
+                    sizeof (regtable[0]), key_cmp);
+    if(regp && strcmp (name, regp->name)==0)
+    {
+      expr->X_op = O_register;
+      expr->X_add_number = regp->number;
+      input_line_pointer = (char*)name + strlen(regp->name);
+      return 1;
+    }
+  return 0;
+}
+
+
+/* Generate a relocation fixup record to apply to an address */
+void
+tms9900_cons_fix_new (fragS *frag_p, int offset, int nbytes, expressionS *exp,
+                      bfd_reloc_code_real_type r)
+{
+  int pcrel = 0;
+  if (r == BFD_RELOC_NONE)
+  {
+    if (nbytes == 1)
+    {
+      pcrel = 1;
+      r = BFD_RELOC_8_PCREL;
+    }
+    else if (nbytes == 2)
+    {
+      r = BFD_RELOC_16;
+    }
+    else if (nbytes == 4)
+    {
+      /* Place relocation into low word. Leave high word as zero */
+      r = BFD_RELOC_16;
+      offset += 2;
+    }
+    else
+      as_bad (_ ("unsupported BFD relocation size %u"), nbytes);
+  }
+
+  fix_new_exp (frag_p, offset, nbytes, exp, pcrel, r);
+}
+
+
+/* GAS will call this handler whenever "getopt" encounters an unrecognized
+   command-line option */
+int
+md_parse_option (int c, const char* arg ATTRIBUTE_UNUSED)
+{
+  switch (c)
+    {
+    default:
+      return 0;
+    }
+}
+
+
+/* GAS will call this handler to print available target-specific command-line
+   options */
+void
+md_show_usage (FILE * f)
+{
+  fprintf (f,"\n");
+}
+
+
+/* GAS will call this function at the start of the assembly, after the command
+   line arguments have been parsed and all the machine independent
+   initializations have been completed */
+void
+md_begin (void)
+{
+  /* We do not use relaxation */
+  linkrelax = 0;
+
+  /* Specify the target machine */
+  bfd_set_arch_mach (stdoutput, TARGET_ARCH, bfd_mach_tms9900);
+}
+
+
+/* GAS will call this function when a symbol table lookup fails, before it
+   creates a new symbol */
+symbolS *
+md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
+{
+  return NULL;
+}
+
+
+/* This function is called to convert an ASCII string into a floating point
+   value in format used by the CPU */
+const char *
+md_atof (int type ATTRIBUTE_UNUSED, char *litP ATTRIBUTE_UNUSED,
+	 int *sizeP ATTRIBUTE_UNUSED)
+{
+  return _("floating point numbers are not implemented");
+}
+
+
+/* GAS will call this function for each section at the end of the assembly, to
+   permit the CPU backend to adjust the alignment of a section */
+valueT
+md_section_align (segT seg ATTRIBUTE_UNUSED, valueT size)
+{
+  return size;
+}
+
+
+/* This function will return the position from which the PC relative adjustment
+   for a PC relative fixup should be made */
+long
+md_pcrel_from (fixS * fixp)
+{
+  return fixp->fx_where + fixp->fx_frag->fr_address + 1;
+}
+
+
+/* GAS will call this function for each input line which does not contain a
+   pseudo-op.  The argument is a null terminated string.  The function should
+   assemble the string as an instruction with operands */
+void
+md_assemble (char* str)
+{
+  static char buf[8];  /* Large enough for any keyword. */
+  static const int BUFLEN = sizeof(buf);
+  static const char *key = buf;
+
+  const char *p;
+  char * old_ptr;
+  int i;
+  table_t *insp;
+  short opcode[2];
+  int op_size[2];
+  expressionS exp[2];
+  char *out;
+  short insn;
+  int check_unex = 0;
+
+  /* Skip leading spaces */
+  old_ptr = input_line_pointer;
+  p = skip_space (str);
+
+  /* Convert opcode to lowercase */
+  for (i = 0; (i < BUFLEN) && (ISALPHA (*p));)
+    {
+      buf[i++] = TOLOWER (*p++);
+    }
+
+  if (i == BUFLEN)
+    {
+      /* Opcode too long */
+      buf[BUFLEN-3] = buf[BUFLEN-2] = '.'; /* Mark opcode as abbreviated.  */
+      buf[BUFLEN-1] = 0;
+      as_bad (_ ("unknown instruction '%s'"), buf);
+    }
+  else if ((*p) && (!ISSPACE (*p)))
+    {
+      as_bad (_ ("syntax error"));
+    }
+  else
+    {
+      /* Check for valid opcode */
+      buf[i] = 0;
+      p = skip_space (p);
+      key = buf;
+
+      insp = bsearch (&key, instab, ARRAY_SIZE (instab),
+		    sizeof (instab[0]), key_cmp);
+      if (!insp)
+        {
+	  as_bad (_ ("unknown instruction '%s'"), buf);
+        }
+      else
+	{
+          /* Skip to start of arguments, if we have any */
+          input_line_pointer = str + strlen(insp->name);
+          input_line_pointer = (char*)skip_space (input_line_pointer);
+
+          /* Initialize arguments */
+          for (i = 0; i < 2; i++)
+            {
+              exp[i].X_op = O_absent;
+              op_size[i] = 0;
+              opcode[i] = 0;
+            }
+
+          /* Parse arguments */
+          if (insp->arg[0] != ARG_NONE)
+            {
+              /* Parse first argument */
+              if (assemble_arg (insp->arg[0], &opcode[0], &op_size[0], &exp[0]) != 0)
+                {
+                  check_unex = 1;
+                  if (insp->arg[1] != ARG_NONE)
+                    {
+                      /* Parse second argument */
+                      if (*input_line_pointer != ',')
+                        {
+                          if (*input_line_pointer == 0)
+                            {
+                              as_bad (_ ("unexpected end of line"));
+                              check_unex = 0;
+                            }
+                          else
+                            {
+                              char str[64];
+                              sprintf (str, "unexpected character at \"%s\"",
+                                       input_line_pointer);
+                              as_bad (str);
+                              check_unex = 0;
+                            }
+                        }
+                      else
+                        {
+                          input_line_pointer++;
+                          if (assemble_arg (insp->arg[1], &opcode[1], &op_size[1], &exp[1]))
+                            {
+                              /* Second argument is valid, rest is comment */
+                              check_unex = 0;
+                            }
+                        }
+                    }
+                }
+            }
+
+          /* Check for unexpected characters */
+          if (check_unex != 0 &&
+              *input_line_pointer != 0 &&
+              strspn (input_line_pointer, " *") == 0)
+            {
+              char str[64];
+              sprintf (str, "unexpected character at \"%s\"", input_line_pointer);
+              as_bad (str);
+            }
+
+          /* Make output instruction */
+          insn = insp->opcode |
+                 opcode[0]    |
+                 (opcode[1] << op_size[0]);
+
+          out = frag_more(2);
+          *out++ = ((insn >> 8) & 0xFF);
+          *out   =  (insn       & 0xFF);
+
+          /* Insert extra words and fixups */
+          for (i=0; i<2; i++)
+            {
+              if (exp[i].X_op != O_absent)
+                {
+                  /* Assume no fixup required */
+                  int reloc_type = BFD_RELOC_NONE;
+                  int fix_size = 0;
+
+                  if (insp->arg[i] == ARG_OFFSET)
+                    {
+                      /* 8-bit PC-relative offset, stored in instruction */
+                      reloc_type = BFD_RELOC_8_PCREL;
+                      fix_size = 1;
+                    }
+                  else
+                    {
+                      /* 16-bit constant value, stored after instruction */
+                      unsigned short val = 0;
+                      out = frag_more (2);
+                      reloc_type = BFD_RELOC_16;
+                      fix_size = 2;
+                      if (exp[i].X_op == O_constant)
+                        {
+                          val = (exp[i].X_add_number & 0xFFFF);
+                          fix_size = 0;
+                        }
+                      out[0] = ((val >> 8) & 0xFF);
+                      out[1] =  (val       & 0xFF);
+                    }
+
+                  if (fix_size != 0)
+                    {
+                      /* Fixup used for this instruction, configure it */
+                      fix_new_exp (frag_now,
+                                   out - frag_now->fr_literal,
+                                   fix_size,
+                                   &exp[i],
+                                   0,
+                                   reloc_type);
+                    }
+                }
+            }
+        }
+    }
+
+  input_line_pointer = old_ptr;
+}
+
+
+/* GAS will call this function with one argument, an expressionS pointer,
+   for any expression that can not be recognized.  When the function is called,
+   "input_line_pointer" will point to the start of the expression */
+void
+md_operand (expressionS* exp ATTRIBUTE_UNUSED)
+{
+  printf("Unrecognized expression: \"%s\"\n", input_line_pointer);
+}
+
+
+/* GAS will call this for each fixup that passes the TC_VALIDATE_FIX test when
+   linkrelax is not set.  It should store the correct value in the object file */
+void
+md_apply_fix (fixS * fixP, valueT* valP, segT seg ATTRIBUTE_UNUSED)
+{
+  long val = * (long *) valP;
+  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
+
+  switch (fixP->fx_r_type)
+    {
+    case BFD_RELOC_8_PCREL:
+      if (fixP->fx_addsy)
+        {
+          fixP->fx_no_overflow = 1;
+          fixP->fx_done = 0;
+        }
+      else
+        {
+	  fixP->fx_no_overflow = (-128 <= val && val < 128);
+	  if (!fixP->fx_no_overflow)
+            {
+              as_bad_where (fixP->fx_file, fixP->fx_line,
+                            _("relative jump out of range"));
+            }
+	  *buf++ = val;
+          fixP->fx_done = 1;
+        }
+      break;
+
+    case BFD_RELOC_16:
+      *buf++ = (val >> 8);
+      *buf++ = val;
+      fixP->fx_no_overflow = 1;
+      if (fixP->fx_addsy == NULL)
+	fixP->fx_done = 1;
+      break;
+
+    default:
+      printf (_ ("md_apply_fix: unknown r_type 0x%x\n"), fixP->fx_r_type);
+      abort ();
+    }
+}
+
+/* GAS will call this to generate a reloc.  GAS will pass the
+   resulting reloc to `bfd_install_relocation'.  This currently works
+   poorly, as `bfd_install_relocation' often does the wrong thing, and
+   instances of `tc_gen_reloc' have been written to work around the
+   problems, which in turns makes it difficult to fix
+   `bfd_install_relocation'.  */
+arelent *
+tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED , fixS *fixp)
+{
+  arelent *reloc;
+
+  if (! bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type))
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("reloc %d not supported by object file format"),
+		    (int) fixp->fx_r_type);
+      return NULL;
+    }
+
+  reloc               = xmalloc (sizeof (arelent));
+  reloc->sym_ptr_ptr  = xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address      = fixp->fx_frag->fr_address + fixp->fx_where;
+  reloc->howto        = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+  reloc->addend       = fixp->fx_offset;
+
+  return reloc;
+}
+
diff -rupN binutils-2.40-original/gas/config/tc-tms9900.c.org binutils-2.40/gas/config/tc-tms9900.c.org
--- binutils-2.40-original/gas/config/tc-tms9900.c.org	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.40/gas/config/tc-tms9900.c.org	2024-03-10 16:38:19.725164841 -0400
@@ -0,0 +1,1293 @@
+/* tc-tms9900.c -- Assemble code for the Texas Instruments TMS9900
+   Copyright 2009 Eric Welser
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include "as.h"
+#include "safe-ctype.h"
+#include "subsegs.h"
+
+
+/* Exported constants.  */
+const char line_separator_chars[] = "\0";
+const char EXP_CHARS[] = "eE\0";
+const char FLT_CHARS[] = "RrFf\0";
+const char line_comment_chars[] = "#\0";
+
+/* The TMS9900 assembly format specifies "*" for the start of comments.
+   Unfortunately, that character is also used in register expressions.
+   So we have to manually handle comments here, and cannot rely on GAS's
+   normal comment parsing */
+const char tms9900_comment_chars[] = "#;\0";
+
+/* List of chars besides those in app.c:symbol_chars that can start an
+   operand.  Used to prevent the scrubber eating vital white-space.
+   We use this to determine if the asterisk is the start of a comment */
+const char tms9900_symbol_chars[] = "+*\0";
+
+/* For machine specific options.  */
+const char * md_shortopts = ""; /* None yet.  */
+
+struct option md_longopts[] =
+{
+  { NULL, no_argument, NULL, 0 }
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+
+extern int coff_flags;
+
+
+int
+md_parse_option (int c, const char* arg ATTRIBUTE_UNUSED)
+{
+  switch (c)
+    {
+    default:
+      return 0;
+    }
+}
+
+
+void
+md_show_usage (FILE * f)
+{
+  fprintf (f,"\n");
+}
+
+static symbolS * zero;
+
+
+void
+md_begin (void)
+{
+  expressionS nul;
+  char * p;
+
+  p = input_line_pointer;
+  input_line_pointer = "0";
+  nul.X_md = 0;
+  expression (& nul);
+  input_line_pointer = p;
+  zero = make_expr_symbol (& nul);
+  /* We do not use relaxation (yet).  */
+  linkrelax = 0;
+
+  bfd_set_arch_mach (stdoutput, TARGET_ARCH, bfd_mach_tms9900);
+}
+
+
+static const char *
+skip_space (const char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    ++s;
+  return s;
+}
+
+
+symbolS *
+md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
+{
+  return NULL;
+}
+
+
+const char *
+md_atof (int type ATTRIBUTE_UNUSED, char *litP ATTRIBUTE_UNUSED,
+	 int *sizeP ATTRIBUTE_UNUSED)
+{
+  return _("floating point numbers are not implemented");
+}
+
+
+valueT
+md_section_align (segT seg ATTRIBUTE_UNUSED, valueT size)
+{
+  return size;
+}
+
+
+long
+md_pcrel_from (fixS * fixp)
+{
+  return fixp->fx_where +
+    fixp->fx_frag->fr_address + 1;
+}
+
+
+/* Compares the key for structs that start with a char * to the key.  */
+static int
+key_cmp (const void * a, const void * b)
+{
+  const char *str_a, *str_b;
+
+  str_a = *((const char**)a);
+  str_b = *((const char**)b);
+  return strcmp (str_a, str_b);
+}
+
+
+static int
+key_regcmp (const void * a, const void * b)
+{
+  const char *str_a, *str_b;
+
+  str_a = *((const char**)a);
+  str_b = *((const char**)b);
+  return strncasecmp (str_a, str_b, strlen (str_b));
+}
+
+
+#define BUFLEN 8 /* Large enough for any keyword.  */
+
+char buf[BUFLEN];
+const char *key = buf;
+
+static const struct reg_entry
+{
+  char* name;
+  int number;
+} regtable[] =
+{
+  {"cb",  12 },  /* CRU base */
+  {"lp",  14 },  /* Old Program Counter register after BLWP */
+  {"lr",  11 },  /* Return address after BL */
+  {"ls",  15 },  /* Old Status Register after BLWP */
+  {"lw",  13 },  /* Old Workspace Register after BLWP */
+  {"r0",   0 },
+  {"r1",   1 },
+  {"r10", 10 },
+  {"r11", 11 },
+  {"r12", 12 },
+  {"r13", 13 },
+  {"r14", 14 },
+  {"r15", 15 },
+  {"r2",   2 },
+  {"r3",   3 },
+  {"r4",   4 },
+  {"r5",   5 },
+  {"r6",   6 },
+  {"r7",   7 },
+  {"r8",   8 },
+  {"r9",   9 },
+  {"sp",  10 }   /* Stack pointer */
+} ;
+
+/* Prevent an error on a line from also generating
+   a "junk at end of line" error message.  */
+static char err_flag;
+
+static void tms9900_bss (int unused ATTRIBUTE_UNUSED);
+
+
+int
+tms9900_start_line_hook (void)
+{
+  /* Elements of code grammar */
+  enum
+    {
+      ST_START,         /* Start of line */
+      ST_LABEL,         /* Code label */
+      ST_PRE_DIRECTIVE, /* Space before directive or mnemonic*/
+      ST_DIRECTIVE,     /* Assembly directive */
+      ST_PRE_OPTION,    /* Space before directive option */
+      ST_OPTION,        /* Directive option */
+      ST_MNEMONIC,      /* Opcode mnemonic */
+      ST_PRE_ARGUMENT,  /* Space before argument */
+      ST_ARGUMENT,      /* Non-string argument */
+      ST_POST_ARGUMENT, /* Space or comma after argument */
+      ST_TI_STRING,     /* TI-style string */
+      ST_GAS_STRING,    /* GAS-style string */
+      ST_POST_STRING,   /* Space or comma after string */
+      ST_COMMENT        /* Comment at end of line */
+    };
+  int state = ST_START;
+  char *p;
+
+  for (p = input_line_pointer; *p && *p != '\n'; ++p)
+    {
+      switch (state)
+        {
+          case ST_START:
+          if (strchr(" \t",*p)) state = ST_PRE_DIRECTIVE;
+          else if (*p == '*') state = ST_COMMENT;
+          else state = ST_LABEL;
+          p--;
+          break;
+
+          case ST_LABEL:
+          if (strchr (" \t",p[1])) state = ST_PRE_DIRECTIVE;
+          break;
+
+          case ST_PRE_DIRECTIVE:
+          if (strchr (" \t",p[1]) == NULL)
+            {
+              if (p[1] == '.') state = ST_DIRECTIVE;
+              else if (p[1] == '*') state = ST_COMMENT;
+              else state = ST_MNEMONIC;
+            }
+          break;
+
+          case ST_DIRECTIVE:
+          if (strchr (" \t",p[1])) state = ST_PRE_OPTION;
+          break;
+
+          case ST_PRE_OPTION:
+          if (strchr (" \t",p[1]) == NULL) state = ST_OPTION;
+          break;
+
+          case ST_OPTION:
+          if (strchr (" \t",p[1])) state = ST_OPTION;
+          if (p[0] == '*') {p--; state = ST_COMMENT;}
+          break;
+
+          case ST_MNEMONIC:
+          if (strchr (" \t",p[1])) state = ST_PRE_ARGUMENT;
+          break;
+
+          case ST_PRE_ARGUMENT:
+          if (strchr(" \t",p[0]) == NULL)
+            {
+              if (p[0] == '\'') state = ST_TI_STRING;
+              else if (p[0] == '"') state = ST_GAS_STRING;              
+              else {state = ST_ARGUMENT; p--;}
+            }
+          break;
+
+          case ST_ARGUMENT:
+          if (p[0] == '>' && strchr("0123456789abcdefABCDEF", p[1])) p[0] = '$';
+          if (strchr (" \t,",p[1]))
+            {
+              if (p[0] == '*') {p--; state = ST_COMMENT;}
+              else state = ST_POST_ARGUMENT;
+            }
+          break;
+
+          case ST_POST_ARGUMENT:
+          if (strchr (" \t",p[0]) == NULL)
+            {
+              if (p[0] == ',') state = ST_PRE_ARGUMENT;
+              else {p--; state = ST_COMMENT;}
+            }
+          break;
+
+          case ST_TI_STRING:
+          if (p[0] == '\'' && p[1] == '\'') p++;  /* Skip escaped quote */
+          else if (p[0] == '\'') state = ST_POST_STRING;
+          break;
+
+          case ST_GAS_STRING:
+          if (p[0] == '\\' && p[1] == '"') p++;  /* Skip escaped quote */
+          else if (p[0] == '"') state = ST_POST_STRING;
+          break;
+
+          case ST_POST_STRING:
+          if (strchr(" \t", *p) == NULL)
+            {
+              if (*p == ',') state = ST_PRE_ARGUMENT;
+              else {p--; state = ST_COMMENT;}
+            }
+          break;
+
+          case ST_COMMENT:
+          memset(p, ' ', strcspn(p,"\n"));
+          state = ST_PRE_ARGUMENT;
+          break;
+        }
+    }
+  /* Remove trailing whitespace */
+  p = input_line_pointer;
+  p += strcspn (p, "\n");
+  char *line_end = p;
+  while (p > input_line_pointer && strchr (" \t\n", p[0])) p--;
+  if (p > input_line_pointer)
+    {
+      /* Remove characters occupied by trailing whitespace */
+      p++;
+      memmove (p, line_end,strlen (line_end) + 1);
+      memset (&p[strlen(p)], 0, line_end - p);
+    }
+
+  /* Check for <label>[:] [.](EQU|BES) <value>.  */
+  if (is_name_beginner (*input_line_pointer))
+    {
+      char *rest, *line_start;
+      int code;
+      int len = 3;  /* Length of directive */
+      symbolS * symbolP;
+
+      line_start = input_line_pointer;
+      LISTING_NEWLINE ();
+      if (ignore_input ())
+	return 0;
+
+      rest = input_line_pointer + 1;
+
+      if (*rest == ':')
+	++rest;
+      if (*rest == ' ' || *rest == '\t')
+	++rest;
+      if (*rest == '.')
+	++rest;
+      if (strncasecmp (rest, "EQU", 3) == 0)
+	code = 1;
+      else if (strncasecmp (rest, "BES", 3) == 0)
+        code = 2;
+      else
+	code = 0;
+
+      if (code && (rest[len] == ' ' || rest[len] == '\t'))
+	{
+          if (code == 1)
+            {
+              /* This is an EQU operative */
+              /* Handle assignment here.  */
+              input_line_pointer = rest + len;
+              if (line_start[-1] == '\n')
+                bump_line_counters ();
+              /* Make sure we don't redefine an existing equate */
+              if ((symbolP = symbol_find (line_start)) != NULL) 
+                {
+                  if (S_IS_DEFINED (symbolP) || symbol_equated_p (symbolP))
+                    as_bad (_("symbol `%s' is already defined"), line_start);
+                }
+              equals (line_start, 1);
+              return 1;
+            }
+          else if (code == 2)
+            {
+              /* This is a BES operative */
+              /* Allocate space */
+              input_line_pointer = rest + 3;
+              tms9900_bss (0);
+              /* Move label to after allocation */
+              while (rest-- > line_start)
+                {
+                  (input_line_pointer--)[-1] = rest[-1];
+                }
+            }
+	}
+      else
+	{
+	  /* Restore line and pointer.  */
+	  input_line_pointer = line_start;
+	}
+    }
+  return 0;
+}
+
+
+int
+tms9900_parse_name (const char* name, struct expressionS* expr)
+{
+    struct reg_entry* regp;
+    regp = bsearch (&name, regtable, ARRAY_SIZE (regtable),
+                    sizeof (regtable[0]), key_regcmp);
+    if(regp && strcmp (name, regp->name)==0)
+    {
+      expr->X_op = O_register;
+      expr->X_add_number = regp->number;
+      input_line_pointer = (char*)name + strlen(regp->name);
+      return (1); 
+    }
+  return (0);
+}
+
+
+static char*
+assemble_mode (const char *line, short* opcode, expressionS* exp)
+{
+  /*
+   Encodings for the Ts field of the opcode
+   00 -  REG
+   01 - *REG
+   11 - *REG+
+   10 - @EXP      reg=0
+   10 - @EXP(REG)
+  */
+  char *p = (char*)line;
+  int open = 0;  /* No open paren around register */
+  int maybe_increment = 0;
+  *opcode = 0;
+  exp->X_op = O_absent;
+
+  if (*p == '*')
+    {
+      /* Indirect by register */
+      *opcode = 0x10;
+      maybe_increment = 1;
+      p++;
+    }
+  else if (*p == '@')
+    {
+      /* Indirect by expression */
+      *opcode = 0x20;
+      /* This is an expression, parse it */
+      input_line_pointer = ++p;
+      expression (exp);
+      p = input_line_pointer;
+      if (*p == '(')
+        {
+          open = 1;
+          p++;
+        }
+    }
+
+  if (*p != '*' &&
+      *p != ',' &&
+      *p != 0)
+    {
+      /* This term uses a register, let's find out which one */
+      struct reg_entry* regp;
+      regp = bsearch (&p, regtable, ARRAY_SIZE (regtable),
+                      sizeof (regtable[0]), key_regcmp);
+      if (regp)
+        {
+          *opcode |= regp->number;
+          p += strlen (regp->name);
+        }
+      else
+        {
+          /* Handle registers in numeric format */
+          unsigned int regnum=256;
+          if (sscanf (p,"%u", &regnum) && regnum < 16)
+            {
+              p++;
+              if (regnum > 9) p++;
+              *opcode |= regnum;
+            }
+          else
+            {
+              printf ("Invalid register starting at \"%s\"\n", p);
+            }
+        }
+    }
+
+  /* Do we have register post increment? */
+  if (maybe_increment == 1 && *p == '+')
+    {
+      *opcode |= 0x20;
+      p++;
+    }
+  
+  /* Cleanup end of parameter */
+  if (open == 1)
+    {
+      if (*p == ')')  p++;
+        else printf ("Unclosed paren around register\n");
+    }
+
+  input_line_pointer = p;        
+  return (p);
+}
+
+
+void
+tms9900_cons_fix_new (fragS *frag_p, int offset, int nbytes, expressionS *exp,
+                      bfd_reloc_code_real_type r)
+{
+  int pcrel = 0;
+  if (r == BFD_RELOC_NONE)
+  {
+    if (nbytes == 1)
+    {
+      pcrel = 1;
+      r = BFD_RELOC_8_PCREL;
+    }
+    else if (nbytes == 2)
+    {
+      r = BFD_RELOC_16;
+    }
+    else if (nbytes == 4)
+    {
+      /* Place relocation into low word. Leave high word as zero */
+      r = BFD_RELOC_16;
+      offset += 2;
+    }
+    else
+      as_bad (_ ("unsupported BFD relocation size %u"), nbytes);
+  }
+
+  fix_new_exp (frag_p, offset, nbytes, exp, pcrel, r);
+}
+
+
+enum
+{
+  TEXT_DATAONLY = -1,
+  TEXT_PRESIZE  = -2,
+  TEXT_ZEROTERM = -3
+};
+
+
+static void
+tms9900_data (int size)
+{
+  const char *p;
+  char *u, quote;
+  int cnt;
+  expressionS exp;
+
+  if (is_it_end_of_statement ())
+    {
+      /* Handle instructions which only allocate space */
+      demand_empty_rest_of_line ();
+      if (size > 0)
+        {
+          u = frag_more (size);
+          memset (u, 0, size);
+        }
+      return;
+    }
+
+  /* Skip to data value */  
+  p = skip_space (input_line_pointer);
+
+  do
+    {
+      if (*p == '\"' || *p == '\'')
+	{
+          /* String constant, remove escape codes from string */
+          char q[1024];
+          char *out = q;
+          quote = *p++;
+          if (quote == '\'')
+          {
+            /* TI-style quote, only handle escaped quote character */
+            while (p[0] && (p[0] != '\'' || (p[0] == '\'' && p[1] == '\'')))
+              {
+                if (p[0] == '\'' && p[1] == '\'') p++;
+                *out++ = *p++;
+              }
+            if (p[0] == '\'') p++;
+          }
+          else
+          {
+             /* GAS-style quote, handle standard escape sequences */
+             int c;
+             input_line_pointer = p;
+             while (is_a_char (c = next_char_of_string ()))
+             {
+               *out++ = c;
+             }
+             p = input_line_pointer;
+          }
+          *out = 0;
+          cnt = out - q;
+
+          /* Check for length and validity */
+          if (size > 0)
+            {
+              if (cnt > size)
+                {
+                  as_warn (_ ("string constant too long"));
+                  cnt = size;
+                }
+              u = frag_more (size);
+              if (size == 2 && cnt == 1) u[1] = q[0];
+                else  memcpy (u, q, cnt);
+            }
+          else if (size == TEXT_DATAONLY)
+            {
+              u = frag_more (cnt);
+              memcpy (u, q, cnt);
+            }
+          else if (size == TEXT_PRESIZE)
+            {
+              if (cnt > 255)
+                {
+                  as_warn (_ ("string constant too long"));
+                  cnt = 255;
+                }
+              u = frag_more (cnt+1);
+              *u = cnt;             
+              memcpy (u + 1, q, cnt);
+            }
+          else if (size == TEXT_ZEROTERM)
+            {
+              u = frag_more (cnt + 1);
+              memcpy (u, q, cnt);
+              u[cnt] = 0;
+            }
+          if (!*p)
+            as_warn (_ ("unterminated string"));
+	}
+      else
+	{
+          /* This is a non-string value */
+          input_line_pointer = (char*)p;
+	  expression (&exp);
+printf("tms9900_data: X_op=%d\n", exp.X_op);
+int a; for(a=0;a<20;a++) printf("%c", p[a]); printf("\n");
+          p = (const char*)input_line_pointer;
+	  if (exp.X_op == O_register)
+	    {
+	      break;
+	    }
+	  if (exp.X_op == O_constant)
+            {
+              int max;
+              int val = exp.X_add_number;
+              if (size < 0)
+                {
+                  break;
+                }
+              max = (1 << (size * 8)) - 1;
+              if (val > max || val < -max)
+                {
+                  as_warn (_ ("constant too big"));
+                  val = val & ((1 << (size * 8)) - 1);
+                }
+              u = frag_more (size);
+              if (size == 1)
+                {
+                  u[0] = val & 0xFF;
+                }
+              else
+                {
+                  u[0] = (val >> 8) & 0xFF;
+                  u[1] = val & 0xFF;
+                }
+            }
+//          else if (exp.X_op == O_symbol &&
+//                  size == 2)
+//            {
+//              u = frag_more (2);
+//              fix_new_exp (frag_now,
+//                           u - frag_now->fr_literal,
+//                           2, &exp, 0,
+//                           BFD_RELOC_16);
+//
+//            }
+          else
+            {
+printf("tms9900_data: 1\n");
+              int reloc_type = (size == 1 ? BFD_RELOC_8 : BFD_RELOC_16);
+
+              u = frag_more (size);
+              fix_new_exp (frag_now,
+                           u - frag_now->fr_literal,
+                           size, &exp, 0,
+                           reloc_type);
+
+            }
+
+
+	}
+       p = skip_space (p);
+    }
+  while (*p++ == ',');
+  input_line_pointer = (char *)(p-1);
+}
+
+static void
+tms9900_even (int unused ATTRIBUTE_UNUSED)
+{
+  /* Align to 16 bit boundary, fill with zeroes */
+  s_align_ptwo(1);
+}
+
+static void
+tms9900_bss (int unused ATTRIBUTE_UNUSED)
+{
+  expressionS exp;
+  expression (&exp);
+  if (exp.X_op == O_constant)
+    {
+      char* p = frag_more (exp.X_add_number);
+      memset (p, 0, exp.X_add_number);      
+    }
+  else
+    {
+      as_bad (_ ("junk at end of line, first unrecognized character is `%c'"),
+              *input_line_pointer);
+    }
+}
+
+static void
+tms9900_seg_bss (int unused ATTRIBUTE_UNUSED)
+{
+  subseg_set (bss_section, now_subseg);
+  demand_empty_rest_of_line ();
+}
+
+static void
+tms9900_seg_data (int unused ATTRIBUTE_UNUSED)
+{
+  subseg_set (data_section, now_subseg);
+  demand_empty_rest_of_line ();
+}
+
+static void
+tms9900_seg_text (int unused ATTRIBUTE_UNUSED)
+{
+  subseg_set (text_section, now_subseg);
+  demand_empty_rest_of_line ();
+}
+
+/* Port specific pseudo ops.  */
+const pseudo_typeS md_pseudo_table[] =
+{
+  { ".bss",  tms9900_seg_bss, 0},
+  { ".data", tms9900_seg_data, 0},
+  { ".text", tms9900_seg_text, 0},
+
+
+  /* AORG is a commonly-used directive, but we will have to handle that
+     in the linker, since we can't assign a value for the target address
+     from within GAS. */
+  { "aorg",  s_ignore, 0},
+
+  /* TI convention for segments */
+  { "pseg",  tms9900_seg_text, 0},
+  { "pend",  s_ignore, 0},
+  { "cseg",  tms9900_seg_bss, 0},
+  { "cend",  tms9900_seg_text, 0},
+  { "dseg",  tms9900_seg_data, 0},
+  { "dend",  tms9900_seg_text, 0},
+
+  /* Reservation for data values */
+  { "bes",   tms9900_bss, 0},
+  { "bss",   tms9900_bss, 0},
+  { "byte",  tms9900_data, 1},
+  { "data",  tms9900_data, 2}, 
+  { "end",   s_ignore, 0},
+  { "def",   s_globl, 0},
+  { "even",  tms9900_even, 0},
+  { "ref",   s_ignore, 0},
+  
+  /* The SYM directive displays a list of all symbols, and their values */
+  { "sym",   s_ignore, 0},
+  { "ntext", tms9900_data, TEXT_PRESIZE},
+  { "text",  tms9900_data, TEXT_DATAONLY},
+  { "textz", tms9900_data, TEXT_ZEROTERM},
+
+  /* Aliases for the text drirectives */
+  { "nstring", tms9900_data, TEXT_PRESIZE},
+  { "string",  tms9900_data, TEXT_DATAONLY},
+  { "stringz", tms9900_data, TEXT_ZEROTERM},
+
+  { NULL, 0, 0 }
+} ;
+
+enum
+{
+  ARG_NONE,       /* No argument            */
+  ARG_MODE,       /* Addressing mode        */
+  ARG_OFFSET,     /* Branch offset          */
+  ARG_REGISTER,   /* Register number        */
+  ARG_IMMEDIATE,  /* 16-bit immediate value */
+  ARG_SHIFT,      /* Bit shift count        */
+  ARG_CRU_COUNT,  /* CRU bit count          */
+  ARG_CRU_DISP    /* CRU displacement       */
+};
+
+typedef struct _table_t
+{
+  char* name;
+  short opcode;
+  int arg[2];
+} table_t;
+
+static table_t instab[] =
+{
+  { "a",    0xA000, {ARG_MODE,      ARG_MODE}},
+  { "ab",   0xB000, {ARG_MODE,      ARG_MODE}},
+  { "abs",  0x0740, {ARG_MODE,      ARG_NONE}},
+  { "ai",   0x0220, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "andi", 0x0240, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "b",    0x0440, {ARG_MODE,      ARG_NONE}},
+  { "bl",   0x0680, {ARG_MODE,      ARG_NONE}},
+  { "blwp", 0x0400, {ARG_MODE,      ARG_NONE}},
+  { "c",    0x8000, {ARG_MODE,      ARG_MODE}},
+  { "cb",   0x9000, {ARG_MODE,      ARG_MODE}},
+  { "ci",   0x0280, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "ckof", 0x03C0, {ARG_NONE,      ARG_NONE}},
+  { "ckon", 0x03A0, {ARG_NONE,      ARG_NONE}},
+  { "clr",  0x04C0, {ARG_MODE,      ARG_NONE}},
+  { "coc",  0x2000, {ARG_MODE,      ARG_REGISTER}},
+  { "czc",  0x2400, {ARG_MODE,      ARG_REGISTER}},
+  { "dec",  0x0600, {ARG_MODE,      ARG_NONE}},
+  { "dect", 0x0640, {ARG_MODE,      ARG_NONE}},
+  { "div",  0x3C00, {ARG_MODE,      ARG_REGISTER}},
+  { "idle", 0x0340, {ARG_NONE,      ARG_NONE}},
+  { "inc",  0x0580, {ARG_MODE,      ARG_NONE}},
+  { "inct", 0x05C0, {ARG_MODE,      ARG_NONE}},
+  { "inv",  0x0540, {ARG_MODE,      ARG_NONE}},
+  { "jeq",  0x1300, {ARG_OFFSET,    ARG_NONE}},
+  { "jgt",  0x1500, {ARG_OFFSET,    ARG_NONE}},
+  { "jh",   0x1B00, {ARG_OFFSET,    ARG_NONE}},
+  { "jhe",  0x1400, {ARG_OFFSET,    ARG_NONE}},
+  { "jl",   0x1A00, {ARG_OFFSET,    ARG_NONE}},
+  { "jle",  0x1200, {ARG_OFFSET,    ARG_NONE}},
+  { "jlt",  0x1100, {ARG_OFFSET,    ARG_NONE}},
+  { "jmp",  0x1000, {ARG_OFFSET,    ARG_NONE}},
+  { "jnc",  0x1700, {ARG_OFFSET,    ARG_NONE}},
+  { "jne",  0x1600, {ARG_OFFSET,    ARG_NONE}},
+  { "jno",  0x1900, {ARG_OFFSET,    ARG_NONE}},
+  { "joc",  0x1800, {ARG_OFFSET,    ARG_NONE}},
+  { "jop",  0x1C00, {ARG_OFFSET,    ARG_NONE}},
+  { "ldcr", 0x3000, {ARG_MODE,      ARG_CRU_COUNT}},
+  { "li",   0x0200, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "limi", 0x0300, {ARG_IMMEDIATE, ARG_NONE}},
+  { "lrex", 0x03E0, {ARG_NONE,      ARG_NONE}},
+  { "lwpi", 0x02E0, {ARG_IMMEDIATE, ARG_NONE}},
+  { "mov",  0xC000, {ARG_MODE,      ARG_MODE}},
+  { "movb", 0xD000, {ARG_MODE,      ARG_MODE}},
+  { "mpy",  0x3800, {ARG_MODE,      ARG_REGISTER}},
+  { "neg",  0x0500, {ARG_MODE,      ARG_NONE}},
+  { "nop",  0x1000, {ARG_NONE,      ARG_NONE}},  /* Encoded as "jmp 0"  */
+  { "or",   0xE000, {ARG_MODE,      ARG_MODE}},  /* Encoded as "soc"    */
+  { "orb",  0xF000, {ARG_MODE,      ARG_MODE}},  /* Encoded as "socb"   */
+  { "ori",  0x0260, {ARG_REGISTER,  ARG_IMMEDIATE}},
+  { "rset", 0x0360, {ARG_NONE,      ARG_NONE}},
+  { "rt",   0x045B, {ARG_NONE,      ARG_NONE}},  /* Encoded as "b *r11" */
+  { "rtwp", 0x0380, {ARG_NONE,      ARG_NONE}},
+  { "s",    0x6000, {ARG_MODE,      ARG_MODE}},
+  { "sb",   0x7000, {ARG_MODE,      ARG_MODE}},
+  { "sbo",  0x1D00, {ARG_CRU_DISP,  ARG_NONE}},
+  { "sbz",  0x1E00, {ARG_CRU_DISP,  ARG_NONE}},
+  { "seto", 0x0700, {ARG_MODE,      ARG_NONE}},
+  { "sla",  0x0A00, {ARG_REGISTER,  ARG_SHIFT}},
+  { "soc",  0xE000, {ARG_MODE,      ARG_MODE}},
+  { "socb", 0xF000, {ARG_MODE,      ARG_MODE}},
+  { "sra",  0x0800, {ARG_REGISTER,  ARG_SHIFT}},
+  { "src",  0x0B00, {ARG_REGISTER,  ARG_SHIFT}},
+  { "srl",  0x0900, {ARG_REGISTER,  ARG_SHIFT}},
+  { "stcr", 0x3400, {ARG_MODE,      ARG_CRU_COUNT}},
+  { "stst", 0x02C0, {ARG_REGISTER,  ARG_NONE}},
+  { "stwp", 0x02A0, {ARG_REGISTER,  ARG_NONE}},
+  { "swpb", 0x06C0, {ARG_MODE,      ARG_NONE}},
+  { "szc",  0x4000, {ARG_MODE,      ARG_MODE}},
+  { "szcb", 0x5000, {ARG_MODE,      ARG_MODE}},
+  { "tb",   0x1F00, {ARG_CRU_DISP,  ARG_NONE}},
+  { "x",    0x0480, {ARG_MODE,      ARG_NONE}},
+  { "xop",  0x2C00, {ARG_MODE,      ARG_REGISTER}},
+  { "xor",  0x2800, {ARG_MODE,      ARG_REGISTER}}
+};
+
+static int
+assemble_arg(int argtype, short *opcode, int *op_size, expressionS *exp)
+{
+  /* argtype - type of argument to parse
+     opcode  - bits to insert into opcode
+     op_size - size of opcode bits
+     expr    - expression for branch target or immediate value
+  */
+
+  char *start = input_line_pointer;
+
+  exp->X_op = O_absent;
+  *opcode = 0;
+  *op_size = 0;  
+  int valid = 0;
+
+  if (argtype == ARG_MODE)
+    {
+      assemble_mode (input_line_pointer, opcode, exp);
+      *op_size = 6;
+      valid = 1;
+    }
+  else if (argtype != ARG_NONE)
+    {
+      char *ptr = input_line_pointer;
+      expression (exp);
+      switch (argtype)
+        {
+          /* Branch offset */
+          case ARG_OFFSET:     
+            if (exp->X_op == O_constant ||
+                exp->X_op == O_symbol)
+              {
+                valid = 1;
+              }
+            if (exp->X_op == O_constant)
+              {
+                *opcode = (exp->X_add_number >> 1) & 0xFF;
+                *op_size = 8;
+                exp->X_op = O_absent;
+              }
+            break;
+
+          /* Register number */
+          case ARG_REGISTER:
+            if (exp->X_op == O_register ||
+               /* The expression parser cannot handle numeric registers.
+                  Instructions like "mov 1,2" must be handled here
+               */
+                (exp->X_op == O_constant &&
+                  (unsigned int)exp->X_add_number < 16))
+              {
+                *opcode = exp->X_add_number;
+                *op_size = 4;
+                exp->X_op = O_absent;
+                valid = 1;
+              }
+            else
+              {
+                as_bad (_ ("not a register '%s'"), start);
+              }
+            break;
+
+          /* 16-bit immediate value */
+          case ARG_IMMEDIATE:
+            if (exp->X_op == O_constant && *ptr++ == '\'')
+              {
+                /* Could be a constant like 'a' or 'ab'
+                   These values can be no longer than two characters.
+                   Since TI escapes the single quote by duplication,
+                   the code below is uglier than it needs to be.
+
+                   Expected translations:
+                     ''     -> 0x0027
+                     ''''   -> 0x0027
+                     '''''' -> 0x2727
+                */
+                int i, val = 0;
+                for (i = 0; i < 2; i++)
+                  {
+                    if (*ptr == '\'' && ptr[1] == '\'') ptr++;
+                    val = (val << 8) | *ptr++;
+                    if ((*ptr == '\'' && ptr[1]!='\'') ||
+                       *ptr == 0    ||
+                       *ptr == '\n') break;
+                  }
+                if (*ptr == '\n' ||
+                    *ptr == 0) as_warn (_ ("unterminated string"));
+                else if (*ptr != '\'' ||
+                         (*ptr == '\'' && ptr[1] == '\''))
+                  {
+                    as_warn (_ ("constant too big"));
+                  }
+
+                /* Use the value we found */
+                exp->X_add_number = val;
+                valid = 1;
+              }
+            else if (exp->X_op == O_constant ||
+                     exp->X_op == O_symbol)
+              {
+                valid = 1;
+              }
+            else
+              {
+                as_bad (_ ("not a constant expression '%s'"), start);
+              }
+            break;
+
+          /* Bit shift count */
+          case ARG_SHIFT:
+            if (exp->X_op == O_constant ||
+                (exp->X_op == O_register && exp->X_add_number == 0))
+              {
+                *opcode = exp->X_add_number;
+                *op_size = 4;
+                exp->X_op = O_absent;
+                valid = 1;
+              }
+            break;
+
+          /* CRU bit count */
+          case ARG_CRU_COUNT:
+            if (exp->X_op == O_constant)
+              {
+                *opcode = exp->X_add_number;
+                *op_size = 4;
+                exp->X_op = O_absent;
+                valid = 1;
+              }
+            else
+              {
+                as_bad (_ ("not a constant expression '%s'"), input_line_pointer);
+              }
+            break;
+
+          /* CRU displacement */
+          case ARG_CRU_DISP:
+            if (exp->X_op == O_constant)
+              {
+                *opcode = exp->X_add_number;
+                *op_size = 8;
+                exp->X_op = O_absent;
+                valid = 1;
+              }
+            else
+              {
+                as_bad (_ ("not a constant expression '%s'"), input_line_pointer);
+              }
+            break;
+        }
+    }
+
+  if(input_line_pointer == start)
+    {
+      as_bad (_ ("missing argument"));
+      return (0);
+    }
+
+  /* If we found an invalid argument, revert everything done here */
+  if(valid == 0)
+    {
+      exp->X_op = O_absent;
+      input_line_pointer = start;
+    }
+  return (valid);
+}
+
+void
+md_assemble (char* str)
+{
+  const char *p;
+  char * old_ptr;
+  int i;
+  table_t *insp;
+  short opcode[2];
+  int op_size[2];
+  expressionS exp[2];              
+  char *out;
+  short insn;
+  int check_unex = 0;
+
+  err_flag = 0;
+  old_ptr = input_line_pointer;
+  p = skip_space (str);
+
+  /* Convert opcode to lowercase */
+  for (i = 0; (i < BUFLEN) && (ISALPHA (*p));)
+    buf[i++] = TOLOWER (*p++);
+
+  if (i == BUFLEN)
+    {
+      /* Opcode too long */
+      buf[BUFLEN-3] = buf[BUFLEN-2] = '.'; /* Mark opcode as abbreviated.  */
+      buf[BUFLEN-1] = 0;
+      as_bad (_ ("unknown instruction '%s'"), buf);
+    }
+  else if ((*p) && (!ISSPACE (*p)))
+    as_bad (_ ("syntax error"));
+  else 
+    {
+      /* Check for valid opcode */
+      buf[i] = 0;
+      p = skip_space (p);
+      key = buf;
+      
+      insp = bsearch (&key, instab, ARRAY_SIZE (instab),
+		    sizeof (instab[0]), key_cmp);
+      if (!insp)
+	as_bad (_ ("unknown instruction '%s'"), buf);
+      else
+	{
+          /* Skip to start of arguments, if we have any */
+          input_line_pointer = str + strlen(insp->name);
+          input_line_pointer = (char*)skip_space (input_line_pointer);
+
+          /* Initialize arguments */
+          for (i = 0; i < 2; i++)
+            {
+              exp[i].X_op = O_absent;
+              op_size[i] = 0;
+              opcode[i] = 0;
+            }
+
+          /* Parse arguments */
+          if (insp->arg[0] != ARG_NONE)
+            {
+              /* Parse first argument */
+              if (assemble_arg (insp->arg[0], &opcode[0], &op_size[0], &exp[0]) != 0)
+                {
+                  check_unex = 1;
+                  if (insp->arg[1] != ARG_NONE)
+                    {
+                      /* Parse second argument */
+                      if (*input_line_pointer != ',')
+                        {
+                          if (*input_line_pointer == 0)
+                            {
+                              as_bad (_ ("unexpected end of line"));
+                              check_unex = 0;
+                            }
+                          else
+                            {
+                              char str[64];
+                              sprintf (str, "unexpected character at \"%s\"",
+                                       input_line_pointer);
+                              as_bad (str);
+                              check_unex = 0;
+                            }
+                        }
+                      else
+                        {
+                          input_line_pointer++;
+                          if (assemble_arg (insp->arg[1], &opcode[1], &op_size[1], &exp[1]))
+                              /* Second argument is valid, rest is comment */
+                              check_unex = 0;
+                        }
+                    }
+                }           
+            }
+
+          /* Check for unexpected characters */
+          if (check_unex != 0 && 
+              *input_line_pointer != 0 && 
+              strspn (input_line_pointer, " *") == 0)
+            {
+              char str[64];
+              sprintf (str, "unexpected character at \"%s\"", input_line_pointer);
+              as_bad (str);
+            }
+
+          /* Make output instruction */
+          insn = insp->opcode | 
+                 opcode[0]    |
+                 (opcode[1] << op_size[0]);
+
+          out = frag_more(2);
+          *out++ = ((insn >> 8) & 0xFF);
+          *out   =  (insn       & 0xFF);
+
+          /* Insert extra words and fixups */
+          for (i=0; i<2; i++)
+            {
+              if (exp[i].X_op != O_absent)
+                {
+                  /* Assume no fixup required */
+                  int reloc_type = BFD_RELOC_NONE;
+                  int fix_size = 0;
+
+                  if (insp->arg[i] == ARG_OFFSET)
+                    {
+                      /* 8-bit PC-relative offset, stored in instruction */
+                      reloc_type = BFD_RELOC_8_PCREL;
+                      fix_size = 1;
+                    }
+                  else
+                    {
+                      /* 16-bit constant value, stored after instruction */
+                      unsigned short val = 0;
+                      out = frag_more (2);
+                      reloc_type = BFD_RELOC_16;
+                      fix_size = 2;
+                      if (exp[i].X_op == O_constant)
+                        {
+                          val = (exp[i].X_add_number & 0xFFFF);
+                          fix_size = 0;
+                        }
+                      out[0] = ((val >> 8) & 0xFF);
+                      out[1] =  (val       & 0xFF);      
+                    }
+
+                  if (fix_size != 0)
+                    {
+                      /* Fixup used for this instruction, configure it */
+                      fix_new_exp (frag_now,
+                                   out - frag_now->fr_literal,
+                                   fix_size,
+                                   &exp[i],
+                                   0,
+                                   reloc_type);
+                    }
+                }
+            }
+        }
+    }
+
+  input_line_pointer = old_ptr;
+}
+
+
+void
+md_operand (expressionS* exp ATTRIBUTE_UNUSED)
+{
+  printf("Unrecognized expression: \"%s\"\n", input_line_pointer);
+}
+
+
+void
+md_apply_fix (fixS * fixP, valueT* valP, segT seg ATTRIBUTE_UNUSED)
+{
+  long val = * (long *) valP;
+  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
+
+  switch (fixP->fx_r_type)
+    {
+    case BFD_RELOC_8_PCREL:
+      if (fixP->fx_addsy)
+        {
+          fixP->fx_no_overflow = 1;
+          fixP->fx_done = 0;
+        }
+      else
+        {
+	  fixP->fx_no_overflow = (-128 <= val && val < 128);
+	  if (!fixP->fx_no_overflow)
+            as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("relative jump out of range"));
+	  *buf++ = val;
+          fixP->fx_done = 1;
+        }
+      break;
+
+    case BFD_RELOC_16:
+      *buf++ = (val >> 8);
+      *buf++ = val;
+      fixP->fx_no_overflow = 1; 
+      if (fixP->fx_addsy == NULL)
+	fixP->fx_done = 1;
+      break;
+
+    default:
+      printf (_ ("md_apply_fix: unknown r_type 0x%x\n"), fixP->fx_r_type);
+      abort ();
+    }
+}
+
+/* GAS will call this to generate a reloc.  GAS will pass the
+   resulting reloc to `bfd_install_relocation'.  This currently works
+   poorly, as `bfd_install_relocation' often does the wrong thing, and
+   instances of `tc_gen_reloc' have been written to work around the
+   problems, which in turns makes it difficult to fix
+   `bfd_install_relocation'.  */
+
+/* If while processing a fixup, a reloc really
+   needs to be created then it is done here.  */
+
+arelent *
+tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED , fixS *fixp)
+{
+  arelent *reloc;
+
+  if (! bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type))
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("reloc %d not supported by object file format"),
+		    (int) fixp->fx_r_type);
+      return NULL;
+    }
+
+  reloc               = xmalloc (sizeof (arelent));
+  reloc->sym_ptr_ptr  = xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address      = fixp->fx_frag->fr_address + fixp->fx_where;
+  reloc->howto        = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+  reloc->addend       = fixp->fx_offset;
+
+  return reloc;
+}
+
diff -rupN binutils-2.40-original/gas/config/tc-tms9900.h binutils-2.40/gas/config/tc-tms9900.h
--- binutils-2.40-original/gas/config/tc-tms9900.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.40/gas/config/tc-tms9900.h	2024-03-10 16:38:19.725164841 -0400
@@ -0,0 +1,118 @@
+/* this is tc-tms9900.h
+   Copyright 2009 Eric Welser
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of .the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#ifndef TC_TMS9900
+#define TC_TMS9900
+
+#define TARGET_ARCH   bfd_arch_tms9900
+#define BFD_ARCH      TARGET_ARCH
+#define COFF_MAGIC    0x5A80
+#define TARGET_MACH   bfd_mach_tms9900
+//#define TARGET_BYTES_BIG_ENDIAN  0
+#define TARGET_BYTES_BIG_ENDIAN  1
+#define LABELS_WITHOUT_COLONS 1
+
+
+#define TARGET_FORMAT "elf32-tms9900"
+
+/* If you define this macro, GAS will warn about the
+   use of nonstandard escape sequences in a string.  */
+#define ONLY_STANDARD_ESCAPES
+
+/* This should just call either `number_to_chars_bigendian' or
+   `number_to_chars_littleendian', whichever is appropriate.  On
+   targets like the MIPS which support options to change the
+   endianness, which function to call is a runtime decision.  On
+   other targets, `md_number_to_chars' can be a simple macro.  */
+#define md_number_to_chars number_to_chars_bigendian
+
+/* This is called when an unrecognized symbol is encountered while
+   parsing an expression. */
+#define md_parse_name(name, exp, mode, c) tms9900_parse_name (name, exp)
+
+/* This macro permits the processor to specify all characters which
+   may appears in an operand.  This will prevent the scrubber from
+   discarding meaningful whitespace in certain cases. */
+extern const char tms9900_symbol_chars[];
+#define tc_symbol_chars tms9900_symbol_chars
+
+extern const char tms9900_comment_chars[];
+#define tc_comment_chars tms9900_comment_chars
+
+
+#define TC_COUNT_RELOC(x) 1
+
+#define TC_COFF_FIX2RTYPE(fixP) tc_coff_fix2rtype (fixP)
+#define md_convert_frag(b,s,f)   as_fatal ("convert_frag called\n")
+#define md_estimate_size_before_relax(f,s) \
+  (as_fatal (_("estimate_size_before_relax called")), 1)
+
+/* Define some functions to be called by generic code.  */
+#define md_start_line_hook() { if (tms9900_start_line_hook ()) continue; }
+#define TC_CONS_FIX_NEW tms9900_cons_fix_new
+
+extern int tms9900_start_line_hook (void);
+extern void tms9900_cons_fix_new (fragS *, int, int, expressionS *,
+                                  bfd_reloc_code_real_type r);
+extern int tms9900_parse_name(const char *, struct expressionS *);
+
+/* We don't need to handle a broken .word directive. */
+#define WORKING_DOT_WORD
+
+/* If you define this macro, it means that `tc_gen_reloc' may return
+   multiple relocation entries for a single fixup.  In this case, the
+   return value of `tc_gen_reloc' is a pointer to a null terminated
+   array.  */
+#undef RELOC_EXPANSION_POSSIBLE
+
+/* No shared lib support, so we don't need to ensure
+   externally visible symbols can be overridden.  */
+#define EXTERN_FORCE_RELOC 0
+
+/* Values passed to md_apply_fix3 don't include the symbol value.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+
+#define LISTING_WORD_SIZE 2
+
+/* A single '=' is accepted as a comparison operator.  */
+#define O_SINGLE_EQ O_eq
+
+/* A '$' is used to refer to the current location or as a hex. prefix.  */
+#define DOLLAR_DOT
+#define DOLLAR_AMBIGU                1
+#define LOCAL_LABELS_FB              1
+#define LITERAL_PREFIXPERCENT_BIN
+#define NUMBERS_WITH_SUFFIX          1
+#define NO_PSEUDO_DOT                1
+/* We allow single quotes to delimit character constants as
+   well, but it is cleaner to handle that in tc-tms9900.c.  */
+#define SINGLE_QUOTE_STRINGS
+#define ONLY_STANDARD_ESCAPES
+
+/* An `.lcomm' directive with no explicit alignment parameter will
+   use this macro to set P2VAR to the alignment that a request for
+   SIZE bytes will have.  The alignment is expressed as a power of
+   two.  If no alignment should take place, the macro definition
+   should do nothing.  Some targets define a `.bss' directive that is
+   also affected by this macro.  The default definition will set
+   P2VAR to the truncated power of two of sizes up to eight bytes.  */
+#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR) (P2VAR) = 0
+
+#endif
diff -rupN binutils-2.40-original/gas/configure.tgt binutils-2.40/gas/configure.tgt
--- binutils-2.40-original/gas/configure.tgt	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/gas/configure.tgt	2024-03-10 16:38:19.725164841 -0400
@@ -111,6 +111,7 @@ case ${cpu} in
   sparc*)		cpu_type=sparc arch=sparclite ;; # ??? See tc-sparc.c.
   tilegx*be)		cpu_type=tilegx endian=big ;;
   tilegx*)		cpu_type=tilegx endian=little ;;
+  tms9900*)             cpu_type=tms9900 endian=big ;;
   v850*)		cpu_type=v850 ;;
   visium)		cpu_type=visium endian=big ;;
   wasm32)               cpu_type=wasm32 endian=little ;;
@@ -413,6 +414,8 @@ case ${generic_target} in
 
   tilepro-*-* | tilegx*-*-*)		fmt=elf ;;
 
+  tms9900*-*-*)				fmt=elf ;;
+
   v850*-*-*)				fmt=elf ;;
 
   vax-*-netbsdaout)			fmt=aout em=nbsd ;;
diff -rupN binutils-2.40-original/gas/doc/as.1 binutils-2.40/gas/doc/as.1
--- binutils-2.40-original/gas/doc/as.1	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/gas/doc/as.1	2024-03-10 16:38:19.725164841 -0400
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
+.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -54,20 +54,16 @@
 .\" Avoid warning from groff about undefined register 'F'.
 .de IX
 ..
-.nr rF 0
-.if \n(.g .if rF .nr rF 1
-.if (\n(rF:(\n(.g==0)) \{\
-.    if \nF \{\
-.        de IX
-.        tm Index:\\$1\t\\n%\t"\\$2"
+.if !\nF .nr F 0
+.if \nF>0 \{\
+.    de IX
+.    tm Index:\\$1\t\\n%\t"\\$2"
 ..
-.        if !\nF==2 \{\
-.            nr % 0
-.            nr F 2
-.        \}
+.    if !\nF==2 \{\
+.        nr % 0
+.        nr F 2
 .    \}
 .\}
-.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -133,7 +129,7 @@
 .\" ========================================================================
 .\"
 .IX Title "AS 1"
-.TH AS 1 "2023-01-14" "binutils-2.40" "GNU Development Tools"
+.TH AS 1 "2023-04-17" "binutils-2.40" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -3025,7 +3021,7 @@ Single precision floating point numbers
 Double precision floating point numbers format. Default: ieee754 (64 bit).
 .SH "SEE ALSO"
 .IX Header "SEE ALSO"
-\&\fBgcc\fR\|(1), \fBld\fR\|(1), and the Info entries for \fIbinutils\fR and \fIld\fR.
+\&\fIgcc\fR\|(1), \fIld\fR\|(1), and the Info entries for \fIbinutils\fR and \fIld\fR.
 .SH "COPYRIGHT"
 .IX Header "COPYRIGHT"
 Copyright (c) 1991\-2023 Free Software Foundation, Inc.
diff -rupN binutils-2.40-original/gas/doc/as.info binutils-2.40/gas/doc/as.info
--- binutils-2.40-original/gas/doc/as.info	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/gas/doc/as.info	2024-03-10 16:38:19.737164949 -0400
@@ -1,4 +1,4 @@
-This is as.info, produced by makeinfo version 6.8 from as.texi.
+This is as.info, produced by makeinfo version 6.5 from as.texi.
 
 This file documents the GNU Assembler "as".
 
@@ -27606,7 +27606,7 @@ AS Index
 * builtin math functions, TIC54X:        TIC54X-Builtins.    (line    6)
 * builtin subsym functions, TIC54X:      TIC54X-Macros.      (line   16)
 * bundle:                                Bundle directives.  (line    9)
-* bundle-locked:                         Bundle directives.  (line   38)
+* bundle-locked:                         Bundle directives.  (line   39)
 * bundle_align_mode directive:           Bundle directives.  (line    9)
 * bundle_lock directive:                 Bundle directives.  (line   31)
 * bundle_unlock directive:               Bundle directives.  (line   31)
@@ -30244,8 +30244,3 @@ Node: GNU Free Documentation License957
 Node: AS Index983093
 
 End Tag Table
-
-
-Local Variables:
-coding: utf-8
-End:
diff -rupN binutils-2.40-original/include/elf/common.h binutils-2.40/include/elf/common.h
--- binutils-2.40-original/include/elf/common.h	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/include/elf/common.h	2024-03-10 16:38:19.737164949 -0400
@@ -424,6 +424,9 @@
 /* old S/390 backend magic number. Written in the absence of an ABI.  */
 #define EM_S390_OLD		0xa390
 
+/* Texas Instruments TMS9900 processor.  */
+#define EM_TMS9900		0xabba
+
 /* Old, unofficial value for Xtensa.  */
 #define EM_XTENSA_OLD		0xabc7
 
diff -rupN binutils-2.40-original/include/elf/tms9900.h binutils-2.40/include/elf/tms9900.h
--- binutils-2.40-original/include/elf/tms9900.h	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.40/include/elf/tms9900.h	2024-03-10 16:38:19.737164949 -0400
@@ -0,0 +1,33 @@
+/* TMS9900 ELF support for BFD.
+   Copyright (C) 1999-2023 Free Software Foundation, Inc.
+   Contributed by Sergey Belyashov <sergey.belyashov@gmail.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _ELF_TMS9900_H
+#define _ELF_TMS9900_H
+
+#include "elf/reloc-macros.h"
+
+/* Relocations.  */
+START_RELOC_NUMBERS (elf_tms9900_reloc_type)
+     RELOC_NUMBER (R_TMS9900_NONE,	0)
+     RELOC_NUMBER (R_TMS9900_PC8, 	1)
+     RELOC_NUMBER (R_TMS9900_16,	2)
+END_RELOC_NUMBERS (R_TMS9900_max)
+
+#endif /* _ELF_TMS9900_H */
diff -rupN binutils-2.40-original/ld/configure.tgt binutils-2.40/ld/configure.tgt
--- binutils-2.40-original/ld/configure.tgt	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/ld/configure.tgt	2024-03-10 16:38:19.741164987 -0400
@@ -978,6 +978,8 @@ tilegxbe-*-*)		targ_emul=elf64tilegx_be
 			;;
 tilepro-*-*)		targ_emul=elf32tilepro
 			;;
+tms9900-*-*)		targ_emul=elf32_tms9900
+			;;
 v850*-*-*)		targ_emul=v850_rh850
 			targ_extra_emuls=v850
 			;;
diff -rupN binutils-2.40-original/ld/emulparams/elf32_tms9900.sh binutils-2.40/ld/emulparams/elf32_tms9900.sh
--- binutils-2.40-original/ld/emulparams/elf32_tms9900.sh	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.40/ld/emulparams/elf32_tms9900.sh	2024-03-10 16:38:19.741164987 -0400
@@ -0,0 +1,6 @@
+SCRIPT_NAME=elf
+OUTPUT_FORMAT="elf32-tms9900"
+OUTPUT_ARCH="tms9900"
+TEXT_START_ADDR=0xA000
+TARGET_PAGE_SIZE=512
+ARCH=tms9900
diff -rupN binutils-2.40-original/ld/Makefile.in binutils-2.40/ld/Makefile.in
--- binutils-2.40-original/ld/Makefile.in	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/ld/Makefile.in	2024-03-10 16:38:19.741164987 -0400
@@ -724,6 +724,7 @@ ALL_EMULATION_SOURCES = \
 	eelf32_tic6x_le.c \
 	eelf32_tic6x_linux_be.c \
 	eelf32_tic6x_linux_le.c \
+        eelf32_tms9900.c \
 	eelf32am33lin.c \
 	eelf32bfin.c \
 	eelf32bfinfd.c \
@@ -1549,6 +1550,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic3xcoff_onchip.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic4xcoff.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic54xcoff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etms9900.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev850.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev850_rh850.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evanilla.Po@am__quote@
@@ -2532,6 +2534,7 @@ $(ALL_EMULATION_SOURCES) $(ALL_64_EMULAT
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic3xcoff_onchip.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic4xcoff.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic54xcoff.Pc@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etms9900.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev850.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev850_rh850.Pc@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evanilla.Pc@am__quote@
diff -rupN binutils-2.40-original/opcodes/configure binutils-2.40/opcodes/configure
--- binutils-2.40-original/opcodes/configure	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/opcodes/configure	2024-03-10 16:38:19.749165059 -0400
@@ -12585,6 +12585,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_tic6x_arch)		ta="$ta tic6x-dis.lo" ;;
 	bfd_tilegx_arch)	ta="$ta tilegx-dis.lo tilegx-opc.lo" ;;
 	bfd_tilepro_arch)	ta="$ta tilepro-dis.lo tilepro-opc.lo" ;;
+	bfd_tms9900_arch)	ta="$ta tms9900-dis.lo" ;;
 	bfd_v850_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850e_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850ea_arch)	ta="$ta v850-opc.lo v850-dis.lo" ;;
diff -rupN binutils-2.40-original/opcodes/disassemble.c binutils-2.40/opcodes/disassemble.c
--- binutils-2.40-original/opcodes/disassemble.c	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/opcodes/disassemble.c	2024-03-10 16:38:19.749165059 -0400
@@ -93,6 +93,7 @@
 #define ARCH_tic54x
 #define ARCH_tic6x
 #define ARCH_tilepro
+#define ARCH_tms9900
 #define ARCH_v850
 #define ARCH_vax
 #define ARCH_visium
@@ -463,6 +464,11 @@ disassembler (enum bfd_architecture a,
       disassemble = print_insn_tic6x;
       break;
 #endif
+#ifdef ARCH_tms9900
+    case bfd_arch_tms9900:
+      disassemble = print_insn_tms9900;
+      break;
+#endif
 #ifdef ARCH_ft32
     case bfd_arch_ft32:
       disassemble = print_insn_ft32;
diff -rupN binutils-2.40-original/opcodes/disassemble.h binutils-2.40/opcodes/disassemble.h
--- binutils-2.40-original/opcodes/disassemble.h	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/opcodes/disassemble.h	2024-03-10 16:38:19.753165097 -0400
@@ -89,6 +89,7 @@ extern int print_insn_tic54x		(bfd_vma,
 extern int print_insn_tic6x		(bfd_vma, disassemble_info *);
 extern int print_insn_tilegx		(bfd_vma, disassemble_info *);
 extern int print_insn_tilepro		(bfd_vma, disassemble_info *);
+extern int print_insn_tms9900		(bfd_vma, disassemble_info *);
 extern int print_insn_v850		(bfd_vma, disassemble_info *);
 extern int print_insn_vax		(bfd_vma, disassemble_info *);
 extern int print_insn_visium		(bfd_vma, disassemble_info *);
diff -rupN binutils-2.40-original/opcodes/Makefile.in binutils-2.40/opcodes/Makefile.in
--- binutils-2.40-original/opcodes/Makefile.in	2023-01-13 19:00:00.000000000 -0500
+++ binutils-2.40/opcodes/Makefile.in	2024-03-10 16:38:19.753165097 -0400
@@ -644,6 +644,7 @@ TARGET32_LIBOPCODES_CFILES = \
 	tic6x-dis.c \
 	tilepro-dis.c \
 	tilepro-opc.c \
+	tms9900-opc.c \
 	v850-dis.c \
 	v850-opc.c \
 	vax-dis.c \
@@ -1052,6 +1053,8 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tilegx-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tilepro-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tilepro-opc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tms9900-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tms9900-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/v850-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/v850-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vax-dis.Plo@am__quote@
diff -rupN binutils-2.40-original/opcodes/tms9900-dis.c binutils-2.40/opcodes/tms9900-dis.c
--- binutils-2.40-original/opcodes/tms9900-dis.c	1969-12-31 19:00:00.000000000 -0500
+++ binutils-2.40/opcodes/tms9900-dis.c	2024-03-10 16:38:19.753165097 -0400
@@ -0,0 +1,387 @@
+/* Print TMS9900 instructions
+   Copyright 2009 Eric Welser
+
+   This file is part of the GNU opcodes library.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "dis-asm.h"
+#include <stdio.h>
+
+struct buffer
+{
+  bfd_vma base;
+  unsigned short opcode;
+  int n_fetch;
+  unsigned char data[6];
+};
+
+typedef void (*parse_func)(struct buffer *, disassemble_info *, char *);
+
+struct parse_table
+{
+  parse_func func;
+  char* text;
+};
+
+static int
+fetch_data (struct buffer *buf, disassemble_info * info, int n)
+{
+  int r;
+
+  if (buf->n_fetch + n > 6)
+    abort ();
+
+  r = info->read_memory_func (buf->base + buf->n_fetch,
+			      (unsigned char*) buf->data + buf->n_fetch,
+			      n, info);
+  if (r == 0)
+    buf->n_fetch += n;
+  return !r;
+}
+
+static void parse_error(struct buffer *buffer, disassemble_info *info, char *text ATTRIBUTE_UNUSED)
+{
+  info->fprintf_func (info->stream, "data %02x%02x", 
+                      buffer->data[0],  buffer->data[1]);  
+}
+
+static void parse_mode(struct buffer *buffer, disassemble_info *info, char *arg, int code)
+{
+  int mode = (code >> 4) & 0x3;
+  int reg = code & 0xF;
+  if(mode == 2)
+    {
+      unsigned char *data = &buffer->data[buffer->n_fetch];
+      unsigned short value;
+      if (! fetch_data (buffer, info, 2))
+        return;
+      value = ((unsigned short)data[0] << 8) | data[1];
+      if(reg == 0)
+        sprintf(arg, "@>%04x",value);
+      else
+        sprintf(arg, "@>%04x(r%d)", value, reg);
+    }
+  else
+    {
+      char *format[] = { "r%d", "*r%d", "", "*r%d+" };
+      sprintf(arg, format[mode], reg);
+    }
+}
+
+static void parse_type_1(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // source, dest     |Opcode  |B |Td   |Dest. Reg. |Ts   |Source Reg.|
+
+  char source[16];
+  char dest[16];
+
+  parse_mode(buffer, info, source, (buffer->opcode & 0x3F));
+  parse_mode(buffer, info, dest, ((buffer->opcode >> 6) & 0x3F));
+
+  info->fprintf_func (info->stream, "%s %s, %s", text, source, dest);
+}
+
+static void parse_type_2(struct buffer *buffer ATTRIBUTE_UNUSED, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // PC-rel           |Opcode                 |Offset                 |
+
+  char disp = buffer->opcode & 0xFF;
+  info->fprintf_func (info->stream, "%s %d", text, (int)(disp) * 2);
+}
+
+static void parse_type_2a(struct buffer *buffer ATTRIBUTE_UNUSED, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // CRU disp         |Opcode                 |Offset                 |
+
+  char disp = buffer->opcode & 0xFF;
+  info->fprintf_func (info->stream, "%s %d", text, (int)(disp));
+}
+
+static void parse_type_3(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // source, reg      |Opcode           |Register   |Ts   |Source Reg.|
+
+  char source[16];
+  parse_mode(buffer, info, source, (buffer->opcode & 0x3F));
+  info->fprintf_func (info->stream, "%s %s, r%d", 
+                      text, source, (buffer->opcode >> 6) & 0xF);
+}
+
+static void parse_type_4(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // source, nbits    |Opcode           |NBits      |Ts   |Source Reg.|
+
+  char source[16];
+  parse_mode(buffer, info, source, (buffer->opcode & 0x3F));
+  info->fprintf_func (info->stream, "%s %s, %d", 
+                      text, source, (buffer->opcode >> 6) & 0xF);
+}
+
+static void parse_type_5(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // register, count  |Opcode                 |Count      |Register   |
+
+  info->fprintf_func (info->stream, "%s r%d, %d", 
+                      text, buffer->opcode & 0xF, (buffer->opcode >> 4) & 0xF);
+}
+
+static void parse_type_6(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // dest             |Opcode                       |Ts   |Source Reg.|
+
+  char source[16];
+  parse_mode(buffer, info, source, (buffer->opcode & 0x3F));
+  info->fprintf_func (info->stream, "%s %s", text, source);
+}
+
+static void parse_type_7(struct buffer *buffer ATTRIBUTE_UNUSED, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // dest             |Opcode                             | 0  0  0  0|
+
+  info->fprintf_func (info->stream, "%s", text);
+}
+
+static void parse_type_8(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // register, count  |Opcode                          | 0|Register   |
+  // immediate        |Data                                           |
+
+  unsigned char *data = &buffer->data[buffer->n_fetch];
+  unsigned short value;
+  if (! fetch_data (buffer, info, 2))
+    return;
+  value = ((unsigned short)data[0] << 8) | data[1];
+
+  info->fprintf_func (info->stream, "%s r%d, >%04x", 
+                      text, buffer->opcode & 0xF, value);
+}
+
+static void parse_type_8a(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // register, count  |Opcode                          | 0|Register   |
+
+  info->fprintf_func (info->stream, "%s r%d", 
+                      text, buffer->opcode & 0xF);
+}
+
+static void parse_type_8b(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  //                  |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+  // opcode           |Opcode                          | 0            |
+  // immediate        |Data                                           |
+
+  unsigned char *data = &buffer->data[buffer->n_fetch];
+  unsigned short value;
+  if (! fetch_data (buffer, info, 2))
+    return;
+  value = ((unsigned short)data[0] << 8) | data[1];
+
+  info->fprintf_func (info->stream, "%s >%04x", 
+                      text, value);
+}
+
+static struct parse_table level_5[] =
+{
+  {parse_type_6, "blwp"},
+  {parse_type_6, "b"},
+  {parse_type_6, "x"},
+  {parse_type_6, "clr"},
+  {parse_type_6, "neg"},
+  {parse_type_6, "inv"},
+  {parse_type_6, "inc"},
+  {parse_type_6, "inct"},
+  {parse_type_6, "dec"},
+  {parse_type_6, "dect"},
+  {parse_type_6, "bl"},
+  {parse_type_6, "swpb"},
+  {parse_type_6, "seto"},
+  {parse_type_6, "abs"},
+  {parse_error,  ""},
+  {parse_error,  ""}
+};
+
+static void parse_level_5(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  unsigned int code = (buffer->opcode >> 6) & 0xF;
+  text = level_5[code].text;
+  level_5[code].func(buffer, info, text);
+}
+
+static struct parse_table level_4[] =
+{
+  {parse_type_8,  "li"},
+  {parse_error,   ""},
+  {parse_type_8,  "ai"},
+  {parse_error,   ""},
+  {parse_type_8,  "andi"},
+  {parse_error,   ""},
+  {parse_type_8,  "ori"},
+  {parse_error,   ""},
+  {parse_type_8,  "ci"},
+  {parse_error,   ""},
+  {parse_type_8a, "stwp"},
+  {parse_error,   ""},
+  {parse_type_8a, "stst"},
+  {parse_error,   ""},
+  {parse_type_8b, "lwpi"},
+  {parse_error,   ""},
+  {parse_type_8b, "limi"},
+  {parse_error,   ""},
+  {parse_type_7,  "idle"},
+  {parse_error,   ""},
+  {parse_type_7,  "rset"},
+  {parse_error,   ""},
+  {parse_type_7,  "rtwp"},
+  {parse_error,   ""},
+  {parse_type_7,  "ckon"},
+  {parse_error,   ""},
+  {parse_type_7,  "ckof"},
+  {parse_error,   ""},
+  {parse_type_7,  "lrex"},
+  {parse_error,   ""},
+  {parse_error,   ""},
+  {parse_error,   ""}
+};
+
+static void parse_level_4(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  unsigned int code = (buffer->opcode >> 4) & 0x1F;
+  text = level_4[code].text;
+  level_4[code].func(buffer, info, text);
+}
+
+static struct parse_table level_3[] =
+{
+  {parse_error,   ""},
+  {parse_error,   ""},
+  {parse_level_4, ""},
+  {parse_level_4, ""},
+  {parse_level_5, ""},
+  {parse_level_5, ""},
+  {parse_level_5, ""},
+  {parse_level_5, ""},
+  {parse_type_5,  "sra"},
+  {parse_type_5,  "srl"},
+  {parse_type_5,  "sla"},
+  {parse_type_5,  "src"},
+  {parse_error,   ""},
+  {parse_error,   ""},
+  {parse_error,   ""},
+  {parse_error,   ""}
+};
+
+static void parse_level_3(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  unsigned int code = (buffer->opcode >> 8) & 0xF;
+  text = level_3[code].text;
+  level_3[code].func(buffer, info, text);
+}
+
+static struct parse_table level_2[] =
+{
+  {parse_type_2,  "jmp"},
+  {parse_type_2,  "jlt"},
+  {parse_type_2,  "jle"},
+  {parse_type_2,  "jeq"},
+  {parse_type_2,  "jhe"},
+  {parse_type_2,  "jgt"},
+  {parse_type_2,  "jne"},
+  {parse_type_2,  "jnc"},
+  {parse_type_2,  "joc"},
+  {parse_type_2,  "jno"},
+  {parse_type_2,  "jl"},
+  {parse_type_2,  "jh"},
+  {parse_type_2,  "jop"},
+  {parse_type_2a, "sbo"},
+  {parse_type_2a, "sbz"},
+  {parse_type_2a, "tb"}
+};
+
+static void parse_level_2(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  unsigned int code = (buffer->opcode >> 8) & 0xF;
+  text = level_2[code].text;
+  level_2[code].func(buffer, info, text);
+}
+
+static struct parse_table level_1[] =
+{
+  {parse_type_3, "coc"},
+  {parse_type_3, "czc"},
+  {parse_type_3, "xor"},
+  {parse_type_4, "xop"},
+  {parse_type_4, "ldcr"},
+  {parse_type_4, "stcr"},
+  {parse_type_3, "mpy"},
+  {parse_type_3, "div"}
+};
+
+static void parse_level_1(struct buffer *buffer, disassemble_info *info, char *text)
+{
+  unsigned int code = (buffer->opcode >> 10) & 0x7;
+  text = level_1[code].text;
+  level_1[code].func(buffer, info, text);
+}
+
+static struct parse_table level_0[] =
+{
+  {parse_level_3, ""},
+  {parse_level_2, ""},
+  {parse_level_1, ""},
+  {parse_level_1, ""},
+  {parse_type_1,  "szc"},
+  {parse_type_1,  "szcb"},
+  {parse_type_1,  "s"},
+  {parse_type_1,  "sb"},
+  {parse_type_1,  "c"},
+  {parse_type_1,  "cb"},
+  {parse_type_1,  "a"},
+  {parse_type_1,  "ab"},
+  {parse_type_1,  "mov"},
+  {parse_type_1,  "movb"},
+  {parse_type_1,  "soc"},
+  {parse_type_1,  "socb"}
+};
+
+int
+print_insn_tms9900 (bfd_vma addr, disassemble_info * info)
+{
+  struct buffer buf;
+  unsigned int code;
+  
+  buf.base = addr;
+  buf.n_fetch = 0;
+
+  if (! fetch_data (& buf, info, 2))
+    return -1;
+  buf.opcode = (((unsigned int)buf.data[0]) << 8) | buf.data[1];
+  code = (buf.opcode >> 12) & 0xF;
+  level_0[code].func(&buf, info, level_0[code].text);
+  return(buf.n_fetch);
+}
+
